<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>Effective Java 笔记</title>
    <link href="/2021/08/09/effective-java/"/>
    <url>/2021/08/09/effective-java/</url>
    
    <content type="html"><![CDATA[<h1 id="一、用静态工厂方法代替构造器"><a href="#一、用静态工厂方法代替构造器" class="headerlink" title="一、用静态工厂方法代替构造器"></a>一、用静态工厂方法代替构造器</h1><h3 id="优点"><a href="#优点" class="headerlink" title="优点"></a>优点</h3><ol><li>静态工厂方法与构造器不同的第一大优势在于，他们有名称</li></ol><blockquote><p>比如 BigInteger.probablePrime 直接返回可能为素数</p></blockquote><ol start="2"><li>静态工厂方法与构造器不同的第二大优势在于，不必在每次调用它们的时候都创建一个新对象</li></ol><blockquote><p>可以使用预先构建好的实例，或者将构建好的实例缓存起来， 进行重复利用，从而避免创建不必要的重复对象</p></blockquote><ol start="3"><li>静态工厂方法与构造器不同的第三大优势在于，它们可以返回原返回类型的任何子类型的对象</li></ol><blockquote><p>例如 Java Collections Framework 的集合接口有 45 个工具实现，分别提供了不可修改的集合、 同步集合，等等</p></blockquote><ol start="4"><li>静态工厂的第四大优势在于，所返回的对象的类可以随着每次调用而发生变化，这取决于静态工厂方法的参数值</li></ol><blockquote><p>..</p></blockquote><ol start="5"><li>静态工厂的第五大优势在于，方法返回的对象所属的类，在编写包含该静态工厂方法的类时可以不存在</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/** 返回Connection,该类为DriverManager.class */</span><br>    <span class="hljs-meta">@CallerSensitive</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> Connection <span class="hljs-title">getConnection</span><span class="hljs-params">(String url,</span></span><br><span class="hljs-params"><span class="hljs-function">        java.util.Properties info)</span> <span class="hljs-keyword">throws</span> SQLException </span>&#123;<br><br>        <span class="hljs-keyword">return</span> (getConnection(url, info, Reflection.getCallerClass()));<br>    &#125;<br></code></pre></td></tr></table></figure><h3 id="缺点"><a href="#缺点" class="headerlink" title="缺点"></a>缺点</h3><ol><li>静态工厂方法的主要缺点在子，类如果不含公有的或者受保护的构造器，就不能被子类化</li><li>静态工厂方法的第二个缺点在于，程序员很难发现它们</li></ol><blockquote><p>对于提供了静态工厂方法而不是构造器的类来说，要想查明如何实例化一个类是非常困难的 。</p></blockquote><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><blockquote><p>简而言之，静态工厂方法和公有构造器都有用处，我们需要理解他们各自的长处。静态工厂经常更加合适，因此切忌第一反应就是提供公有的构造器，而不先考虑静态工厂。</p></blockquote><h1 id="二、遇到多个构造器参数时要考虑使用构建器"><a href="#二、遇到多个构造器参数时要考虑使用构建器" class="headerlink" title="二、遇到多个构造器参数时要考虑使用构建器"></a>二、遇到多个构造器参数时要考虑使用构建器</h1><blockquote><p>静态工厂和构造器有个共同的局限性：它们都不能很好 扩展到大量的可选参数</p><p>重叠构造器模式可行，但是当有许多参数的时候，客户端代码会很难缩写，并且仍然较难以阅读</p><p>简而言之 如果类的构造器或者静态工厂中具有多个参数，设计这种类时， Builde模式就是一种不错的选择，</p><p>采用 <code>Buide</code> 模式</p></blockquote><h1 id="三、用私有构造器或者枚举类型强化-Singleton-属性"><a href="#三、用私有构造器或者枚举类型强化-Singleton-属性" class="headerlink" title="三、用私有构造器或者枚举类型强化 Singleton 属性"></a>三、用私有构造器或者枚举类型强化 Singleton 属性</h1>]]></content>
    
    
    
    <tags>
      
      <tag>Effective Java</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>springboot源码分析(04) - SpringApplication run</title>
    <link href="/2021/08/01/springboot-source-04/"/>
    <url>/2021/08/01/springboot-source-04/</url>
    
    <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>上节讲了 <code>SpringApplication</code> 的构造方法，这节咱们来看下 <code>SpringApplication</code> 的 <code>run</code> 方法。</p><h1 id="run方法"><a href="#run方法" class="headerlink" title="run方法"></a>run方法</h1><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// SpringApplication.java</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> ConfigurableApplicationContext <span class="hljs-title">run</span><span class="hljs-params">(String... args)</span> </span>&#123;<br>  <span class="hljs-comment">// &lt;1&gt; 创建 StopWatch 对象，并启动。StopWatch 主要用于简单统计 run 启动过程的时长。</span><br>StopWatch stopWatch = <span class="hljs-keyword">new</span> StopWatch();<br>stopWatch.start();<br>  <span class="hljs-comment">// 初始化ApplicationContext</span><br>ConfigurableApplicationContext context = <span class="hljs-keyword">null</span>;<br>Collection&lt;SpringBootExceptionReporter&gt; exceptionReporters = <span class="hljs-keyword">new</span> ArrayList&lt;&gt;();<br>  <span class="hljs-comment">// &lt;2&gt; 配置 headless 属性</span><br>configureHeadlessProperty();<br>  <span class="hljs-comment">// &lt;3&gt; 获得 SpringApplicationRunListener 的数组，并启动监听</span><br>SpringApplicationRunListeners listeners = getRunListeners(args);<br>  <span class="hljs-comment">// &lt;3.1&gt; 构建 ApplicationStartingEvent 事件，并且启动</span><br>listeners.starting();<br><span class="hljs-keyword">try</span> &#123;<br>      <span class="hljs-comment">// &lt;4&gt; 创建  ApplicationArguments 对象</span><br>ApplicationArguments applicationArguments = <span class="hljs-keyword">new</span> DefaultApplicationArguments(args);<br>      <span class="hljs-comment">// &lt;5&gt; 加载属性配置。执行完成后，所有的 environment 的属性都会加载进来，包括 application.properties 和外部的属性配置。</span><br>ConfigurableEnvironment environment = prepareEnvironment(listeners, applicationArguments);<br>configureIgnoreBeanInfo(environment);<br><span class="hljs-comment">// &lt;6&gt; 打印 Spring Banner</span><br>      Banner printedBanner = printBanner(environment);<br>      <span class="hljs-comment">// &lt;7&gt; 创建 Spring 容器。</span><br>context = createApplicationContext();<br>      <span class="hljs-comment">// &lt;8&gt; 异常报告器</span><br>exceptionReporters = getSpringFactoriesInstances(SpringBootExceptionReporter.class,<br><span class="hljs-keyword">new</span> Class[] &#123; ConfigurableApplicationContext.class &#125;, context);<br>      <span class="hljs-comment">// &lt;9&gt; 主要是调用所有初始化类的 initialize 方法</span><br>prepareContext(context, environment, listeners, applicationArguments, printedBanner);<br><span class="hljs-comment">// &lt;10&gt; 初始化 Spring 容器。</span><br>      refreshContext(context);<br>      <span class="hljs-comment">// &lt;11&gt; 执行 Spring 容器的初始化的后置逻辑。默认实现为空。</span><br>afterRefresh(context, applicationArguments);<br>      <span class="hljs-comment">// &lt;12&gt; 停止 StopWatch 统计时长</span><br>stopWatch.stop();<br>      <span class="hljs-comment">// &lt;13&gt; 打印 Spring Boot 启动的时长日志。</span><br><span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span>.logStartupInfo) &#123;<br><span class="hljs-keyword">new</span> StartupInfoLogger(<span class="hljs-keyword">this</span>.mainApplicationClass).logStarted(getApplicationLog(), stopWatch);<br>&#125;<br>      <span class="hljs-comment">// &lt;14&gt; 通知 SpringApplicationRunListener 的数组，Spring 容器启动完成。</span><br>listeners.started(context);<br>      <span class="hljs-comment">// &lt;15&gt; 调用 ApplicationRunner 或者 CommandLineRunner 的运行方法。</span><br>callRunners(context, applicationArguments);<br>&#125;<br><span class="hljs-keyword">catch</span> (Throwable ex) &#123;<br>      <span class="hljs-comment">// &lt;15.1&gt; 如果发生异常，则进行处理，并抛出 IllegalStateException 异常</span><br>handleRunFailure(context, ex, exceptionReporters, listeners);<br><span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> IllegalStateException(ex);<br>&#125;<br><br>  <span class="hljs-comment">// &lt;16&gt; 通知 SpringApplicationRunListener 的数组，Spring 容器运行中。</span><br><span class="hljs-keyword">try</span> &#123;<br>listeners.running(context);<br>&#125;<br><span class="hljs-keyword">catch</span> (Throwable ex) &#123;<br>      <span class="hljs-comment">// &lt;16.1&gt; 如果发生异常，则进行处理，并抛出 IllegalStateException 异常</span><br>handleRunFailure(context, ex, exceptionReporters, <span class="hljs-keyword">null</span>);<br><span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> IllegalStateException(ex);<br>&#125;<br><span class="hljs-keyword">return</span> context;<br>&#125;<br></code></pre></td></tr></table></figure><blockquote><p>咱们可以重点关注下一下几个点。</p></blockquote><ol><li><p>&lt;1&gt; 处， <code>StopWatch</code> 主要用于简单统计 <code>run</code> 启动过程的时长。</p></li><li><p>&lt;2&gt; 处，配置 <code>awt</code> &gt; <code>java.awt.headless</code> 为 <code>true</code>。</p></li><li><p>&lt;3&gt; 处，调用 <code>#getRunListeners(String[] args)</code> 方法，获得 <code>SpringApplicationRunListener</code> 数组，并启动监听。调用位置咱们在讲解 <a href="https://mengsu.site/2021/07/31/springboot-source-03/#SpringFactoriesLoader-loadFactoryNames">SpringApplication构造方法</a> 中提到过，这是是读取缓存中的值 <code>Map&lt;ClassLoader, MultiValueMap&lt;String, String&gt;&gt; cache</code> 。</p><p>&lt;3.1&gt; 处，构建了一个ApplicationStartingEvent事件，并将其发布出去，其中调用了resolveDefaultEventType方法，该方法返回了一个封装了事件的默认类型（ApplicationStartingEvent）的ResolvableType对象。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Override</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">multicastEvent</span><span class="hljs-params">(<span class="hljs-keyword">final</span> ApplicationEvent event, <span class="hljs-meta">@Nullable</span> ResolvableType eventType)</span> </span>&#123;<br>ResolvableType type = (eventType != <span class="hljs-keyword">null</span> ? eventType : resolveDefaultEventType(event));<br>Executor executor = getTaskExecutor();<br><span class="hljs-keyword">for</span> (ApplicationListener&lt;?&gt; listener : getApplicationListeners(event, type)) &#123;<br><span class="hljs-keyword">if</span> (executor != <span class="hljs-keyword">null</span>) &#123;<br>executor.execute(() -&gt; invokeListener(listener, event));<br>&#125;<br><span class="hljs-keyword">else</span> &#123;<br>invokeListener(listener, event);<br>&#125;<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>这里不得不提的就是springboot的事件机制</p><blockquote><p>事件源：SpringApplication</p><p>事件：ApplicationStartingEvent</p><p>监听器：过滤后的监听器，具体5个上文中已经说过</p><p>事件环境：EventPublishingListener，提供环境支持事件，并且发布事件（starting方法）</p></blockquote><blockquote><p>初略的看，就是遍历getApplicationListeners(event, type)，然后对每个listener进行invokeListener(listener, event)</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">protected</span> Collection&lt;ApplicationListener&lt;?&gt;&gt; getApplicationListeners(<br>ApplicationEvent event, ResolvableType eventType) &#123;<br><br>Object source = event.getSource();<br>Class&lt;?&gt; sourceType = (source != <span class="hljs-keyword">null</span> ? source.getClass() : <span class="hljs-keyword">null</span>);<br>ListenerCacheKey cacheKey = <span class="hljs-keyword">new</span> ListenerCacheKey(eventType, sourceType);<br><br><span class="hljs-comment">// Quick check for existing entry on ConcurrentHashMap...</span><br>ListenerRetriever retriever = <span class="hljs-keyword">this</span>.retrieverCache.get(cacheKey);<br><span class="hljs-keyword">if</span> (retriever != <span class="hljs-keyword">null</span>) &#123;<br><span class="hljs-keyword">return</span> retriever.getApplicationListeners();<br>&#125;<br><br><span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span>.beanClassLoader == <span class="hljs-keyword">null</span> ||<br>(ClassUtils.isCacheSafe(event.getClass(), <span class="hljs-keyword">this</span>.beanClassLoader) &amp;&amp;<br>(sourceType == <span class="hljs-keyword">null</span> || ClassUtils.isCacheSafe(sourceType, <span class="hljs-keyword">this</span>.beanClassLoader)))) &#123;<br><span class="hljs-comment">// Fully synchronized building and caching of a ListenerRetriever</span><br><span class="hljs-keyword">synchronized</span> (<span class="hljs-keyword">this</span>.retrievalMutex) &#123;<br>retriever = <span class="hljs-keyword">this</span>.retrieverCache.get(cacheKey);<br><span class="hljs-keyword">if</span> (retriever != <span class="hljs-keyword">null</span>) &#123;<br><span class="hljs-keyword">return</span> retriever.getApplicationListeners();<br>&#125;<br>retriever = <span class="hljs-keyword">new</span> ListenerRetriever(<span class="hljs-keyword">true</span>);<br>Collection&lt;ApplicationListener&lt;?&gt;&gt; listeners =<br>retrieveApplicationListeners(eventType, sourceType, retriever);<br><span class="hljs-keyword">this</span>.retrieverCache.put(cacheKey, retriever);<br><span class="hljs-keyword">return</span> listeners;<br>&#125;<br>&#125;<br><span class="hljs-keyword">else</span> &#123;<br><span class="hljs-comment">// No ListenerRetriever caching -&gt; no synchronization necessary</span><br><span class="hljs-keyword">return</span> retrieveApplicationListeners(eventType, sourceType, <span class="hljs-keyword">null</span>);<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><blockquote><p>从上图可知，主要涉及到3个点：缓存retrieverCache、retrieveApplicationListeners已经retrieveApplicationListeners中调用的supportsEvent方法。流程是这样的：</p><p>1、缓存中是否有匹配的结果，有则返回</p><p>2、若缓存中没有匹配的结果，则从this.defaultRetriever.applicationListeners中过滤，这个this表示的EventPublishingRunListener对象的属性initialMulticaster（也就是SimpleApplicationEventMulticaster对象，而defaultRetriever.applicationListeners的值也是在EventPublishingRunListener构造方法中初始化的）</p><p>3、过滤过程，遍历defaultRetriever.applicationListeners集合，从中找出ApplicationStartingEvent匹配的listener，具体的匹配规则需要看各个listener的supportsEventType方法（有两个重载的方法）</p><p>4、将过滤的结果缓存到retrieverCache</p><p>5、将过滤出的结果返回回去</p></blockquote><p>过滤出的listener对象有哪些:</p><p><img src="/images/springboot/springboot-run-starting.png"></p><blockquote><p>invokeListener</p><p>使用给定的事件调用给定的监听器</p><p>　　getApplicationListeners方法过滤出的监听器都会被调用，过滤出来的监听器包括LoggingApplicationListener、BackgroundPreinitializer、DelegatingApplicationListener、LiquibaseServiceLocatorApplicationListener、EnableEncryptablePropertiesBeanFactoryPostProcessor五种类型的对象。这五个对象的onApplicationEvent都会被调用。</p><p>　　那么这五个监听器的onApplicationEvent都做了些什么了</p><p>　　　　　　LoggingApplicationListener：检测正在使用的日志系统，默认是logback，支持3种，优先级从高到低：logback &gt; log4j &gt; javalog。此时日志系统还没有初始化</p><p>　　　　　　BackgroundPreinitializer：另起一个线程实例化Initializer并调用其run方法，包括验证器、消息转换器等等</p><p>　　　　　　DelegatingApplicationListener：此时什么也没做</p><p>　　　　　　LiquibaseServiceLocatorApplicationListener：此时什么也没做</p><p>　　　　　　EnableEncryptablePropertiesBeanFactoryPostProcessor：此时仅仅打印了一句日志，其他什么也没做</p></blockquote></li><li><p>&lt;4&gt; 处，创建 <code>DefaultApplicationArguments</code> </p></li><li><p>&lt;5&gt; 处，调用 <code>#prepareEnvironment(SpringApplicationRunListeners listeners, ApplicationArguments applicationArguments)</code> 方法，加载属性配置。执行完成后，所有的 environment 的属性都会加载进来，包括 <code>application.properties</code> 和外部的属性配置。</p></li><li><p>&lt;6&gt; 处，调用 <code>#printBanner(ConfigurableEnvironment environment)</code> 方法，打印 Spring Banner 。</p></li><li><p>&lt;7&gt; 处，调用 <code>#createApplicationContext()</code> 方法，创建 Spring 容器。请看代码：</p></li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">protected</span> ConfigurableApplicationContext <span class="hljs-title">createApplicationContext</span><span class="hljs-params">()</span> </span>&#123;<br>Class&lt;?&gt; contextClass = <span class="hljs-keyword">this</span>.applicationContextClass;<br><span class="hljs-keyword">if</span> (contextClass == <span class="hljs-keyword">null</span>) &#123;<br><span class="hljs-keyword">try</span> &#123;<br><span class="hljs-keyword">switch</span> (<span class="hljs-keyword">this</span>.webApplicationType) &#123;<br><span class="hljs-keyword">case</span> SERVLET: <span class="hljs-comment">// 这里</span><br>contextClass = Class.forName(DEFAULT_SERVLET_WEB_CONTEXT_CLASS);<br><span class="hljs-keyword">break</span>;<br><span class="hljs-keyword">case</span> REACTIVE:<br>contextClass = Class.forName(DEFAULT_REACTIVE_WEB_CONTEXT_CLASS);<br><span class="hljs-keyword">break</span>;<br><span class="hljs-keyword">default</span>:<br>contextClass = Class.forName(DEFAULT_CONTEXT_CLASS);<br>&#125;<br>&#125;<br><span class="hljs-keyword">catch</span> (ClassNotFoundException ex) &#123;<br><span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> IllegalStateException(<br><span class="hljs-string">&quot;Unable create a default ApplicationContext, &quot;</span> + <span class="hljs-string">&quot;please specify an ApplicationContextClass&quot;</span>,<br>ex);<br>&#125;<br>&#125;<br><span class="hljs-keyword">return</span> (ConfigurableApplicationContext) BeanUtils.instantiateClass(contextClass);<br>&#125;<br></code></pre></td></tr></table></figure><blockquote><p>根据SpringApplication的webApplicationType来实例化对应的上下文；如果webApplicationType的值是SERVLET，那么实例化AnnotationConfigServletWebServerApplicationContext，如果是REACTIVE则实例化AnnotationConfigReactiveWebServerApplicationContext（响应式编程，后续再看），如果既不是SERVLET、也不是REACTIVE，那么则是默认情况（也就是我们所说的非web引用），实例化AnnotationConfigApplicationContext。很显然我们目前的应用类型是SERVLET，那么实例化AnnotationConfigServletWebServerApplicationContext。</p></blockquote><ol start="8"><li><p>&lt;8&gt; 处，…</p></li><li><p>&lt;9&gt; 处，<code>#prepareContext(ConfigurableApplicationContext context, ConfigurableEnvironment environment, SpringApplicationRunListeners listeners, ApplicationArguments applicationArguments, Banner printedBanner)</code> 方法，准备 ApplicationContext 对象，主要是初始化它的一些属性。</p></li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">prepareContext</span><span class="hljs-params">(ConfigurableApplicationContext context, ConfigurableEnvironment environment,</span></span><br><span class="hljs-params"><span class="hljs-function">SpringApplicationRunListeners listeners, ApplicationArguments applicationArguments, Banner printedBanner)</span> </span>&#123;<br><span class="hljs-comment">// &lt;1&gt; 设置 context 的 environment 属性</span><br>  context.setEnvironment(environment);<br>  <span class="hljs-comment">// &lt;2&gt; 设置 context 的一些属性</span><br>postProcessApplicationContext(context);<br>  <span class="hljs-comment">// &lt;3&gt; 初始化 ApplicationContextInitializer</span><br>applyInitializers(context);<br>  <span class="hljs-comment">// &lt;4&gt; 通知 SpringApplicationRunListener 的数组，Spring 容器准备完成。</span><br>listeners.contextPrepared(context);<br>  <span class="hljs-comment">// &lt;5&gt; 打印日志</span><br><span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span>.logStartupInfo) &#123;<br>logStartupInfo(context.getParent() == <span class="hljs-keyword">null</span>);<br>logStartupProfileInfo(context);<br>&#125;<br><span class="hljs-comment">// Add boot specific singleton beans</span><br>  <span class="hljs-comment">// &lt;6&gt; 设置 beanFactory 的属性</span><br>ConfigurableListableBeanFactory beanFactory = context.getBeanFactory();<br>beanFactory.registerSingleton(<span class="hljs-string">&quot;springApplicationArguments&quot;</span>, applicationArguments);<br><span class="hljs-keyword">if</span> (printedBanner != <span class="hljs-keyword">null</span>) &#123;<br>beanFactory.registerSingleton(<span class="hljs-string">&quot;springBootBanner&quot;</span>, printedBanner);<br>&#125;<br><span class="hljs-keyword">if</span> (beanFactory <span class="hljs-keyword">instanceof</span> DefaultListableBeanFactory) &#123;<br>((DefaultListableBeanFactory) beanFactory)<br>.setAllowBeanDefinitionOverriding(<span class="hljs-keyword">this</span>.allowBeanDefinitionOverriding);<br>&#125;<br><span class="hljs-comment">// Load the sources</span><br>  <span class="hljs-comment">// &lt;7&gt; 加载 BeanDefinition 们</span><br>Set&lt;Object&gt; sources = getAllSources();<br>Assert.notEmpty(sources, <span class="hljs-string">&quot;Sources must not be empty&quot;</span>);<br>load(context, sources.toArray(<span class="hljs-keyword">new</span> Object[<span class="hljs-number">0</span>]));<br>  <span class="hljs-comment">// &lt;8&gt; 通知 SpringApplicationRunListener 的数组，Spring 容器加载完成。</span><br>listeners.contextLoaded(context);<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    
    <tags>
      
      <tag>SpringBoot</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>springboot源码分析(03) - SpringApplication构造方法</title>
    <link href="/2021/07/31/springboot-source-03/"/>
    <url>/2021/07/31/springboot-source-03/</url>
    
    <content type="html"><![CDATA[<h1 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h1><p>上节自己搭建的 <code>web</code> 例子</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">import</span> org.springframework.boot.SpringApplication;<br><span class="hljs-keyword">import</span> org.springframework.boot.autoconfigure.SpringBootApplication;<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@Author</span>: mengsu</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@Date</span>: 2021/7/30</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@Description</span>:</span><br><span class="hljs-comment"> */</span><br><span class="hljs-meta">@SpringBootApplication</span> <span class="hljs-comment">// &lt;1&gt;</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MyTestMVCApplication</span> </span>&#123;<br><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>SpringApplication.run(MyTestMVCApplication.class, args);  <span class="hljs-comment">// &lt;2&gt;</span><br>&#125;<br><br>&#125;<br></code></pre></td></tr></table></figure><ul><li><code>&lt;1&gt;</code> 处，使用 <code>@SpringBootApplication</code> 注解，标明是 Spring Boot 应用。通过它，可以开启自动配置的功能。</li><li><code>&lt;2&gt;</code> 处，调用 <code>SpringApplication#run(Class&lt;?&gt;... primarySources)</code> 方法，启动 Spring Boot 应用。</li></ul><p>上述的代码，是我们使用 Spring Boot 时，最最最常用的代码。而本文，我们先来分析 Spring Boot 应用的<strong>启动过程</strong>。</p><h3 id="SpringApplication类注释"><a href="#SpringApplication类注释" class="headerlink" title="SpringApplication类注释"></a>SpringApplication类注释</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Class that can be used to bootstrap and launch a Spring application from a Java main</span><br><span class="hljs-comment"> * method. By default class will perform the following steps to bootstrap your</span><br><span class="hljs-comment"> * application:</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> * &lt;ul&gt;</span><br><span class="hljs-comment"> * &lt;li&gt;Create an appropriate &#123;<span class="hljs-doctag">@link</span> ApplicationContext&#125; instance (depending on your</span><br><span class="hljs-comment"> * classpath)&lt;/li&gt;</span><br><span class="hljs-comment"> * &lt;li&gt;Register a &#123;<span class="hljs-doctag">@link</span> CommandLinePropertySource&#125; to expose command line arguments as</span><br><span class="hljs-comment"> * Spring properties&lt;/li&gt;</span><br><span class="hljs-comment"> * &lt;li&gt;Refresh the application context, loading all singleton beans&lt;/li&gt;</span><br><span class="hljs-comment"> * &lt;li&gt;Trigger any &#123;<span class="hljs-doctag">@link</span> CommandLineRunner&#125; beans&lt;/li&gt;</span><br><span class="hljs-comment"> * &lt;/ul&gt;</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> * In most circumstances the static &#123;<span class="hljs-doctag">@link</span> #run(Class, String[])&#125; method can be called</span><br><span class="hljs-comment"> * directly from your &#123;<span class="hljs-doctag">@literal</span> main&#125; method to bootstrap your application:</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> * &lt;pre class=&quot;code&quot;&gt;</span><br><span class="hljs-comment"> * &amp;#064;Configuration</span><br><span class="hljs-comment"> * &amp;#064;EnableAutoConfiguration</span><br><span class="hljs-comment"> * public class MyApplication  &#123;</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> *   // ... Bean definitions</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> *   public static void main(String[] args) &#123;</span><br><span class="hljs-comment"> *     SpringApplication.run(MyApplication.class, args);</span><br><span class="hljs-comment"> *   &#125;</span><br><span class="hljs-comment"> * &#125;</span><br><span class="hljs-comment"> * &lt;/pre&gt;</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> * &lt;p&gt;</span><br><span class="hljs-comment"> * For more advanced configuration a &#123;<span class="hljs-doctag">@link</span> SpringApplication&#125; instance can be created and</span><br><span class="hljs-comment"> * customized before being run:</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> * &lt;pre class=&quot;code&quot;&gt;</span><br><span class="hljs-comment"> * public static void main(String[] args) &#123;</span><br><span class="hljs-comment"> *   SpringApplication application = new SpringApplication(MyApplication.class);</span><br><span class="hljs-comment"> *   // ... customize application settings here</span><br><span class="hljs-comment"> *   application.run(args)</span><br><span class="hljs-comment"> * &#125;</span><br><span class="hljs-comment"> * &lt;/pre&gt;</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> * &#123;<span class="hljs-doctag">@link</span> SpringApplication&#125;s can read beans from a variety of different sources. It is</span><br><span class="hljs-comment"> * generally recommended that a single &#123;<span class="hljs-doctag">@code</span> <span class="hljs-doctag">@Configuration</span>&#125; class is used to bootstrap</span><br><span class="hljs-comment"> * your application, however, you may also set &#123;<span class="hljs-doctag">@link</span> #getSources() sources&#125; from:</span><br><span class="hljs-comment"> * &lt;ul&gt;</span><br><span class="hljs-comment"> * &lt;li&gt;The fully qualified class name to be loaded by</span><br><span class="hljs-comment"> * &#123;<span class="hljs-doctag">@link</span> AnnotatedBeanDefinitionReader&#125;&lt;/li&gt;</span><br><span class="hljs-comment"> * &lt;li&gt;The location of an XML resource to be loaded by &#123;<span class="hljs-doctag">@link</span> XmlBeanDefinitionReader&#125;, or</span><br><span class="hljs-comment"> * a groovy script to be loaded by &#123;<span class="hljs-doctag">@link</span> GroovyBeanDefinitionReader&#125;&lt;/li&gt;</span><br><span class="hljs-comment"> * &lt;li&gt;The name of a package to be scanned by &#123;<span class="hljs-doctag">@link</span> ClassPathBeanDefinitionScanner&#125;&lt;/li&gt;</span><br><span class="hljs-comment"> * &lt;/ul&gt;</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> * Configuration properties are also bound to the &#123;<span class="hljs-doctag">@link</span> SpringApplication&#125;. This makes it</span><br><span class="hljs-comment"> * possible to set &#123;<span class="hljs-doctag">@link</span> SpringApplication&#125; properties dynamically, like additional</span><br><span class="hljs-comment"> * sources (&quot;spring.main.sources&quot; - a CSV list) the flag to indicate a web environment</span><br><span class="hljs-comment"> * (&quot;spring.main.web-application-type=none&quot;) or the flag to switch off the banner</span><br><span class="hljs-comment"> * (&quot;spring.main.banner-mode=off&quot;).</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@author</span> Phillip Webb</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@author</span> Dave Syer</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@author</span> Andy Wilkinson</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@author</span> Christian Dupuis</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@author</span> Stephane Nicoll</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@author</span> Jeremy Rickard</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@author</span> Craig Burke</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@author</span> Michael Simons</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@author</span> Madhura Bhave</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@author</span> Brian Clozel</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@author</span> Ethan Rubinson</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@since</span> 1.0.0</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@see</span> #run(Class, String[])</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@see</span> #run(Class[], String[])</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@see</span> #SpringApplication(Class...)</span><br><span class="hljs-comment"> */</span><br></code></pre></td></tr></table></figure><p><code>SpringApplication</code> 用于从 <code>java main</code> 方法引导和启动 <code>Spring</code> 应用程序，默认情况下，将执行以下步骤来引导我们的应用程序：</p><ol><li>创建一个恰当的 <code>ApplicationContext</code> 实例（取决于类路径）</li><li>注册 <code>CommandLinePropertySource</code> ，将命令行参数公开为 <code>Spring</code> 属性</li><li>刷新应用程序上下文，加载所有单例 <code>bean</code></li><li>触发全部 <code>CommandLineRunner bean</code></li></ol><p>大多数情况下，像 <code>SpringApplication.run(MyTestMVCApplication, args)</code> ; 这样启动我们的应用，也可以在运行之前创建和自定义 <code>SpringApplication</code> 实例，具体可以参考注释中示例。<code>SpringApplication</code> 可以从各种不同的源读取bean。 通常建议使用单个 <code>@Configuration</code> 类来引导，但是我们也可以通过以下方式来设置资源：</p><ol><li>通过 <code>AnnotatedBeanDefinitionReader</code> 加载完全限定类名</li><li>通过 <code>XmlBeanDefinitionReader</code> 加载 XML 资源位置，或者是通过 <code>GroovyBeanDefinitionReader</code> 加载 <code>groovy</code> 脚本位置</li><li>通过 <code>ClassPathBeanDefinitionScanner</code> 扫描包名称</li></ol><p>也就是说 <code>SpringApplication</code> 还是做了不少事的，具体实现后续会慢慢讲来，今天的主角只是 <code>SpringApplication</code> 构造方法。</p><h1 id="SpringApplication构造方法"><a href="#SpringApplication构造方法" class="headerlink" title="SpringApplication构造方法"></a>SpringApplication构造方法</h1><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123; <span class="hljs-comment">// &lt;1&gt;</span><br>SpringApplication.run(MyTestMVCApplication.class, args);   <br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> ConfigurableApplicationContext <span class="hljs-title">run</span><span class="hljs-params">(Class&lt;?&gt; primarySource, String... args)</span> </span>&#123; <span class="hljs-comment">// &lt;2&gt;</span><br><span class="hljs-keyword">return</span> run(<span class="hljs-keyword">new</span> Class&lt;?&gt;[] &#123; primarySource &#125;, args);<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> ConfigurableApplicationContext <span class="hljs-title">run</span><span class="hljs-params">(Class&lt;?&gt;[] primarySources, String[] args)</span> </span>&#123; <span class="hljs-comment">// &lt;3&gt;</span><br><span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> SpringApplication(primarySources).run(args);   <br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">SpringApplication</span><span class="hljs-params">(Class&lt;?&gt;... primarySources)</span> </span>&#123; <span class="hljs-comment">// &lt;4&gt;</span><br><span class="hljs-keyword">this</span>(<span class="hljs-keyword">null</span>, primarySources);<br>&#125;<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Create a new &#123;<span class="hljs-doctag">@link</span> SpringApplication&#125; instance. The application context will load</span><br><span class="hljs-comment"> * beans from the specified primary sources (see &#123;<span class="hljs-doctag">@link</span> SpringApplication class-level&#125;</span><br><span class="hljs-comment"> * documentation for details. The instance can be customized before calling</span><br><span class="hljs-comment"> * &#123;<span class="hljs-doctag">@link</span> #run(String...)&#125;.</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@param</span> resourceLoader the resource loader to use</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@param</span> primarySources the primary bean sources</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@see</span> #run(Class, String[])</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@see</span> #setSources(Set)</span><br><span class="hljs-comment"> */</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">SpringApplication</span><span class="hljs-params">(ResourceLoader resourceLoader, Class&lt;?&gt;... primarySources)</span> </span>&#123; <span class="hljs-comment">// &lt;5&gt;</span><br><span class="hljs-keyword">this</span>.resourceLoader = resourceLoader;   <br>Assert.notNull(primarySources, <span class="hljs-string">&quot;PrimarySources must not be null&quot;</span>);<br><span class="hljs-keyword">this</span>.primarySources = <span class="hljs-keyword">new</span> LinkedHashSet&lt;&gt;(Arrays.asList(primarySources)); <br><span class="hljs-keyword">this</span>.webApplicationType = WebApplicationType.deduceFromClasspath(); <span class="hljs-comment">// &lt;5.1&gt;</span><br>setInitializers((Collection) getSpringFactoriesInstances(ApplicationContextInitializer.class));  <span class="hljs-comment">// &lt;5.2&gt;</span><br>setListeners((Collection) getSpringFactoriesInstances(ApplicationListener.class)); <span class="hljs-comment">// &lt;5.3&gt;</span><br><span class="hljs-keyword">this</span>.mainApplicationClass = deduceMainApplicationClass();  <span class="hljs-comment">// &lt;5.4&gt;</span><br>&#125;<br></code></pre></td></tr></table></figure><p>按照层级跳转分为以上五个层级结构，可以发现咱们自定义的 <code>MyTestMVCApplication main</code> 方法都是调用的 <code>SpringApplication</code> 静态方法，直接到达的构造函数。</p><p>从 <code>SpringApplication</code> 构造函数的注释上来看，就是说创建一个 <code>MyTestMVCApplication </code>实例，应用上下文从特定的资源文件中加载<code>bean</code>。可以在调用<code>run</code>之前自定义实例。</p><h2 id="5-1-WebApplicationType-deduceFromClasspath"><a href="#5-1-WebApplicationType-deduceFromClasspath" class="headerlink" title="5.1 WebApplicationType.deduceFromClasspath()"></a>5.1 WebApplicationType.deduceFromClasspath()</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">static</span> WebApplicationType <span class="hljs-title">deduceFromClasspath</span><span class="hljs-params">()</span> </span>&#123;<br><span class="hljs-keyword">if</span> (ClassUtils.isPresent(WEBFLUX_INDICATOR_CLASS, <span class="hljs-keyword">null</span>) &amp;&amp; !ClassUtils.isPresent(WEBMVC_INDICATOR_CLASS, <span class="hljs-keyword">null</span>)<br>&amp;&amp; !ClassUtils.isPresent(JERSEY_INDICATOR_CLASS, <span class="hljs-keyword">null</span>)) &#123;<br><span class="hljs-keyword">return</span> WebApplicationType.REACTIVE;<br>&#125;<br><span class="hljs-keyword">for</span> (String className : SERVLET_INDICATOR_CLASSES) &#123;<br>     <span class="hljs-comment">// 判断给定的类是否能够加载，就是说类路径下是否存在给定的类</span><br><span class="hljs-keyword">if</span> (!ClassUtils.isPresent(className, <span class="hljs-keyword">null</span>)) &#123;<br><span class="hljs-keyword">return</span> WebApplicationType.NONE;<br>&#125;<br>&#125;<br><span class="hljs-keyword">return</span> WebApplicationType.SERVLET;<br>&#125;<br></code></pre></td></tr></table></figure><blockquote><p>如果<code>org.springframework.web.reactive.DispatcherHandler</code>能够被加载且<code>org.springframework.web.servlet.DispatcherServlet</code>不能够被加载，那么断定<code>web</code>应用类型是<code>REACTIVE</code>；如果<code>javax.servlet.Servlet</code>和<code>org.springframework.web.context.ConfigurableWebApplicationContext</code>任意一个不能被加载，那么断定<code>web</code>应用类型是<code>NONE</code>；如果不能断定是<code>REACTIVE</code>和<code>NONE</code>，那么就是<code>SERVLET</code>类型；具体这三种类型代表什么含义，可以查看WebApplicationType中的说明。　　</p></blockquote><h2 id="5-2-setInitializers-Collection-getSpringFactoriesInstances-ApplicationContextInitializer-class"><a href="#5-2-setInitializers-Collection-getSpringFactoriesInstances-ApplicationContextInitializer-class" class="headerlink" title="5.2 setInitializers((Collection) getSpringFactoriesInstances(ApplicationContextInitializer.class));"></a>5.2 setInitializers((Collection) getSpringFactoriesInstances(ApplicationContextInitializer.class));</h2><blockquote><p>从字面意思看就是获取spring工厂实例，至于从哪获取哪些工厂实例，我们往下看。</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">private</span> &lt;T&gt; <span class="hljs-function">Collection&lt;T&gt; <span class="hljs-title">getSpringFactoriesInstances</span><span class="hljs-params">(Class&lt;T&gt; type)</span> </span>&#123; <span class="hljs-comment">// &lt;1&gt;</span><br><span class="hljs-keyword">return</span> getSpringFactoriesInstances(type, <span class="hljs-keyword">new</span> Class&lt;?&gt;[] &#123;&#125;);<br>&#125;<br><br><span class="hljs-keyword">private</span> &lt;T&gt; <span class="hljs-function">Collection&lt;T&gt; <span class="hljs-title">getSpringFactoriesInstances</span><span class="hljs-params">(Class&lt;T&gt; type, Class&lt;?&gt;[] parameterTypes, Object... args)</span> </span>&#123; <span class="hljs-comment">// &lt;2&gt;</span><br>ClassLoader classLoader = getClassLoader();<br><span class="hljs-comment">// Use names and ensure unique to protect against duplicates</span><br>Set&lt;String&gt; names = <span class="hljs-keyword">new</span> LinkedHashSet&lt;&gt;(SpringFactoriesLoader.loadFactoryNames(type, classLoader));<br>List&lt;T&gt; instances = createSpringFactoriesInstances(type, parameterTypes, classLoader, args, names);<br>AnnotationAwareOrderComparator.sort(instances);<br><span class="hljs-keyword">return</span> instances;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="SpringFactoriesLoader-loadFactoryNames"><a href="#SpringFactoriesLoader-loadFactoryNames" class="headerlink" title="SpringFactoriesLoader.loadFactoryNames"></a>SpringFactoriesLoader.loadFactoryNames</h3><blockquote><p><strong>SpringFactoriesLoader.loadFactoryNames</strong> 可以先留意下，该处代码会在 <code>run</code> 的时候进行读取，可以看到现在的作用就是为了初始化实例，并且放在缓存当中。</p><ol><li><p>查找类路径下全部的META-INF/spring.factories的URL</p></li><li><p>根据url加载全部的spring.factories中的属性，spring.factories内容如下</p></li><li><p>将所有spring.factories中的值缓存到SpringFactoriesLoader的cache中：</p><p>private static final Map&lt;ClassLoader, MultiValueMap&lt;String, String&gt;&gt; cache = new ConcurrentReferenceHashMap&lt;&gt;()；方便下次调用。</p></li></ol></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> List&lt;String&gt; <span class="hljs-title">loadFactoryNames</span><span class="hljs-params">(Class&lt;?&gt; factoryClass, <span class="hljs-meta">@Nullable</span> ClassLoader classLoader)</span> </span>&#123;<br>String factoryClassName = factoryClass.getName();<br><span class="hljs-keyword">return</span> loadSpringFactories(classLoader).getOrDefault(factoryClassName, Collections.emptyList());<br>&#125;<br><br><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> Map&lt;String, List&lt;String&gt;&gt; loadSpringFactories(<span class="hljs-meta">@Nullable</span> ClassLoader classLoader) &#123;<br>MultiValueMap&lt;String, String&gt; result = cache.get(classLoader);<br><span class="hljs-keyword">if</span> (result != <span class="hljs-keyword">null</span>) &#123;<br><span class="hljs-keyword">return</span> result;<br>&#125;<br><br><span class="hljs-keyword">try</span> &#123;<br>     <span class="hljs-comment">// classLoader.getResources(FACTORIES_RESOURCE_LOCATION)获取类路径下全部的META-INF/spring.factories的URL</span><br>Enumeration&lt;URL&gt; urls = (classLoader != <span class="hljs-keyword">null</span> ?<br>classLoader.getResources(FACTORIES_RESOURCE_LOCATION) :<br>ClassLoader.getSystemResources(FACTORIES_RESOURCE_LOCATION));<br>result = <span class="hljs-keyword">new</span> LinkedMultiValueMap&lt;&gt;();<br>     <span class="hljs-comment">// 遍历全部的URL，逐个读取META-INF/spring.factories中的属性</span><br><span class="hljs-keyword">while</span> (urls.hasMoreElements()) &#123;<br>URL url = urls.nextElement();<br>UrlResource resource = <span class="hljs-keyword">new</span> UrlResource(url);<br>Properties properties = PropertiesLoaderUtils.loadProperties(resource);<br><span class="hljs-keyword">for</span> (Map.Entry&lt;?, ?&gt; entry : properties.entrySet()) &#123;<br>String factoryClassName = ((String) entry.getKey()).trim();<br>         <span class="hljs-comment">// 属性全部放入MultiValueMap&lt;String, String&gt; result中，注意result的类型</span><br><span class="hljs-keyword">for</span> (String factoryName : StringUtils.commaDelimitedListToStringArray((String) entry.getValue())) &#123;<br>result.add(factoryClassName, factoryName.trim());<br>&#125;<br>&#125;<br>&#125;<br>     <span class="hljs-comment">// 结果放入缓存，方便下次查找，run方法中会使用缓存</span><br>cache.put(classLoader, result);<br><span class="hljs-keyword">return</span> result;<br>&#125;<br><span class="hljs-keyword">catch</span> (IOException ex) &#123;<br><span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> IllegalArgumentException(<span class="hljs-string">&quot;Unable to load factories from location [&quot;</span> +<br>FACTORIES_RESOURCE_LOCATION + <span class="hljs-string">&quot;]&quot;</span>, ex);<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="createSpringFactoriesInstances"><a href="#createSpringFactoriesInstances" class="headerlink" title="createSpringFactoriesInstances"></a>createSpringFactoriesInstances</h3><blockquote><p>根据上面获取的指定类型的工厂名称列表来实例化工厂bean，我们可以简单的认为通过反射来实例化，但是具体的实现也没那么简单，感兴趣的可以自己去跟。</p></blockquote><h3 id="AnnotationAwareOrderComparator-sort-instances"><a href="#AnnotationAwareOrderComparator-sort-instances" class="headerlink" title="AnnotationAwareOrderComparator.sort(instances)"></a>AnnotationAwareOrderComparator.sort(instances)</h3><blockquote><p>排序规则：@Order从小到大排序，没有order则按没排序之前的顺序。</p></blockquote><h2 id="5-3-getSpringFactoriesInstances-ApplicationListener-class"><a href="#5-3-getSpringFactoriesInstances-ApplicationListener-class" class="headerlink" title="5.3 getSpringFactoriesInstances(ApplicationListener.class))"></a>5.3 getSpringFactoriesInstances(ApplicationListener.class))</h2><blockquote><p>类似 5.2 一样，  只是传入的类型不同 &gt; <code>ApplicationListener</code></p></blockquote><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><ol><li>构造自身实例</li><li>推测web应用类型，并赋值到属性webApplicationType</li><li> 设置属性 </li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java">List&lt;ApplicationContextInitializer&lt;?&gt;&gt; initializers<br>List&lt;ApplicationListener&lt;?&gt;&gt; listeners<br></code></pre></td></tr></table></figure><p>中途读取了类路径下所有META-INF/spring.factories的属性，并缓存到了SpringFactoriesLoader的cache缓存中</p><ol start="4"><li>推断主类，并赋值到属性mainApplicationClass</li></ol>]]></content>
    
    
    
    <tags>
      
      <tag>SpringBoot</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>springboot源码分析(02) - 项目结构详解</title>
    <link href="/2021/07/30/springboot-source-02/"/>
    <url>/2021/07/30/springboot-source-02/</url>
    
    <content type="html"><![CDATA[<h1 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h1><p>本文主要分享 <strong>Spring Boot 的项目结构</strong>。<br>希望通过本文能让胖友对 Spring Boot 的整体项目有个简单的了解。</p><p><img src="/images/springboot/springboot-root.png"></p><h1 id="spring-boot-project-项目"><a href="#spring-boot-project-项目" class="headerlink" title="spring-boot-project 项目"></a>spring-boot-project 项目</h1><p>结构如下</p><p><img src="/images/springboot/springboot-project.png"></p><h2 id="spring-boot-模块"><a href="#spring-boot-模块" class="headerlink" title="spring-boot 模块"></a>spring-boot 模块</h2><p><code>spring-boot</code> 模块，Spring Boot 的核心实现</p><ul><li><p>在 <code>org.springframework.boot.SpringApplication</code> 类，提供了大量的静态方法，可以很容易运行一个独立的 Spring 应用程序。</p><blockquote><p>经常使用。</p></blockquote></li><li><p>带有可选容器的嵌入式 Web 应用程序（Tomcat、Jetty、Undertow） 的支持。</p><blockquote><p>在 <code>org.springframework.boot.web</code> 包下实现。</p></blockquote></li><li><p>边界的外部配置支持。</p></li><li><p>… 省略其它。</p></li></ul><h2 id="spring-boot-autoconfigure-模块"><a href="#spring-boot-autoconfigure-模块" class="headerlink" title="spring-boot-autoconfigure 模块"></a>spring-boot-autoconfigure 模块</h2><p><code>spring-boot-autoconfigure</code> 可以根据类路径的内容，自动配置大部分常用应用程序。通过使用 <code>org.springframework.boot.autoconfigure.@EnableAutoConfiguration</code> 注解，会触发 Spring 上下文的自动配置。</p><blockquote><p>这里的大部分，指的是常用的框架。例如说，Spring MVC、Quartz 等等。也就是说，如果 <code>spring-boot-actuator-autoconfigure</code> 模块，暂未提供的框架，需要我们自己去实现对应框架的自动装配。</p></blockquote><p>这个模块的代码，必须要看，没得商量。</p><p>所以到此处为止，我们已经看到对我们来研究 Spring Boot 最最最重要的两个模块：<code>spring-boot</code> 和 <code>spring-boot-autoconfigure</code> 。</p><h2 id="spring-boot-actuator-模块"><a href="#spring-boot-actuator-模块" class="headerlink" title="spring-boot-actuator 模块"></a>spring-boot-actuator 模块</h2><p><code>spring-boot-actuator</code> 模块。正如其模块的英文 actuator ，它完全是一个用于暴露应用自身信息的模块：</p><ul><li>提供了一个监控和管理生产环境的模块，可以使用 http、jmx、ssh、telnet 等管理和监控应用。</li><li>审计（Auditing）、 健康（health）、数据采集（metrics gathering）会自动加入到应用里面。</li></ul><blockquote><p>一般情况下，我们可以不看这块代码的代码。</p></blockquote><h2 id="spring-boot-actuator-autoconfigure-模块"><a href="#spring-boot-actuator-autoconfigure-模块" class="headerlink" title="spring-boot-actuator-autoconfigure 模块"></a>spring-boot-actuator-autoconfigure 模块</h2><p><code>spring-boot-actuator-autoconfigure</code> 模块，大概 1W7 行代码左右。它提供了 <code>spring-boot-actuator</code> 的自动配置功能。</p><blockquote><p>一般情况下，我们可以不看这块代码的代码。</p></blockquote><h2 id="spring-boot-starters-模块"><a href="#spring-boot-starters-模块" class="headerlink" title="spring-boot-starters 模块"></a>spring-boot-starters 模块</h2><p><code>spring-boot-starters</code> 模块，它不存在任何的代码，而是提供我们常用框架的 Starter 模块。例如：</p><ul><li><code>spring-boot-starter-web</code> 模块，提供了对 Spring MVC 的 Starter 模块。</li><li><code>spring-boot-starter-data-jpa</code> 模块，提供了对 Spring Data JPA 的 Starter 模块。</li></ul><p>而每个 Starter 模块，里面只存在一个 <code>pom</code> 文件，这是为什么呢？简单来说，Spring Boot 可以根据项目中是否存在指定类，并且是否未生成对应的 Bean 对象，那么就自动创建 Bean 对象。因为有这样的机制，我们只需要使用 <code>pom</code> 文件，配置需要引入的框架，就可以实现该框架的使用所需要的类的自动装配。</p><blockquote><p>当然，如果其中没有自己想要的starter， 可以自定义实现。</p></blockquote><h2 id="spring-boot-cli-模块"><a href="#spring-boot-cli-模块" class="headerlink" title="spring-boot-cli 模块"></a>spring-boot-cli 模块</h2><p><code>spring-boot-cli</code> 模块，大概 1W 行代码左右。它提供了 Spring 项目相关的命令行功能。它是 Spring Boot 的命令行界面。</p><ul><li>它可以用来快速启动 Spring 。</li><li>它可以运行 Groovy 脚本，开发人员不需要编写很多样板代码，只需要关注业务逻辑。</li><li>Spring Boot CLI 是创建基于Spring的应用程序的最快方法。</li></ul><blockquote><p>一般情况下，我们可以不看这块代码的代码。</p></blockquote><h2 id="spring-boot-test-模块"><a href="#spring-boot-test-模块" class="headerlink" title="spring-boot-test 模块"></a>spring-boot-test 模块</h2><p><code>spring-boot-test</code> 模块，大概 1W 行代码左右。Spring Boot 提供测试方面的支持，例如说：</p><ul><li>SpringBootTestRandomPortEnvironmentPostProcessor 类，提供随机端口。</li><li><code>org.springframework.boot.test.mock.mockito</code> 包，提供 Mockito 的增强。</li></ul><blockquote><p>一般情况下，我们可以不看这块代码的代码。</p></blockquote><h2 id="spring-boot-test-autoconfigure-模块"><a href="#spring-boot-test-autoconfigure-模块" class="headerlink" title="spring-boot-test-autoconfigure 模块"></a>spring-boot-test-autoconfigure 模块</h2><p><code>spring-boot-test-autoconfigure</code> 模块，大概 1W 行代码不到。它提供了 <code>spring-boot-test</code> 的自动配置功能。</p><blockquote><p>一般情况下，我们可以不看这块代码的代码。</p></blockquote><h2 id="spring-boot-devtools-模块"><a href="#spring-boot-devtools-模块" class="headerlink" title="spring-boot-devtools 模块"></a>spring-boot-devtools 模块</h2><p><code>spring-boot-devtools</code> 模块，大概 8000 行代码左右。通过它，来使 Spring Boot 应用支持热部署，提高开发者的开发效率，无需手动重启 Spring Boot 应用。</p><blockquote><p>一般情况下，我们可以不看这块代码的代码。</p></blockquote><h2 id="spring-boot-tools-模块"><a href="#spring-boot-tools-模块" class="headerlink" title="spring-boot-tools 模块"></a>spring-boot-tools 模块</h2><p><code>spring-boot-tools</code> 模块，大概 3W 行代码左右。它是 Spring Boot 提供的工具箱，所以在其内有多个子 Maven 项目。</p><p>注意哟，我们这里说的工具箱，并不是我们在 Java 里的工具类。困惑？我们来举个例子：<code>spring-boot-maven-plugin</code> 模块：提供 Maven 打包 Spring Boot 项目的插件。</p><p>关于 <code>spring-boot-tools</code> 模块的其它子模块，我们就暂时不多做介绍落。</p><blockquote><p>一般情况下，我们可以不看这块代码的代码。</p></blockquote><h1 id="spring-boot-samples-项目"><a href="#spring-boot-samples-项目" class="headerlink" title="spring-boot-samples 项目"></a>spring-boot-samples 项目</h1><p><code>spring-boot-samples</code> 项目，2W 行代码左右。丧心病狂，提供了超级多的示例，简直良心无敌啊。</p><blockquote><p>一般情况下，我们可以不看这块代码的代码。如果真的需要某个 Spring Boot 对某个框架的示例，大多数情况下，我们还是 Google 检索文章居多。</p></blockquote><h1 id="spring-boot-samples-invoker-项目"><a href="#spring-boot-samples-invoker-项目" class="headerlink" title="spring-boot-samples-invoker 项目"></a>spring-boot-samples-invoker 项目</h1><p><code>spring-boot-samples-invoker</code> 项目，无代码，不用看。当然，也并不重要。</p><h1 id="spring-boot-tests"><a href="#spring-boot-tests" class="headerlink" title="spring-boot-tests"></a>spring-boot-tests</h1><p><code>spring-boot-tests</code> 项目，3000 行代码，主要是 Spring Boot 的集成测试、部署测试。</p><blockquote><p>一般情况下，我们可以不看这块代码的代码。</p></blockquote><h1 id="结尾"><a href="#结尾" class="headerlink" title="结尾"></a>结尾</h1><p>所以我们重点关注的应该是： spring-boot-project ： <code>spring-boot</code>  和 <code>spring-boot-autoconfigure</code> 和  <code>spring-boot-starters</code></p>]]></content>
    
    
    
    <tags>
      
      <tag>SpringBoot</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>springboot源码分析(01) - 搭建调试环境</title>
    <link href="/2021/07/29/springboot-source-01/"/>
    <url>/2021/07/29/springboot-source-01/</url>
    
    <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>为了更加深入理解<code>springboot</code>，近期开始阅读<code>springboot</code>的源码，话不多说，开干！</p><h1 id="依赖工具"><a href="#依赖工具" class="headerlink" title="依赖工具"></a>依赖工具</h1><ul><li>Maven (springboot好多版本都是使用Gradle构建，搭建的胖友们需注意)</li><li>Git</li><li>Jdk8+</li><li>IntelliJ IDEA</li></ul><h1 id="源码拉取"><a href="#源码拉取" class="headerlink" title="源码拉取"></a>源码拉取</h1><p>从官方仓库 <a href="https://github.com/spring-projects/spring-boot">https://github.com/spring-projects/spring-boot</a> <code>Fork</code> 出属于自己的仓库。</p><ul><li>为什么要 <code>Fork</code> ？既然开始阅读、调试源码，我们可能会写一些注释，有了自己的仓库，可以进行自由的提交。</li><li>本文使用的 springboot 版本为 <code>2.1.19.BUILD-SNAPSHOT</code> 。</li><li>使用 <code>IntelliJ IDEA</code> 从 <code>Fork</code> 出来的仓库拉取代码。因为 Spring 项目比较大，从仓库中拉取代码的时间会比较长。</li></ul><p>拉取完成后，Maven 会开始自动 <strong>Build</strong> 项目。因为 Build 的过程中，会下载非常多的依赖，请耐心等待。</p><h1 id="构建调试Demo"><a href="#构建调试Demo" class="headerlink" title="构建调试Demo"></a>构建调试Demo</h1><h2 id="解决-pom-的报错"><a href="#解决-pom-的报错" class="headerlink" title="解决 pom 的报错"></a>解决 pom 的报错</h2><p>在根目录的 <code>pom.xml</code> 中，会看到 <code>$&#123;disable.checks&#125;</code> 报错。它是用来配置，是否开启 Maven 代码检查的插件。因为，我们目的是为了调试代码，所以自然是去禁用它。仅仅需要在 <code>pom.xml</code> 配置如下：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">properties</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">revision</span>&gt;</span>2.1.19.BUILD-SNAPSHOT<span class="hljs-tag">&lt;/<span class="hljs-name">revision</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">main.basedir</span>&gt;</span>$&#123;basedir&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">main.basedir</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">disable.checks</span>&gt;</span>true<span class="hljs-tag">&lt;/<span class="hljs-name">disable.checks</span>&gt;</span>    <span class="hljs-comment">&lt;!-- 我是被加的 --&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">properties</span>&gt;</span><br></code></pre></td></tr></table></figure><h2 id="搭建-MVC-调试环境"><a href="#搭建-MVC-调试环境" class="headerlink" title="搭建 MVC 调试环境"></a>搭建 MVC 调试环境</h2><p>在 <code>spring-boot-tests</code>  下新模块 <code>spring-boot-xxx-tests</code>  &gt;  以后自己测试的模块都是放在里面, 在新建的模块下面再新建 <code>spring-boot-xxx-mvc-tests</code> </p><p>spring-boot-xxx-tests pom文件</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-meta">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">project</span> <span class="hljs-attr">xmlns</span>=<span class="hljs-string">&quot;http://maven.apache.org/POM/4.0.0&quot;</span></span><br><span class="hljs-tag"> <span class="hljs-attr">xmlns:xsi</span>=<span class="hljs-string">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span></span><br><span class="hljs-tag"> <span class="hljs-attr">xsi:schemaLocation</span>=<span class="hljs-string">&quot;http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd&quot;</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">parent</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-boot-tests<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework.boot<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>$&#123;revision&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">parent</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">modelVersion</span>&gt;</span>4.0.0<span class="hljs-tag">&lt;/<span class="hljs-name">modelVersion</span>&gt;</span><br><br><span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-boot-mengsu-tests<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">packaging</span>&gt;</span>pom<span class="hljs-tag">&lt;/<span class="hljs-name">packaging</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">modules</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">module</span>&gt;</span>spring-boot-xxx-mvc-tests<span class="hljs-tag">&lt;/<span class="hljs-name">module</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">modules</span>&gt;</span><br><br><span class="hljs-tag">&lt;<span class="hljs-name">description</span>&gt;</span>我的Spring Boot测试模块<span class="hljs-tag">&lt;/<span class="hljs-name">description</span>&gt;</span><br><br><span class="hljs-tag">&lt;<span class="hljs-name">properties</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">main.basedir</span>&gt;</span>$&#123;basedir&#125;/../..<span class="hljs-tag">&lt;/<span class="hljs-name">main.basedir</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">java.version</span>&gt;</span>1.8<span class="hljs-tag">&lt;/<span class="hljs-name">java.version</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">properties</span>&gt;</span><br><br><span class="hljs-tag">&lt;/<span class="hljs-name">project</span>&gt;</span><br></code></pre></td></tr></table></figure><p>spring-boot-xxx-mvc-tests pom文件</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-meta">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">project</span> <span class="hljs-attr">xmlns</span>=<span class="hljs-string">&quot;http://maven.apache.org/POM/4.0.0&quot;</span></span><br><span class="hljs-tag"> <span class="hljs-attr">xmlns:xsi</span>=<span class="hljs-string">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span></span><br><span class="hljs-tag"> <span class="hljs-attr">xsi:schemaLocation</span>=<span class="hljs-string">&quot;http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd&quot;</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">parent</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-boot-mengsu-tests<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework.boot<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>$&#123;revision&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">parent</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">modelVersion</span>&gt;</span>4.0.0<span class="hljs-tag">&lt;/<span class="hljs-name">modelVersion</span>&gt;</span><br><br><span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-boot-mengsu-mvc-tests<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">name</span>&gt;</span>我的Spring Boot测试模块 之 MVC部分<span class="hljs-tag">&lt;/<span class="hljs-name">name</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">description</span>&gt;</span>$&#123;project.name&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">description</span>&gt;</span><br><br><span class="hljs-tag">&lt;<span class="hljs-name">properties</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">main.basedir</span>&gt;</span>$&#123;basedir&#125;/../../..<span class="hljs-tag">&lt;/<span class="hljs-name">main.basedir</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">properties</span>&gt;</span><br><br><span class="hljs-tag">&lt;<span class="hljs-name">dependencies</span>&gt;</span><br><span class="hljs-comment">&lt;!-- Compile --&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework.boot<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-boot-starter-web<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">dependencies</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">build</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">plugins</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">plugin</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework.boot<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-boot-maven-plugin<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">plugin</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">plugins</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">build</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">project</span>&gt;</span><br></code></pre></td></tr></table></figure><p>新建Application 启动类</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> site.mengsu;<br><br><span class="hljs-keyword">import</span> org.springframework.boot.SpringApplication;<br><span class="hljs-keyword">import</span> org.springframework.boot.autoconfigure.SpringBootApplication;<br><span class="hljs-keyword">import</span> org.springframework.web.bind.annotation.GetMapping;<br><span class="hljs-keyword">import</span> org.springframework.web.bind.annotation.RestController;<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@Author</span>: mengsu</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@Date</span>: 2021/7/30</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@Description</span>:</span><br><span class="hljs-comment"> */</span><br><span class="hljs-meta">@RestController</span><br><span class="hljs-meta">@SpringBootApplication</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MyTestMVCApplication</span> </span>&#123;<br><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>SpringApplication.run(MyTestMVCApplication.class, args);<br>&#125;<br><br><span class="hljs-meta">@GetMapping</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">index</span> <span class="hljs-params">()</span> </span>&#123;<br><span class="hljs-keyword">return</span> <span class="hljs-string">&quot;success&quot;</span>;<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="测试运行"><a href="#测试运行" class="headerlink" title="测试运行"></a>测试运行</h2><p><code>MyTestMVCApplication</code> 启动，访问：<a href="http://localhost:8080/">http://localhost:8080/</a></p><p>返回：success，即为成功。</p>]]></content>
    
    
    
    <tags>
      
      <tag>SpringBoot</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Nacos配置中心</title>
    <link href="/2021/07/27/nacos-config/"/>
    <url>/2021/07/27/nacos-config/</url>
    
    <content type="html"><![CDATA[<h1 id="概念"><a href="#概念" class="headerlink" title="概念"></a><a href="https://github.com/alibaba/spring-cloud-alibaba/wiki/Nacos-config#spring-cloud-alibaba-nacos-config">概念</a></h1><p>Nacos 提供用于存储配置和其他元数据的 key/value 存储，为分布式系统中的外部化配置提供服务器端和客户端支持。使用 Spring Cloud Alibaba Nacos Config，您可以在 Nacos Server 集中管理你 Spring Cloud 应用的外部属性配置。</p><p>Spring Cloud Alibaba Nacos Config 是 Config Server 和 Client 的替代方案，客户端和服务器上的概念与 Spring Environment 和 PropertySource 有着一致的抽象，在特殊的 bootstrap 阶段，配置被加载到 Spring 环境中。当应用程序通过部署管道从开发到测试再到生产时，您可以管理这些环境之间的配置，并确保应用程序具有迁移时需要运行的所有内容。</p><h1 id="快速开始"><a href="#快速开始" class="headerlink" title="快速开始"></a>快速开始</h1><h2 id="引入依赖"><a href="#引入依赖" class="headerlink" title="引入依赖"></a>引入依赖</h2><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>   <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>com.alibaba.cloud<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>   <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-cloud-alibaba-dependencies<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>   <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>$&#123;spring.cloud.alibaba.version&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br>   <span class="hljs-tag">&lt;<span class="hljs-name">type</span>&gt;</span>pom<span class="hljs-tag">&lt;/<span class="hljs-name">type</span>&gt;</span><br>   <span class="hljs-tag">&lt;<span class="hljs-name">scope</span>&gt;</span>import<span class="hljs-tag">&lt;/<span class="hljs-name">scope</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>   <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>com.alibaba.cloud<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>   <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-cloud-starter-alibaba-nacos-config<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br></code></pre></td></tr></table></figure><h2 id="配置文件"><a href="#配置文件" class="headerlink" title="配置文件"></a>配置文件</h2><p>创建 <code>bootstrap.yaml</code>配置文件，添加 Nacos Config 相关配置。配置如下：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-attr">spring:</span><br>  <span class="hljs-attr">application:</span><br>    <span class="hljs-attr">name:</span> <span class="hljs-string">demo-application</span><br><br>  <span class="hljs-attr">cloud:</span><br>    <span class="hljs-attr">nacos:</span><br>      <span class="hljs-comment"># Nacos Config 配置项，对应 NacosConfigProperties 配置属性类</span><br>      <span class="hljs-attr">config:</span><br>        <span class="hljs-attr">server-addr:</span> <span class="hljs-number">127.0</span><span class="hljs-number">.0</span><span class="hljs-number">.1</span><span class="hljs-string">:8848</span> <span class="hljs-comment"># Nacos 服务器地址</span><br>        <span class="hljs-attr">namespace:</span> <span class="hljs-comment"># 使用的 Nacos 的命名空间，默认为 null</span><br>        <span class="hljs-attr">group:</span> <span class="hljs-string">DEFAULT_GROUP</span> <span class="hljs-comment"># 使用的 Nacos 配置分组，默认为 DEFAULT_GROUP</span><br>        <span class="hljs-attr">name:</span> <span class="hljs-comment"># 使用的 Nacos 配置集的 dataId，默认为 spring.application.name</span><br>        <span class="hljs-attr">file-extension:</span> <span class="hljs-string">yaml</span> <span class="hljs-comment"># 使用的 Nacos 配置集的 dataId 的文件拓展名，同时也是 Nacos 配置集的配置格式，默认为 properties</span><br><br></code></pre></td></tr></table></figure><p>Nacos Config 配置项，以 <code>spring.cloud.nacos.config</code> 开头，对应 <a href="https://github.com/alibaba/spring-cloud-alibaba/blob/master/spring-cloud-alibaba-nacos-config/src/main/java/com/alibaba/cloud/nacos/NacosConfigProperties.java">NacosConfigProperties</a> 配置属性类。</p><ol><li><p><code>server-addr</code> 配置项，设置 Nacos 服务器地址。</p></li><li><p><code>namespace</code> 配置项，使用的 Nacos 的命名空间，默认为 <code>null</code>，表示使用 <code>public</code> 这个默认命名空间。</p></li></ol><blockquote><p>FROM <a href="https://nacos.io/zh-cn/docs/concepts.html">《Nacos 文档 —— Nacos 概念》</a></p><p><strong>命名空间</strong><br>用于进行租户粒度的配置隔离。不同的命名空间下，可以存在相同的 Group 或 Data ID 的配置。Namespace 的常用场景之一是不同环境的配置的区分隔离，例如开发测试环境和生产环境的资源（如配置、服务）隔离等。</p></blockquote><ol start="3"><li><code>group</code> 配置项，使用的 Nacos 配置分组，默认为 <code>DEFAULT_GROUP</code>。</li></ol><blockquote><p>FROM <a href="https://nacos.io/zh-cn/docs/concepts.html">《Nacos 文档 —— Nacos 概念》</a></p><p><strong>配置分组</strong><br>Nacos 中的一组配置集，是组织配置的维度之一。通过一个有意义的字符串（如 Buy 或 Trade ）对配置集进行分组，从而区分 Data ID 相同的配置集。当您在 Nacos 上创建一个配置时，如果未填写配置分组的名称，则配置分组的名称默认采用 <code>DEFAULT_GROUP</code> 。配置分组的常见场景：不同的应用或组件使用了相同的配置类型，如 <code>database_url</code> 配置和 <code>MQ_topic</code> 配置。</p></blockquote><ol start="4"><li><code>name</code> 配置项，使用的 Nacos 配置集的 dataId，默认为 <code>spring.application.name</code>。</li></ol><blockquote><p>FROM <a href="https://nacos.io/zh-cn/docs/concepts.html">《Nacos 文档 —— Nacos 概念》</a></p><p><strong>配置集</strong><br>一组相关或者不相关的配置项的集合称为配置集。在系统中，一个配置文件通常就是一个配置集，包含了系统各个方面的配置。例如，一个配置集可能包含了数据源、线程池、日志级别等配置项。</p><p><strong>配置集 ID</strong><br>Nacos 中的某个配置集的 ID。配置集 ID 是组织划分配置的维度之一。Data ID 通常用于组织划分系统的配置集。一个系统或者应用可以包含多个配置集，每个配置集都可以被一个有意义的名称标识。Data ID 通常采用类 Java 包（如 <code>com.taobao.tc.refund.log.level</code>）的命名规则保证全局唯一性。此命名规则非强制。</p></blockquote><p>因为这里我们未进行配置，所以使用 Nacos 配置集的 dataId 为 <code>demo-application</code>。这也是为什么我们将 <code>spring.application.name</code> 配置项添加到 <code>bootstrap.yaml</code> 配置文件中的原因。</p><ol start="5"><li><code>file-extension</code> 配置项，使用的 Nacos 配置集的 dataId 的<strong>文件拓展名</strong>，同时也是 Nacos 配置集的<strong>配置格式</strong>，默认为 <code>properties</code>。这里我们设置为 <code>yaml</code>，因为我们稍后使用的配置集的配置格式为 <code>YAML</code>。</li></ol><h3 id="bootstrap-yaml"><a href="#bootstrap-yaml" class="headerlink" title="bootstrap.yaml"></a>bootstrap.yaml</h3><blockquote><p>为什么要将 Nacos Config 的配置项添加到 <code>bootstrap.yaml</code> 配置文件，而不像我们之前的一样，添加到 <code>application.yaml</code> 配置文件中呢？</p><p>下面，我们来讲解下原因</p></blockquote><p>在 Spring Cloud 应用中，会先创建一个 <strong>Bootstrap</strong> Context（<strong>引导</strong>上下文），比 Spring Boot 创建 <strong>Application</strong> Context（<strong>应用</strong>上下文）<strong>更早初始化</strong>。</p><p>Bootstrap Context 新增了一个 <code>bootstrap.yaml</code> <strong>配置文件</strong>，保证和 Application Context 的 <code>application.yaml</code> <strong>配置文件</strong>的<strong>隔离</strong>。</p><p>有了配置文件的隔离之后，Bootstrap Context 初始化的 <strong>Bean</strong> 从哪里来？Spring Cloud 新定义了专属于 Bootstrap Context 的自动化配置类的拓展点 <strong>BootstrapConfiguration</strong>，和 Spring Boot 为 Application Context 的自动化配置类的拓展点 <strong>EnableAutoConfiguration</strong>的<strong>隔离</strong>，保证两个 Context 创建各自的 Bean。</p><p>虽然说，Bootstrap Context 和 Application Context 做了这么多隔离，但是它们有一点是共享的，那就是 <strong>Environment</strong>。在 Spring 中，我们通过 Environment 获取属性配置，例如说 <code>spring.application.name</code> 对应的值是多少。</p><p>了解完这些之后，我们把它们串联在一起去思考一下，Bootstrap Context 的<strong>目的</strong>究竟是什么呢？通过 Bootstrap Context 的优先初始化，<strong>将配置加载到 Environment 中</strong>，提供给后面的 Application Context 使用。</p><p>举个贼重要的例子，稍后我们会在 <code>bootstrap.yaml</code> 添加 Spring Cloud Alibaba Nacos Config 相关的配置，这样 Bootstrap Context 在初始化时，通过 NacosConfigBootstrapConfiguration 创建 Nacos 相关的 Bean，然后实现从 Nacos 配置中心加载配置到 Environment 中。</p><p>如果我们把 Spring Cloud Alibaba Nacos Config 相关的配置添加在 <code>application.yaml</code> 中，那么可能无法保证 Nacos 相关的 Bean 被<strong>最先</strong>初始化，完成从 Nacos 获取配置，从而影响创建的 Bean。</p><h2 id="创建-Nacos-配置集"><a href="#创建-Nacos-配置集" class="headerlink" title="创建 Nacos 配置集"></a>创建 Nacos 配置集</h2><p>打开 Nacos UI 界面的「配置列表」菜单，进入「配置管理」功能。如下图所示：</p><p><img src="/images/nacos/nacos-config-save.png"></p><h2 id="编写代码"><a href="#编写代码" class="headerlink" title="编写代码"></a>编写代码</h2><p>创建 OrderProperties配置类，读取 <code>order</code> 配置项。代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Component</span><br><span class="hljs-meta">@ConfigurationProperties(prefix = &quot;order&quot;)</span><br><span class="hljs-comment">// @NacosConfigurationProperties(prefix = &quot;order&quot;, dataId = &quot;$&#123;nacos.config.data-id&#125;&quot;, type = ConfigType.YAML)</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">OrderProperties</span> </span>&#123;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 订单支付超时时长，单位：秒。</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-keyword">private</span> Integer payTimeoutSeconds;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 订单创建频率，单位：秒</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-keyword">private</span> Integer createFrequencySeconds;<br><br>    <span class="hljs-comment">// ... 省略 setter/getter 方法</span><br><br>&#125;<br></code></pre></td></tr></table></figure><ul><li>在类上，添加 <code>@Component</code> 注解，保证该配置类可以作为一个 Bean 被扫描到。</li><li>在类上，添加 <code>@ConfigurationProperties</code> 注解，并设置 <code>prefix = &quot;order&quot;</code> 属性，这样它就可以读取<strong>前缀</strong>为 <code>order</code> 配置项，设置到配置类对应的属性上。</li></ul><p>创建 DemoController类，提供测试 <code>@ConfigurationProperties</code> 和 <code>@Value</code> 注入配置的两个 HTTP 接口。代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@RestController</span><br><span class="hljs-meta">@RequestMapping(&quot;/demo&quot;)</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">DemoController</span> </span>&#123;<br><br>    <span class="hljs-meta">@Autowired</span><br>    <span class="hljs-keyword">private</span> OrderProperties orderProperties;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 测试 <span class="hljs-doctag">@ConfigurationProperties</span> 注解的配置属性类</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-meta">@GetMapping(&quot;/test01&quot;)</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> OrderProperties <span class="hljs-title">test01</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> orderProperties;<br>    &#125;<br><br>    <span class="hljs-meta">@Value(value = &quot;$&#123;order.pay-timeout-seconds&#125;&quot;)</span> <span class="hljs-comment">// @NacosValue(value = &quot;$&#123;order.pay-timeout-seconds&#125;&quot;)</span><br>    <span class="hljs-keyword">private</span> Integer payTimeoutSeconds;<br>    <span class="hljs-meta">@Value(value = &quot;$&#123;order.create-frequency-seconds&#125;&quot;)</span> <span class="hljs-comment">// @NacosValue(value = &quot;$&#123;order.create-frequency-seconds&#125;&quot;)</span><br>    <span class="hljs-keyword">private</span> Integer createFrequencySeconds;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 测试 <span class="hljs-doctag">@Value</span> 注解的属性</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-meta">@GetMapping(&quot;/test02&quot;)</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> Map&lt;String, Object&gt; <span class="hljs-title">test02</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> JSONObject().fluentPut(<span class="hljs-string">&quot;payTimeoutSeconds&quot;</span>, payTimeoutSeconds)<br>                .fluentPut(<span class="hljs-string">&quot;createFrequencySeconds&quot;</span>, createFrequencySeconds);<br>    &#125;<br><br>&#125;<br></code></pre></td></tr></table></figure><h2 id="简单测试"><a href="#简单测试" class="headerlink" title="简单测试"></a>简单测试</h2><p>访问 <a href="http://127.0.0.1:8080/demo/test01">http://127.0.0.1:8080/demo/test01</a> 接口</p><p>访问 <a href="http://127.0.0.1:8080/demo/test02">http://127.0.0.1:8080/demo/test02</a> 接口</p><p>结果：</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs json">&#123;<br>    <span class="hljs-attr">&quot;payTimeoutSeconds&quot;</span>: <span class="hljs-number">60</span>,<br>    <span class="hljs-attr">&quot;createFrequencySeconds&quot;</span>: <span class="hljs-number">120</span><br>&#125;<br></code></pre></td></tr></table></figure><h1 id="自动刷新配置"><a href="#自动刷新配置" class="headerlink" title="自动刷新配置"></a>自动刷新配置</h1><ul><li>使用 <code>@ConfigurationProperties</code> 注解，使用 <code>@Value</code> 注解的<strong>不会</strong></li><li>使用 <code>@RefreshScope</code> 注解，</li></ul><h2 id="EnvironmentChangeEvent"><a href="#EnvironmentChangeEvent" class="headerlink" title="EnvironmentChangeEvent"></a>EnvironmentChangeEvent</h2><p>通过 <code>@ConfigurationProperties</code> 或者 <code>@Value</code> + <code>@RefreshScope</code> 注解，已经能够满足我们绝大多数场景下的自动刷新配置的功能。但是，在一些场景下，我们仍然需要<strong>实现对配置的监听，执行自定义的逻辑</strong>。</p><p>例如说，当数据库连接的配置发生变更时，我们需要通过监听该配置的变更，重新初始化应用中的数据库连接，从而访问到新的数据库地址。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Component</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">DemoEnvironmentChangeListener</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">ApplicationListener</span>&lt;<span class="hljs-title">EnvironmentChangeEvent</span>&gt; </span>&#123;<br><br>    <span class="hljs-keyword">private</span> Logger logger = LoggerFactory.getLogger(getClass());<br><br>    <span class="hljs-meta">@Autowired</span><br>    <span class="hljs-keyword">private</span> ConfigurableEnvironment environment;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">onApplicationEvent</span><span class="hljs-params">(EnvironmentChangeEvent event)</span> </span>&#123;<br>        <span class="hljs-keyword">for</span> (String key : event.getKeys()) &#123;<br>            logger.info(<span class="hljs-string">&quot;[onApplicationEvent][key(&#123;&#125;) 最新 value 为 &#123;&#125;]&quot;</span>, key, environment.getProperty(key));<br>        &#125;<br>    &#125;<br><br>&#125;<br></code></pre></td></tr></table></figure><h1 id="官方文档"><a href="#官方文档" class="headerlink" title="官方文档"></a>官方文档</h1><ul><li><a href="https://nacos.io/zh-cn/docs/what-is-nacos.html">《Nacos 官方文档》</a></li><li><a href="https://github.com/alibaba/spring-cloud-alibaba/wiki/Nacos-config">《Spring Cloud Alibaba 官方<strong>文档</strong> —— Nacos Config》</a></li><li><a href="https://github.com/alibaba/spring-cloud-alibaba/blob/master/spring-cloud-alibaba-examples/nacos-example/nacos-config-example/readme-zh.md">《Spring Cloud Alibaba 官方<strong>示例</strong> —— Nacos Config》</a></li></ul>]]></content>
    
    
    
    <tags>
      
      <tag>Nacos</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Nacos数据模型</title>
    <link href="/2021/07/27/nacos-data-model/"/>
    <url>/2021/07/27/nacos-data-model/</url>
    
    <content type="html"><![CDATA[<h2 id="数据模型"><a href="#数据模型" class="headerlink" title="数据模型"></a>数据模型</h2><p>Nacos 数据模型 Key 由三元组唯一确认。如下图所示：</p><p><img src="/images/nacos/nacos-data-model.jpeg" alt="点击"></p><ul><li>作为注册中心时，Namespace + Group + Service</li><li>作为配置中心时，Namespace + Group + DataId</li></ul><h2 id="Namespace-命名空间"><a href="#Namespace-命名空间" class="headerlink" title="Namespace 命名空间"></a>Namespace 命名空间</h2><p>用于进行租户粒度的配置隔离。默认为 public（公共命名空间）。</p><p>不同的命名空间下，可以存在相同的 Group 或 Data ID 的配置。Namespace 的常用场景之一是不同环境的配置的区分隔离，例如开发测试环境和生产环境的资源（如配置、服务）隔离等。</p><h2 id="Group-服务分组"><a href="#Group-服务分组" class="headerlink" title="Group 服务分组"></a>Group 服务分组</h2><p>不同的服务可以归类到同一分组。默认为 DEFAULT_GROUP（默认分组）。</p><h2 id="Service-服务"><a href="#Service-服务" class="headerlink" title="Service 服务"></a>Service 服务</h2><p>例如说，用户服务、订单服务、商品服务等等。</p><h2 id="官方文档"><a href="#官方文档" class="headerlink" title="官方文档"></a>官方文档</h2><ul><li><a href="https://nacos.io/zh-cn/docs/what-is-nacos.html">《Nacos 官方文档 —— 概念》</a></li><li><a href="https://nacos.io/zh-cn/docs/architecture.html">《Nacos 官方文档 —— 架构》</a></li></ul>]]></content>
    
    
    
    <tags>
      
      <tag>Nacos</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Nacos注册中心</title>
    <link href="/2021/07/27/nacos-discovery/"/>
    <url>/2021/07/27/nacos-discovery/</url>
    
    <content type="html"><![CDATA[<h3 id="服务发现和服务健康监测"><a href="#服务发现和服务健康监测" class="headerlink" title="服务发现和服务健康监测"></a><strong>服务发现和服务健康监测</strong></h3><p>Nacos 支持基于 DNS 和基于 RPC 的服务发现。服务提供者使用 <a href="https://nacos.io/zh-cn/docs/sdk.html">原生SDK</a>、<a href="https://nacos.io/zh-cn/docs/open-api.html">OpenAPI</a>、或一个<a href="https://nacos.io/zh-cn/docs/other-language.html">独立的Agent TODO</a>注册 Service 后，服务消费者可以使用<a href="https://nacos.io/zh-cn/docs/xx">DNS TODO</a> 或<a href="https://nacos.io/zh-cn/docs/open-api.html">HTTP&amp;API</a>查找和发现服务。</p><p>Nacos 提供对服务的实时的健康检查，阻止向不健康的主机或服务实例发送请求。Nacos 支持传输层 (PING 或 TCP)和应用层 (如 HTTP、MySQL、用户自定义）的健康检查。 对于复杂的云环境和网络拓扑环境中（如 VPC、边缘网络等）服务的健康检查，Nacos 提供了 agent 上报模式和服务端主动检测2种健康检查模式。Nacos 还提供了统一的健康检查仪表盘，帮助您根据健康状态管理服务的可用性及流量。</p><h3 id="注册中心原理"><a href="#注册中心原理" class="headerlink" title="注册中心原理"></a>注册中心原理</h3><p>在使用注册中心时，一共有三种角色：服务提供者（Service Provider）、服务消费者（Service Consumer）、注册中心（Registry）。</p><p><img src="/images/nacos/nacos-dis.png" alt="点击"></p><ol><li>Provider：</li></ol><ul><li>启动时，向 Registry <strong>注册</strong>自己为一个服务（Service）的实例（Instance）。</li><li>同时，定期向 Registry 发送<strong>心跳</strong>，告诉自己还存活。</li><li>关闭时，向 Registry <strong>取消注册</strong>。</li></ul><ol start="2"><li>Consumer：</li></ol><ul><li>启动时，向 Registry <strong>订阅</strong>使用到的服务，并缓存服务的实例列表在内存中。</li><li>后续，Consumer 向对应服务的 Provider 发起<strong>调用</strong>时，从内存中的该服务的实例列表选择一个，进行远程调用。</li><li>关闭时，向 Registry <strong>取消订阅</strong>。</li></ul><ol start="3"><li>Registry：</li></ol><ul><li>Provider 超过一定时间未<strong>心跳</strong>时，从服务的实例列表移除。</li><li>服务的实例列表发生变化（新增或者移除）时，通知订阅该服务的 Consumer，从而让 Consumer 能够刷新本地缓存。</li></ul><p>当然，不同的注册中心可能在实现原理上会略有差异。例如说，<a href="https://github.com/Netflix/eureka/">Eureka</a> 注册中心，并不提供通知功能，而是 Eureka Client 自己定期轮询，实现本地缓存的更新。</p><p>另外，Provider 和 Consumer 是角色上的定义，一个服务<strong>同时</strong>即可以是 Provider 也可以作为 Consumer。例如说，优惠劵服务可以给订单服务提供接口，同时又调用用户服务提供的接口。</p><h3 id="快速开始"><a href="#快速开始" class="headerlink" title="快速开始"></a>快速开始</h3><h4 id="引入依赖"><a href="#引入依赖" class="headerlink" title="引入依赖"></a>引入依赖</h4><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>com.alibaba.cloud<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-cloud-alibaba-dependencies<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>$&#123;spring.cloud.alibaba.version&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">type</span>&gt;</span>pom<span class="hljs-tag">&lt;/<span class="hljs-name">type</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">scope</span>&gt;</span>import<span class="hljs-tag">&lt;/<span class="hljs-name">scope</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>com.alibaba.cloud<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-cloud-starter-alibaba-nacos-discovery<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br></code></pre></td></tr></table></figure><h4 id="生产者"><a href="#生产者" class="headerlink" title="生产者"></a>生产者</h4><p>配置文件</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-attr">spring:</span><br>  <span class="hljs-attr">application:</span><br>    <span class="hljs-attr">name:</span> <span class="hljs-string">demo-provider</span> <span class="hljs-comment"># Spring 应用名</span><br>  <span class="hljs-attr">cloud:</span><br>    <span class="hljs-attr">nacos:</span><br>      <span class="hljs-comment"># Nacos 作为注册中心的配置项，对应 NacosDiscoveryProperties 配置类</span><br>      <span class="hljs-attr">discovery:</span><br>        <span class="hljs-attr">server-addr:</span> <span class="hljs-number">127.0</span><span class="hljs-number">.0</span><span class="hljs-number">.1</span><span class="hljs-string">:8848</span> <span class="hljs-comment"># Nacos 服务器地址</span><br>        <span class="hljs-attr">service:</span> <span class="hljs-string">$&#123;spring.application.name&#125;</span> <span class="hljs-comment"># 注册到 Nacos 的服务名。默认值为 $&#123;spring.application.name&#125;。</span><br><br><span class="hljs-attr">server:</span><br>  <span class="hljs-attr">port:</span> <span class="hljs-number">18080</span> <span class="hljs-comment"># 服务器端口。默认为 8080</span><br></code></pre></td></tr></table></figure><p>重点看 <code>spring.cloud.nacos.discovery</code> 配置项，它是 Nacos Discovery 配置项的前缀，对应 <a href="https://github.com/alibaba/spring-cloud-alibaba/blob/master/spring-cloud-alibaba-nacos-discovery/src/main/java/com/alibaba/cloud/nacos/NacosDiscoveryProperties.java">NacosDiscoveryProperties</a> 配置项。</p><p>创建 DemoProviderApplication 类，创建应用启动类，并提供 HTTP 接口。代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@SpringBootApplication</span><br><span class="hljs-meta">@EnableDiscoveryClient</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">DemoProviderApplication</span> </span>&#123;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>        SpringApplication.run(DemoProviderApplication.class, args);<br>    &#125;<br><br>    <span class="hljs-meta">@RestController</span><br>    <span class="hljs-keyword">static</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">TestController</span> </span>&#123;<br><br>        <span class="hljs-meta">@GetMapping(&quot;/echo&quot;)</span><br>        <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">echo</span><span class="hljs-params">(String name)</span> </span>&#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;provider:&quot;</span> + name;<br>        &#125;<br><br>    &#125;<br><br>&#125;<br></code></pre></td></tr></table></figure><ol><li><p><code>@SpringBootApplication</code> 注解，被添加在类上，声明这是一个 Spring Boot 应用。Spring Cloud 是构建在 Spring Boot 之上的，所以需要添加。</p></li><li><p><a href="https://github.com/spring-cloud/spring-cloud-commons/blob/master/spring-cloud-commons/src/main/java/org/springframework/cloud/client/discovery/EnableDiscoveryClient.java"><code>@EnableDiscoveryClient</code></a> 注解，开启 Spring Cloud 的注册发现功能。不过从 Spring Cloud Edgware 版本开始，实际上已经不需要添加 <code>@EnableDiscoveryClient</code> 注解，只需要引入 Spring Cloud 注册发现组件，就会自动开启注册发现的功能。例如说，我们这里已经引入了 <code>spring-cloud-starter-alibaba-nacos-discovery</code> 依赖，就不用再添加 <code>@EnableDiscoveryClient</code> 注解了。</p></li></ol><h4 id="消费者"><a href="#消费者" class="headerlink" title="消费者"></a>消费者</h4><p>配置文件</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-attr">spring:</span><br>  <span class="hljs-attr">application:</span><br>    <span class="hljs-attr">name:</span> <span class="hljs-string">demo-provider</span> <span class="hljs-comment"># Spring 应用名</span><br>  <span class="hljs-attr">cloud:</span><br>    <span class="hljs-attr">nacos:</span><br>      <span class="hljs-comment"># Nacos 作为注册中心的配置项，对应 NacosDiscoveryProperties 配置类</span><br>      <span class="hljs-attr">discovery:</span><br>        <span class="hljs-attr">server-addr:</span> <span class="hljs-number">127.0</span><span class="hljs-number">.0</span><span class="hljs-number">.1</span><span class="hljs-string">:8848</span> <span class="hljs-comment"># Nacos 服务器地址</span><br>        <span class="hljs-attr">service:</span> <span class="hljs-string">$&#123;spring.application.name&#125;</span> <span class="hljs-comment"># 注册到 Nacos 的服务名。默认值为 $&#123;spring.application.name&#125;。</span><br><br><span class="hljs-attr">server:</span><br>  <span class="hljs-attr">port:</span> <span class="hljs-number">28080</span> <span class="hljs-comment"># 服务器端口。默认为 8080</span><br></code></pre></td></tr></table></figure><p>创建 DemoConsumerApplication类，创建应用启动类，并提供一个调用服务提供者的 HTTP 接口。代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@SpringBootApplication</span><br><span class="hljs-comment">// @EnableDiscoveryClient</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">DemoConsumerApplication</span> </span>&#123;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>        SpringApplication.run(DemoConsumerApplication.class, args);<br>    &#125;<br><br>    <span class="hljs-meta">@Configuration</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">RestTemplateConfiguration</span> </span>&#123;<br><br>        <span class="hljs-meta">@Bean</span><br>        <span class="hljs-function"><span class="hljs-keyword">public</span> RestTemplate <span class="hljs-title">restTemplate</span><span class="hljs-params">()</span> </span>&#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> RestTemplate();<br>        &#125;<br><br>    &#125;<br><br>    <span class="hljs-meta">@RestController</span><br>    <span class="hljs-keyword">static</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">TestController</span> </span>&#123;<br><br>        <span class="hljs-meta">@Autowired</span><br>        <span class="hljs-keyword">private</span> DiscoveryClient discoveryClient;<br>        <span class="hljs-meta">@Autowired</span><br>        <span class="hljs-keyword">private</span> RestTemplate restTemplate;<br>        <span class="hljs-meta">@Autowired</span><br>        <span class="hljs-keyword">private</span> LoadBalancerClient loadBalancerClient;<br><br>        <span class="hljs-meta">@GetMapping(&quot;/hello&quot;)</span><br>        <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">hello</span><span class="hljs-params">(String name)</span> </span>&#123;<br>            <span class="hljs-comment">// &lt;1&gt; 获得服务 `demo-provider` 的一个实例</span><br>            ServiceInstance instance;<br>            <span class="hljs-keyword">if</span> (<span class="hljs-keyword">true</span>) &#123;<br>                <span class="hljs-comment">// 获取服务 `demo-provider` 对应的实例列表</span><br>                List&lt;ServiceInstance&gt; instances = discoveryClient.getInstances(<span class="hljs-string">&quot;demo-provider&quot;</span>);<br>                <span class="hljs-comment">// 选择第一个</span><br>                instance = instances.size() &gt; <span class="hljs-number">0</span> ? instances.get(<span class="hljs-number">0</span>) : <span class="hljs-keyword">null</span>;<br>            &#125; <span class="hljs-keyword">else</span> &#123;<br>                instance = loadBalancerClient.choose(<span class="hljs-string">&quot;demo-provider&quot;</span>);<br>            &#125;<br>            <span class="hljs-comment">// &lt;2&gt; 发起调用</span><br>            <span class="hljs-keyword">if</span> (instance == <span class="hljs-keyword">null</span>) &#123;<br>                <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> IllegalStateException(<span class="hljs-string">&quot;获取不到实例&quot;</span>);<br>            &#125;<br>            String targetUrl = instance.getUri() + <span class="hljs-string">&quot;/echo?name=&quot;</span> + name;<br>            String response = restTemplate.getForObject(targetUrl, String.class);<br>            <span class="hljs-comment">// 返回结果</span><br>            <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;consumer:&quot;</span> + response;<br>        &#125;<br><br>    &#125;<br><br>&#125;<br></code></pre></td></tr></table></figure><ol><li><p><code>@EnableDiscoveryClient</code> 注解，因为已经无需添加，所以我们进行了注释，原因在上面已经解释过。</p></li><li><p>RestTemplateConfiguration 配置类，创建 <a href="https://github.com/spring-projects/spring-framework/blob/master/spring-web/src/main/java/org/springframework/web/client/RestTemplate.java">RestTemplate</a> Bean。RestTemplate 是 Spring 提供的 HTTP 调用模板工具类，可以方便我们稍后调用服务提供者的 HTTP API。</p></li><li><p>TestController 提供了 <code>/hello</code> 接口，用于调用服务提供者的 <code>/demo</code> 接口。代码略微有几行，我们来稍微解释下哈。</p></li></ol><p><code>discoveryClient</code> 属性，DiscoveryClient 对象，服务发现客户端，上文我们已经介绍过。这里我们注入的不是 Nacos Discovery 提供的 NacosDiscoveryClient，保证通用性。未来如果我们不使用 Nacos 作为注册中心，而是使用 Eureka 或则 Zookeeper 时，则无需改动这里的代码。</p><p><code>loadBalancerClient</code> 属性，<a href="https://github.com/spring-cloud/spring-cloud-commons/blob/master/spring-cloud-commons/src/main/java/org/springframework/cloud/client/loadbalancer/LoadBalancerClient.java">LoadBalancerClient</a> 对象，负载均衡客户端。稍后我们会使用它，从 Nacos 获取的服务 <code>demo-provider</code> 的实例列表中，选择一个进行 HTTP 调用。</p><blockquote><p>拓展小知识：在 Spring Cloud Common 项目中，定义了<a href="https://github.com/spring-cloud/spring-cloud-commons/blob/master/spring-cloud-commons/src/main/java/org/springframework/cloud/client/loadbalancer/LoadBalancerClient.java">LoadBalancerClient</a> 接口，作为通用的负载均衡客户端，提供从指定服务中选择一个实例、对指定服务发起请求等 API 方法。而想要集成到 Spring Cloud 体系的负载均衡的组件，需要提供对应的 LoadBalancerClient 实现类。</p><p>例如说，Spring Cloud Netflix Ribbon 提供了 <a href="https://github.com/spring-cloud/spring-cloud-netflix/blob/2.2.x/spring-cloud-netflix-ribbon/src/main/java/org/springframework/cloud/netflix/ribbon/RibbonLoadBalancerClient.java">RibbonLoadBalancerClient</a> 实现。</p><p>如此，所有需要使用到的地方，只需要获取到 DiscoveryClient 客户端，而无需关注具体实现，保证其通用性。😈 不过貌似 Spring Cloud 体系中，暂时只有 Ribbon 一个负载均衡组件。</p><p>当然，LoadBalancerClient 的服务的实例列表，是来自 DiscoveryClient 提供的。</p></blockquote><p><code>/hello</code> 接口，示例接口，对服务提供者发起一次 HTTP 调用。</p><ul><li><code>&lt;1&gt;</code> 处，获得服务 <code>demo-provider</code> 的一个实例。这里我们提供了两种方式的代码，分别基于 DiscoveryClient 和 LoadBalancerClient。</li><li><code>&lt;2&gt;</code> 处，通过获取到的服务实例 ServiceInstance 对象，拼接请求的目标 URL，之后使用 RestTemplate 发起 HTTP 调用。</li></ul><h4 id="测试"><a href="#测试" class="headerlink" title="测试"></a>测试</h4><p>访问：<a href="http://127.0.0.1:28080/hello?name=mengsu">http://127.0.0.1:28080/hello?name=mengsu</a> ，返回结果为 <code>&quot;consumer:provider:mengsu&quot;</code>。说明，调用远程的<strong>服务提供者</strong>成功。</p>]]></content>
    
    
    
    <tags>
      
      <tag>Nacos</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Typora快捷键</title>
    <link href="/2021/07/26/Typora%E5%BF%AB%E6%8D%B7%E9%94%AE/"/>
    <url>/2021/07/26/Typora%E5%BF%AB%E6%8D%B7%E9%94%AE/</url>
    
    <content type="html"><![CDATA[<h1 id="Typora快捷键"><a href="#Typora快捷键" class="headerlink" title="Typora快捷键"></a>Typora快捷键</h1><p>最大标题：command + 1 或者：#<br> 大标题：command + 2 或者：##<br> 标准标题：command + 3 或者：###<br> 中标题：command + 4 或者：####<br> 小标题：command + 5 或者：#####<br> 插入表格：command + T<br> 插入代码：command + alt +c<br> 插入图片：cmd + ctrl + i<br> 行间公式 command + Alt + b<br> 段落：command + 0<br> 竖线 ： command + Alt +q<br> 无需列表：command+option+U<br> 有序列表（1. 2.） ：输入数字+“.”之后输 入空格 或者：command + Alt + o<br> 黑点标记：command + Alt + u<br> 隔离线shift + command + -<br> 超链接：command + Alt + l<br> 插入链接：command +k<br> 下划线：command +u<br> 加粗：command +b<br> 搜索：command +f<br> 引用：command+option+Q</p>]]></content>
    
    
    
    <tags>
      
      <tag>Typora</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Nacos安装运行</title>
    <link href="/2021/07/26/nacos-install/"/>
    <url>/2021/07/26/nacos-install/</url>
    
    <content type="html"><![CDATA[<h2 id="快速开始"><a href="#快速开始" class="headerlink" title="快速开始"></a><a href="https://nacos.io/zh-cn/">快速开始</a></h2><h3 id="Docker下载安装"><a href="#Docker下载安装" class="headerlink" title="Docker下载安装"></a>Docker下载安装</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">docker pull nacos/nacos-server<br></code></pre></td></tr></table></figure><h3 id="Docker查看镜像"><a href="#Docker查看镜像" class="headerlink" title="Docker查看镜像"></a>Docker查看镜像</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">docker images<br></code></pre></td></tr></table></figure><h3 id="Docker运行"><a href="#Docker运行" class="headerlink" title="Docker运行"></a>Docker运行</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs bash">docker run -d \<br>-e MODE=standalone \<br>-e SPRING_DATASOURCE_PLATFORM=mysql \<br>-e MYSQL_SERVICE_HOST=docker.for.mac.host.internal \<br>-e MYSQL_SERVICE_PORT=3306 \<br>-e MYSQL_SERVICE_USER=root \<br>-e MYSQL_SERVICE_PASSWORD=123456 \<br>-e MYSQL_SERVICE_DB_NAME=nacos_config \<br>-p 8848:8848 \<br>--restart=always \<br>nacos/nacos-server<br></code></pre></td></tr></table></figure><p>备注：连接数据库需要导入nacos自己的<a href="https://github.com/alibaba/nacos/edit/master/distribution/conf/nacos-mysql.sql">数据库脚本</a>，该模式为单机启动</p><h3 id="Docker查看运行状态"><a href="#Docker查看运行状态" class="headerlink" title="Docker查看运行状态"></a>Docker查看运行状态</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">docker ps<br></code></pre></td></tr></table></figure><h3 id="访问地址"><a href="#访问地址" class="headerlink" title="访问地址"></a>访问地址</h3><p><a href="http://127.0.0.1:8848/">http://127.0.0.1:8848/</a>  ，默认账密都是：nacos</p><h3 id="系统截图"><a href="#系统截图" class="headerlink" title="系统截图"></a>系统截图</h3><p><img src="/images/nacos/nacos-show.png" alt="点击"></p>]]></content>
    
    
    
    <tags>
      
      <tag>Nacos</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Hexo</title>
    <link href="/2021/07/23/hello-world/"/>
    <url>/2021/07/23/hello-world/</url>
    
    <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ hexo new <span class="hljs-string">&quot;My New Post&quot;</span><br></code></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ hexo server<br></code></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ hexo generate<br></code></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ hexo deploy<br></code></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>]]></content>
    
    
    
  </entry>
  
  
  
  
</search>
