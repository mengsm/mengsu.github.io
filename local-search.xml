<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>java基础(04) - 类</title>
    <link href="/2021/12/20/java/java-base-4/"/>
    <url>/2021/12/20/java/java-base-4/</url>
    
    <content type="html"><![CDATA[<h1 id="类"><a href="#类" class="headerlink" title="类"></a>类</h1><p>java中除了八大基本数据类型（其中，四种整形byte/short/int/long，两种浮点类型float/double，一种真假类型boolean，一种字符类型char），还可以自定义类，类可以理解为是<strong>函数的容器</strong>，但是类更多表示的是自定义数据类型。</p><h2 id="类的组成部分"><a href="#类的组成部分" class="headerlink" title="类的组成部分"></a>类的组成部分</h2><ul><li>类型本身具有的属性，通过<strong>类变量</strong>体现  </li><li>类型本身可以进行的操作，通过<strong>类方法</strong>体现</li><li>类型实例具有的属性，通过<strong>实例变量</strong>体现</li><li>类型实例可以进行的操作，通过<strong>实例方法</strong>体现</li></ul><blockquote><p>类变量 or 类方法， 可以理解为 静态 <strong>static</strong> 修饰，可以直接用 <strong>类型.变量(方法)</strong> 进行访问</p><p>实例变量 or 方法，可以理解为 通过 new Class()，然后进行访问</p><p>类变量和实例变量都叫成员变量，也就是类的成员，类变量也叫静态变量或静态成员变量。类方法和实例方法都叫成员方法，也都是类的成员，类方法也叫静态方法。</p></blockquote><h3 id="类成员-static-和-实例成员-new-的访问关系"><a href="#类成员-static-和-实例成员-new-的访问关系" class="headerlink" title="类成员(static) 和 实例成员(new) 的访问关系"></a>类成员(<strong>static</strong>) 和 实例成员(<strong>new</strong>) 的访问关系</h3><blockquote><p>类方法只能访问类变量，但不能访问实例变量，可以调用其他的类方法，但不能调用实例方法。</p><p>实例方法既能访问实例变量，也可以访问类变量，既可以调用实例方法，也可以调用类方法。</p></blockquote><p><strong>声明变量本身只会分配存放位置的内存空间，这块空间还没有指向任何实际内容</strong>。因为这种变量和数组变量本身不存储数据，而只是存储实际内容的位置，它们也都称为<strong>引用类型</strong>的变量。</p><h2 id="关键字"><a href="#关键字" class="headerlink" title="关键字"></a>关键字</h2><ul><li>public:可以修饰类、类方法、类变量、实例变量、实例方法、构造方法，表示可被外部访问。    </li><li>private:可以修饰类、类方法、类变量、实例变量、实例方法、构造方法，表示不可以被外部访问，只能在类内被使用。</li><li>static: 修饰类变量和类方法，它也可以修饰内部类（后续章节介绍）。        </li><li>this：表示当前实例，可以用于调用其他构造方法，访问实例变量，访问实例方法。       </li><li>final: 修饰类变量、实例变量，表示只能被赋值一次，final也可以修饰实例方法和局部变量（后续章节介绍）。</li></ul><h1 id="类和对象的生命周期"><a href="#类和对象的生命周期" class="headerlink" title="类和对象的生命周期"></a><strong>类和对象的生命周期</strong></h1><h2 id="类-1"><a href="#类-1" class="headerlink" title="类"></a>类</h2><p>在程序运行的时候，当第一次通过new创建一个类的对象的时候，或者直接通过类名访问类变量和类方法的时候，<strong>Java会将类加载进内存，为这个类型分配一块空间，这个空间会包括类的定义，它有哪些变量，哪些方法等，同时还有类的静态变量，并对静态变量赋初始值</strong>。</p><p>类加载进内存后，一般不会释放，直到程序结束。一般情况下，类只会加载一次，所以静态变量在内存中只有一份。</p><h2 id="对象"><a href="#对象" class="headerlink" title="对象"></a>对象</h2><p>当通过new创建一个对象的时候，对象产生，在内存中，会存储这个对象的实例变量值，每new一次，对象就会产生一个，就会有一份独立的实例变量。</p><p>每个对象除了保存实例变量的值外，可以理解还保存着对应类型即类的地址，这样，通过对象能知道它的类，访问到类的变量和方法代码。</p><p>实例方法可以理解为一个静态方法，只是多了一个参数this，通过对象调用方法，可以理解为就是调用这个静态方法，并将对象作为参数传给this。</p><h1 id="继承"><a href="#继承" class="headerlink" title="继承"></a><strong>继承</strong></h1><p>计算机程序经常使用类之间的<strong>继承</strong>关系来表示对象之间的分类关系。在继承关系中，有<strong>父类</strong>和<strong>子类</strong>，比如动物类Animal和狗类Dog，Animal是父类，Dog是子类。父类也叫<strong>基类</strong>，子类也叫<strong>派生类</strong>，父类子类是相对的，一个类B可能是类A的子类，是类C的父类。</p><p>使用继承一方面可以复用代码，公共的属性和行为可以放到父类中，而子类只需要关注子类特有的就可以了，另一方面，不同子类的对象可以更为方便的被统一处理。</p><p>继承和多态的基本概念：</p><ul><li>每个类有且只有一个父类，没有声明父类的其父类为Object，子类继承了父类非private的属性和方法，可以增加自己的属性和方法，可以重写父类的方法实现。</li><li>new过程中，父类先进行初始化，可通过super调用父类相应的构造方法，没有使用super的话，调用父类的默认构造方法。</li><li>子类变量和方法与父类重名的情况下，可通过super强制访问父类的变量和方法。</li><li>子类对象可以赋值给父类引用变量，这叫多态，实际执行调用的是子类实现，这叫<strong>动态绑定</strong>。</li></ul><h2 id="构造方法"><a href="#构造方法" class="headerlink" title="构造方法"></a><strong>构造方法</strong></h2><h3 id="super"><a href="#super" class="headerlink" title="super"></a><strong>super</strong></h3><p>如果类只有一个<strong>带参数的构造方法</strong>，没有默认构造方法。这个时候，它的任何子类都必须在构造方法中通过super(…)调用Base的带参数构造方法，否则，Java会提示编译错误。</p><h3 id="构造方法调用重写方法"><a href="#构造方法调用重写方法" class="headerlink" title="构造方法调用重写方法"></a><strong>构造方法调用重写方法</strong></h3><p>如果在父类构造方法中调用了可被重写的方法，则可能会出现意想不到的结果，<strong>在父类构造方法中调用可被子类重写的方法，是一种不好的实践，容易引起混淆，应该只调用private的方法。</strong></p><h2 id="重名与静态绑定"><a href="#重名与静态绑定" class="headerlink" title="重名与静态绑定"></a><strong>重名与静态绑定</strong></h2><p>重名是可以的，重名后实际上有两个变量或方法。对于private变量和方法，它们只能在类内被访问，访问的也永远是当前类的，即在子类中，访问的是子类的，在父类中，访问的父类的，它们只是碰巧名字一样而已，没有任何关系。</p><p>但对于public变量和方法，则要看如何访问它，在类内访问的是当前类的，但子类可以通过super.明确指定访问父类的。在类外，则要看访问变量的静态类型，静态类型是父类，则访问父类的变量和方法，静态类型是子类，则访问的是子类的变量和方法。</p><p>当通过<strong>父类</strong>访问时，访问的是<strong>Base</strong>的变量和方法，当通过<strong>子类</strong>访问时，访问的是Child的变量和方法，这称之为静态绑定，即访问绑定到变量的静态类型，静态绑定在程序编译阶段即可决定，而动态绑定则要等到程序运行时。<strong>实例变量、静态变量、静态方法、private方法，都是静态绑定的</strong>。</p>]]></content>
    
    
    
    <tags>
      
      <tag>Java</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>java基础(03) - 函数</title>
    <link href="/2021/12/20/java/java-base-3/"/>
    <url>/2021/12/20/java/java-base-3/</url>
    
    <content type="html"><![CDATA[<h1 id="函数概念"><a href="#函数概念" class="headerlink" title="函数概念"></a>函数概念</h1><p>计算机程序使用<strong>函数这个概念来解决这个问题，即使用函数来减少重复代码和分解复杂操作，本节我们就来谈谈Java中的函数，包括函数的基础和一些细节</strong>。</p><h1 id="定义函数"><a href="#定义函数" class="headerlink" title="定义函数"></a><strong>定义函数</strong></h1><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java">修饰符 返回值类型  函数名字(参数类型 参数名字, ...) &#123;<br>    操作 ...<br>    <span class="hljs-keyword">return</span> 返回值;<br>&#125;<br></code></pre></td></tr></table></figure><ul><li>函数名字：名字是不可或缺的，表示函数的功能。</li><li>参数：参数有0个到多个，每个参数有参数的数据类型和参数名字组成。</li><li>操作：函数的具体操作代码。</li><li>返回值：函数可以没有返回值，没有的话返回值类型写成void，有的话在函数代码中必须要使用return语句返回一个值，这个值的类型需要和声明的返回值类型一致。</li><li>修饰符：Java中函数有很多修饰符，分别表示不同的目的，在本节我们假定修饰符为public static，且暂不讨论这些修饰符的目的。</li></ul><p>以上就是定义函数的语法，<strong>定义函数就是定义了一段有着明确功能的子程序，但定义函数本身不会执行任何代码，函数要被执行，需要被调用</strong>。</p><h1 id="函数调用"><a href="#函数调用" class="headerlink" title="函数调用"></a><strong>函数调用</strong></h1><p>Java中，任何函数都需要放在一个类中，类我们还没有介绍，我们暂时可以把类看做函数的一个容器，即函数放在类中，类中包括多个函数，Java中函数一般叫做方法，我们不特别区分函数和方法，可能会交替使用。一个类里面可以定义多个函数，类里面可以定义一个叫做main的函数，形式如：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>      ...<br>      <span class="hljs-comment">// 函数a   a();</span><br>      <span class="hljs-comment">// 函数b   b();</span><br>&#125;<br></code></pre></td></tr></table></figure><h1 id="函数传参"><a href="#函数传参" class="headerlink" title="函数传参"></a>函数传参</h1><p>关于参数传递，简单总结一下，定义函数时声明参数，实际上就是定义变量，只是这些变量的值是未知的，调用函数时传递参数，实际上就是给函数中的变量赋值。</p><p>值传递和引用传递</p><blockquote><ul><li>基本数据类型传值，对形参的修改不会影响实参</li><li>引用类型传引用，形参和实参指向同一个内存地址（同一个对象），所以对参数的修改会影响到实际的对象</li><li>String, Integer, Double等immutable的类型特殊处理，可以理解为传值，最后的操作不会修改实参对象。</li></ul></blockquote><h1 id="函数命名以及重载"><a href="#函数命名以及重载" class="headerlink" title="函数命名以及重载"></a>函数命名以及重载</h1><p>每个函数都有一个名字，这个名字表示这个函数的意义，名字可以重复吗？在不同的类里，答案是肯定的，在同一个类里，要看情况。</p><p>同一个类里，<strong>函数可以重名，但是参数不能一样，一样是指参数个数相同，每个位置的参数类型也一样，但参数的名字不算，返回值类型也不算。换句话说，函数的唯一性标示是：类名_函数名_参数1类型_参数2类型_…参数n类型。</strong></p><p>同一个类中<strong>函数名字相同但参数不同的现象，一般称为函数重载。为什么需要函数重载呢？一般是因为函数想表达的意义是一样的，但参数个数或类型不一样。比如说，求两个数的最大值，在Java的Math库中就定义了四个函数，如下所示：</strong></p><p><img src="http://oss.mengsu.site/image-20211220154756946.png" alt="image-20211220154756946"></p><p>函数是计算机程序的一种重要结构，<strong>通过函数来减少重复代码，分解复杂操作是计算机程序的一种重要思维方式</strong>。本节我们介绍了函数的基础概念，还有关于参数传递、返回值、重载、递归方面的一些细节。</p><h1 id="函数调用的基本原理"><a href="#函数调用的基本原理" class="headerlink" title="函数调用的基本原理"></a>函数调用的基本原理</h1><p>我们之前谈过程序执行的基本原理：<strong>CPU有一个指令指示器，指向下一条要执行的指令，要么顺序执行，要么进行跳转（条件跳转或无条件跳转）。</strong></p><p>基本上，这依然是成立的，程序从<strong>main函数开始顺序执行，函数调用可以看做是一个无条件跳转，跳转到对应函数的指令处开始执行，碰到return语句或者函数结尾的时候，再执行一次无条件跳转，跳转回调用方，执行调用函数后的下一条指令。</strong></p><p>但这里面有几个问题：</p><ul><li>参数如何传递？</li><li>函数如何知道返回到什么地方？在if/else, for中，跳转的地址都是确定的，但函数自己并不知道会被谁调用，而且可能会被很多地方调用，它并不能提前知道执行结束后返回哪里。</li><li>函数结果如何传给调用方？</li></ul><p>解决思路是使用内存来存放这些数据，函数调用方和函数自己就如何存放和使用这些数据达成一个一致的协议或约定。这个约定在各种计算机系统中都是类似的，存放这些数据的内存有一个相同的名字，叫<strong>栈</strong>。</p><h2 id="栈"><a href="#栈" class="headerlink" title="栈"></a><strong>栈</strong></h2><p>栈是一块内存，但它的使用有特别的约定，一般是先进后出，类似于一个桶，往栈里放数据，我们称为入栈，最下面的我们称为栈底，最上面的我们称为栈顶，从栈顶拿出数据，通常称为出栈。栈一般是从高位地址向低位地址扩展，换句话说，栈底的内存地址是最高的，栈顶的是最小的。</p><p>计算机系统<strong>主要使用栈来存放函数调用过程中需要的数据，包括参数、返回地址，函数内定义的局部变量也放在栈中</strong>。计算机系统就如何在栈中存放这些数据，调用者和函数如何协作做了约定。返回值不太一样，它可能放在栈中，但它使用的栈和局部变量不完全一样，有的系统使用CPU内的一个存储器存储返回值，我们可以<strong>简单认为存在一个专门的返回值存储器</strong>。 main函数的相关数据放在栈的最下面，每调用一次函数，都会将相关函数的数据入栈，调用结束会出栈。</p><h2 id="例子"><a href="#例子" class="headerlink" title="例子"></a><strong>例子</strong></h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Sum</span> </span>&#123;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">int</span> <span class="hljs-title">sum</span><span class="hljs-params">(<span class="hljs-keyword">int</span> a, <span class="hljs-keyword">int</span> b)</span> </span>&#123;<br>        <span class="hljs-keyword">int</span> c = a + b;<br>        <span class="hljs-keyword">return</span> c;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>        <span class="hljs-keyword">int</span> d = Sum.sum(<span class="hljs-number">1</span>, <span class="hljs-number">2</span>);<br>        System.out.println(d);<br>    &#125;<br><br>&#125;<br></code></pre></td></tr></table></figure><p>存储逻辑</p><p><img src="http://oss.mengsu.site/image-20211220165332885.png" alt="image-20211220165332885"></p><p><strong>start</strong><br>main方法开始执行 <strong>&gt;</strong><br>main参数：arg 和 局部变量：d 入栈  <strong>&gt;</strong><br>调用进入sum方法，方法参数 a 和 b 入栈 <strong>&gt;</strong><br>记录main方法当前执行代码行数指令 入栈 <strong>&gt;</strong><br>sum方法返回结果值3存储寄存器，并记录结果值 入栈 <strong>&gt;</strong><br>sum方法执行完毕，方法内部局部变量 a b 销毁，返回结果销毁 <strong>&gt;</strong><br><strong>end</strong></p><h2 id="变量的生命周期"><a href="#变量的生命周期" class="headerlink" title="变量的生命周期"></a><strong>变量的生命周期</strong></h2><p>定义一个变量就会分配一块内存，但我们并没有具体谈什么时候分配内存，具体分配在哪里，什么时候释放内存。</p><p>从以上关于栈的描述我们可以看出，<strong>函数中的参数和函数内定义的变量，都分配在栈中，这些变量只有在函数被调用的时候才分配，而且在调用结束后就被释放了</strong>。但这个说法主要针对<strong>基本数据类型</strong>，<strong>除了局部变量存放在栈中，其它变量都在堆中</strong>， 接下来我们谈数组和对象。</p><h2 id="数组和对象"><a href="#数组和对象" class="headerlink" title="数组和对象"></a><strong>数组和对象</strong></h2><p>对于数组和对象类型，我们介绍过，它们都有两块内存，一块存放实际的内容，一块存放实际内容的地址，实际的内容空间一般不是分配在栈上的，而是分配在堆（也是内存的一部分，后续文章介绍）中，但存放地址的空间是分配在<strong>栈</strong>上的。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ArrayMax</span> </span>&#123;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">int</span> <span class="hljs-title">max</span><span class="hljs-params">(<span class="hljs-keyword">int</span> min, <span class="hljs-keyword">int</span>[] arr)</span> </span>&#123;<br>        <span class="hljs-keyword">int</span> max = min;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> a : arr)&#123;<br>            <span class="hljs-keyword">if</span>(a&gt;max)&#123;<br>                max = a;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> max;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>        <span class="hljs-keyword">int</span>[] arr = <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[]&#123;<span class="hljs-number">2</span>,<span class="hljs-number">3</span>,<span class="hljs-number">4</span>&#125;;<br>        <span class="hljs-keyword">int</span> ret = max(<span class="hljs-number">0</span>, arr);<br>        System.out.println(ret);<br>    &#125;<br><br>&#125;<br></code></pre></td></tr></table></figure><p><img src="http://oss.mengsu.site/image-20211220165347746.png" alt="image-20211220165347746"></p><h2 id="函数调用的成本"><a href="#函数调用的成本" class="headerlink" title="函数调用的成本"></a><strong>函数调用的成本</strong></h2><p>从函数调用的过程我们可以看出，调用是有成本的，每一次调用都需要<strong>分配额外的栈空间用于存储参数、局部变量以及返回地址，需要进行额外的入栈和出栈操作</strong>。</p><p>在递归调用的情况下，如果递归的次数比较多，这个成本是比较可观的，所以，<strong>如果程序可以比较容易的改为别的方式，应该考虑别的方式。</strong></p><p>函数调用主要是通过栈来存储相关数据的，系统就函数调用者和函数如何使用栈做了约定，返回值我们简化认为是通过一个专门的返回值存储器存储的。</p>]]></content>
    
    
    
    <tags>
      
      <tag>Java</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>java基础(02) - 字符编码</title>
    <link href="/2021/12/20/java/java-base-2/"/>
    <url>/2021/12/20/java/java-base-2/</url>
    
    <content type="html"><![CDATA[<h1 id="ASCII"><a href="#ASCII" class="headerlink" title="ASCII"></a><strong>ASCII</strong></h1><p>世界上虽然有各种各样的字符，但计算机发明之初没有考虑那么多，基本上只考虑了<strong>美国</strong>的需求，美国大概只需要<strong>128</strong>个字符，美国就规定了这128个字符的二进制表示方法。</p><p>这个方法是一个标准，称为ASCII编码，全称是American Standard Code for Information Interchange，美国信息互换标准代码。</p><p>128个字符用7个位刚好可以表示，计算机存储的最小单位是byte，即8位，ASCII码中最高位设置为0，用剩下的7位表示字符。这7位可以看做数字0到127，ASCII码规定了从0到127个，每个数字代表什么含义。</p><p><img src="http://oss.mengsu.site/924211-20160422101314320-785393147.jpeg" alt="924211-20160422101314320-785393147"></p><p>数字32到126表示的这些字符都是可打印字符，0到31和127表示一些不可以打印的字符，这些字符一般用于控制目的，这些字符中大部分都是不常用的，下表列出了其中相对常用的字符。</p><p><img src="https://images2015.cnblogs.com/blog/924211/201604/924211-20160422101334054-974012985.jpg" alt="img"></p><p>Ascii 码对美国是够用了，但对别的国家而言却是不够的，于是，各个国家的各种计算机厂商就发明了各种各种的编码方式以表示自己国家的字符，为了保持与Ascii 码的兼容性，一般都是将最高位设置为1。也就是说，当最高位为0时，表示Ascii码，当为1时就是各个国家自己的字符。</p><p>在这些扩展的编码中，在西欧国家中流行的是ISO 8859-1和Windows-1252，在中国是GB2312，GBK，GB18030和Big5，我们逐个来看下这些编码。</p><h1 id="ISO-8859-1"><a href="#ISO-8859-1" class="headerlink" title="ISO 8859-1"></a><strong>ISO 8859-1</strong></h1><p>ISO 8859-1又称Latin-1，它也是使用一个字节表示一个字符，其中0到127与Ascii一样，128到255规定了不同的含义。在128到255中，128到159表示一些控制字符，这些字符也不常用，就不介绍了。160到255表示一些西欧字符，如下图所示：</p><p><img src="http://oss.mengsu.site/image-20211220142501463.png" alt="image-20211220142501463"></p><h1 id="GB2312"><a href="#GB2312" class="headerlink" title="GB2312"></a><strong>GB2312</strong></h1><p>美国和西欧字符用一个字节就够了，但中文显然是不够的。<strong>中文第一个标准是GB2312</strong>。</p><p>GB2312标准主要针对的是简体中文常见字符，包括约7000个汉字，不包括一些罕用词，不包括繁体字。</p><p>GB2312固定使用两个字节表示汉字，在这两个字节中，最高位都是1，如果是0，就认为是Ascii字符。在这两个字节中，其中高位字节范围是0xA1-0xF7，低位字节范围是0xA1-0xFE。</p><h1 id="GBK"><a href="#GBK" class="headerlink" title="GBK"></a><strong>GBK</strong></h1><p>GBK建立在GB2312的基础上，向下兼容GB2312，也就是说，GB2312编码的字符和二进制表示，在GBK编码里是完全一样的。</p><p>GBK增加了一万四千多个汉字，共计约21000汉字，其中包括繁体字。</p><p>GBK同样使用固定的两个字节表示，其中高位字节范围是0x81-0xFE，低位字节范围是0x40-0x7E和0x80-0xFE。</p><p>需要注意的是，低位字节是从0x40也就是64开始的，也就是说，低位字节最高位可能为0。那怎么知道它是汉字的一部分，还是一个Ascii字符呢？</p><p>其实很简单，因为汉字是用固定两个字节表示的，在解析二进制流的时候，如果第一个字节的最高位为1，那么就将下一个字节读进来一起解析为一个汉字，而不用考虑它的最高位，解析完后，跳到第三个字节继续解析。</p><h1 id="GB18030"><a href="#GB18030" class="headerlink" title="GB18030"></a><strong>GB18030</strong></h1><p>GB18030向下兼容GBK，增加了<strong>五万五千多个字符</strong>，共<strong>七万六千多个字符</strong>。包括了很多少数民族字符，以及中日韩统一字符。</p><p>用两个字节已经表示不了GB18030中的所有字符，GB18030使用变长编码，有的字符是两个字节，有的是四个字节。</p><p>在两字节编码中，字节表示范围与GBK一样。在四字节编码中，第一个字节的值从0x81到0xFE，第二个字节的值从0x30到0x39，第三个字节的值从0x81到0xFE，第四个字节的值从0x30到0x39。</p><p>解析二进制时，如何知道是两个字节还是四个字节表示一个字符呢？看第二个字节的范围，如果是0x30到0x39就是四个字节表示，因为两个字节编码中第二字节都比这个大。</p><h1 id="Big5"><a href="#Big5" class="headerlink" title="Big5"></a><strong>Big5</strong></h1><p>Big5是针对繁体中文的，广泛用于台湾香港等地。</p><p>Big5包括1万3千多个繁体字，和GB2312类似，一个字符同样固定使用两个字节表示。在这两个字节中，高位字节范围是0x81-0xFE，低位字节范围是0x40-0x7E和0xA1-0xFE。</p><h1 id="编码汇总"><a href="#编码汇总" class="headerlink" title="编码汇总"></a><strong>编码汇总</strong></h1><p>我们简单汇总一下上面的内容。</p><p>Ascii码是基础，一个字节表示，最高位设为0，其他7位表示128个字符。其他编码都是兼容Ascii的，最高位使用1来进行区分。</p><p>西欧主要使用Windows-1252，使用一个字节，增加了额外128个字符。</p><p>中文大陆地区的三个主要编码GB2312，GBK，GB18030，有时间先后关系，表示的字符数越来越多，且后面的兼容前面的，GB2312和GBK都是用两个字节表示，而GB18030则使用两个或四个字节表示。</p><p>香港台湾地区的主要编码是Big5。</p><p>如果文本里的字符都是Ascii码字符，那么采用以上所说的任一编码方式都是一一样的。</p><p>但如果有高位为1的字符，除了GB2312/GBK/GB18030外，其他编码都是不兼容的，比如，Windows-1252和中文的各种编码是不兼容的，即使Big5和GB18030都能表示繁体字，其表示方式也是不一样的，而这就会出现所谓的乱码。</p><h1 id="Unicode"><a href="#Unicode" class="headerlink" title="Unicode"></a><strong>Unicode</strong></h1><p>以上我们介绍了中文和西欧的字符与编码，但世界上还有很多别的国家的字符，每个国家的各种计算机厂商都对自己常用的字符进行编码，在编码的时候基本忽略了别的国家的字符和编码，甚至忽略了同一国家的其他计算机厂商，这样造成的结果就是，出现了太多的编码，且互相不兼容。</p><p>世界上所有的字符能不能统一编码呢？可以，这就是Unicode。</p><p>Unicode 做了一件事，就是给世界上所有字符都分配了一个唯一的数字编号，这个编号范围从0x000000到0x10FFFF，包括110多万。但大部分常用字符都 在0x0000到0xFFFF之间，即65536个数字之内。每个字符都有一个Unicode编号，这个编号一般写成16进制，在前面加U+。大部分中文 的编号范围在U+4E00到U+9FA5，例如，”马”的Unicode是U+9A6C。</p><p>Unicode就做了这么 一件事，就是给所有字符分配了唯一数字编号。它并没有规定这个编号怎么对应到二进制表示，这是与上面介绍的其他编码不同的，其他编码都既规定了能表示哪些 字符，又规定了每个字符对应的二进制是什么，而Unicode本身只规定了每个字符的数字编号是多少。</p><p>那编号怎么对应到二进制表示呢？有多种方案，主要有UTF-32, UTF-16和UTF-8。</p><h1 id="UTF-32"><a href="#UTF-32" class="headerlink" title="UTF-32"></a><strong>UTF-32</strong></h1><p>这个最简单，就是字符编号的整数二进制形式，四个字节。</p><p>但有个细节，就是字节的排列顺序，如果第一个字节是整数二进制中的最高位，最后一个字节是整数二进制中的最低位，那这种字节序就叫“大端”（Big Endian, BE），否则，正好相反的情况，就叫“小端”（Little Endian, LE）。对应的编码方式分别是UTF-32BE和UTF-32LE。</p><p>可以看出，每个字符都用四个字节表示，非常浪费空间，实际采用的也比较少。</p><h1 id="UTF-16"><a href="#UTF-16" class="headerlink" title="UTF-16"></a><strong>UTF-16</strong></h1><p>UTF-16使用变长字节表示：</p><ul><li>对于编号在U+0000到U+FFFF的字符 (常用字符集），直接用两个字节表示。需要说明的是，U+D800到U+DBFF之间的编号其实是没有定义的。</li><li>字符值在U+10000到U+10FFFF之间的字符(也叫做增补字符集)，需要用四个字节表示。前两个字节叫高代理项，范围是U+D800到 U+DBFF，后两个字节叫低代理项，范围是U+DC00到U+DFFF。数字编号和这个二进制表示之间有一个转换算法，本文就不介绍了。</li></ul><p>区分是两个字节还是四个字节表示一个符号就看前两个字节的编号范围，如果是U+D800到U+DBFF，就是四个字节，否则就是两个字节。</p><p>UTF-16也有和UTF-32一样的字节序问题，如果高位存放在前面就叫大端(BE)，编码就叫UTF-16BE，否则就叫小端，编码就叫UTF-16LE。</p><p>UTF-16常用于系统内部编码，UTF-16比UTF-32节省了很多空间，但是任何一个字符都至少需要两个字节表示，对于美国和西欧国家而言，还是很浪费的。</p><h1 id="UTF-8"><a href="#UTF-8" class="headerlink" title="UTF-8"></a><strong>UTF-8</strong></h1><p>UTF-8就是使用变长字节表示，每个字符使用的字节个数与其Unicode编号的大小有关，编号小的使用的字节就少，编号大的使用的字节就多，使用的字节个数从1到4个不等。</p><p>具体来说，各个Unicode编号范围对应的二进制格式如下图所示：</p><p><img src="https://images2015.cnblogs.com/blog/924211/201604/924211-20160422101438460-952966359.jpg" alt="img"></p><p>图中的x表示可以用的二进制位，而每个字节开头的1或0是固定的。</p><p>小于128的，编码与Ascii码一样，最高位为0。其他编号的第一个字节有特殊含义，最高位有几个连续的1表示一共用几个字节表示，而其他字节都以10开头。</p><p>对于一个Unicode编号，具体怎么编码呢？首先将其看做整数，转化为二进制形式（去掉高位的0），然后将二进制位从右向左依次填入到对应的二进制格式x中，填完后，如果对应的二进制格式还有没填的x，则设为0。</p><p>我们来看个例子，’马’的Unicode编号是：0x9A6C，整数编号是39532，其对应的UTF-8二进制格式是：</p><p>1110xxxx 10xxxxxx 10xxxxxx</p><p>整数编号39532的二进制格式是 1001 101001 101100</p><p>将这个二进制位从右到左依次填入二进制格式中，结果就是其UTF-8编码：</p><p>11101001 10101001 10101100</p><p>16进制表示为：0xE9A9AC</p><p>和UTF-32/UTF-16不同，UTF-8是兼容Ascii的，对大部分中文而言，一个中文字符需要用三个字节表示。</p>]]></content>
    
    
    
    <tags>
      
      <tag>Java</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>java基础(01)</title>
    <link href="/2021/12/16/java/java-base-1/"/>
    <url>/2021/12/16/java/java-base-1/</url>
    
    <content type="html"><![CDATA[<h1 id="数据类型和变量"><a href="#数据类型和变量" class="headerlink" title="数据类型和变量"></a>数据类型和变量</h1><p>数据类型用于对数据归类，以便于理解和操作。对Java语言而言，有如下基本数据类型。</p><ul><li>整数类型：有4种整型byte/short/int/long,分别有不同的取值范围；</li><li>小数类型：有两种类型Hoat/doublc,有不同的取值范围和精度；</li><li>字符类型：char,表示单个字符；</li><li>真假类型：boolean，表示真假。</li></ul><p>为了操作数据，需要把数据存放到内存中。所谓内存在程序看来就是一块有地址编号的连续的空 间，数据放到内存中的某个位置后，为了方便地找到和操作这个数据，需要给这个位置起一个名字。编程 语言通过<strong>变量</strong>这个概念来表示这个过程。</p><p><strong>变量就是给数据起名字，方便找不同的数据，它的值可以变，但含义不应变。</strong></p><h2 id="基本数据类型"><a href="#基本数据类型" class="headerlink" title="基本数据类型"></a>基本数据类型</h2><h3 id="整数类型"><a href="#整数类型" class="headerlink" title="整数类型"></a>整数类型</h3><p>整数类型有byte、short、int和long,分别占1、2、4、8个字节</p><p><img src="http://oss.mengsu.site/image-20211216225240791.png" alt="image-20211216225240791"></p><p>赋值操作很简单，只需要把对应的值赋给定义的<strong>变量</strong>即可，但是要注意赋值的范围不能超出变量类型的最大取值范围。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">byte</span> b = <span class="hljs-number">23</span>; <br><span class="hljs-keyword">short</span> s = <span class="hljs-number">3333</span>; <br><span class="hljs-keyword">int</span> i = <span class="hljs-number">9999</span>;<br><span class="hljs-keyword">long</span> <span class="hljs-number">1</span> = <span class="hljs-number">32323</span>;<br><span class="hljs-comment">// 但是，在给long类型赋值时，如果常量超过了int的表示范围，需要在常量后面加大写或小写字母L, 即L或1</span><br><span class="hljs-keyword">long</span> a = <span class="hljs-number">3232343433L</span>;<br></code></pre></td></tr></table></figure><h3 id="小数类型"><a href="#小数类型" class="headerlink" title="小数类型"></a>小数类型</h3><p>小数类型有float和double,占用的内存空间分别是4和8字节，有不同的取值范围和精度，double表示 的范围更大，精度更高，E表示以10为底的指数，E后 面的+号和-号代表正指数和负指数，例如：1.4E-45表示1.4乘以10的-45次方。</p><p><img src="http://oss.mengsu.site/image-20211216230055879.png" alt="image-20211216230055879"></p><p>赋值操作</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">double</span> d = <span class="hljs-number">333.33</span>;<br><span class="hljs-comment">// 但对于float,需要在数字后面加大写字母F或小写字母f</span><br><span class="hljs-keyword">float</span> f = <span class="hljs-number">333.33f</span>;<br></code></pre></td></tr></table></figure><h3 id="真假类型"><a href="#真假类型" class="headerlink" title="真假类型"></a>真假类型</h3><p>真假(<strong>boolean</strong>)类型很简单，直接使用true或false赋值，分别表示真和假</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">boolean</span> b = <span class="hljs-keyword">true</span>; b = <span class="hljs-keyword">false</span>;<br></code></pre></td></tr></table></figure><h3 id="字符类型"><a href="#字符类型" class="headerlink" title="字符类型"></a>字符类型</h3><p>字符类型char用于表示一个字符，这个字符可以是中文字符，也可以是英文字符，char占用的内存空 间是两个字节。赋值时把常,字符用单引号括起来，不要使用双引号</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">char</span> c = <span class="hljs-string">&#x27;c&#x27;</span>;<br></code></pre></td></tr></table></figure><p>前面介绍的赋值都是在声明变量的时候就进行了赋值，但这不是必需的，可以先声明变量，随后再 进行赋值。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">int</span> a = <span class="hljs-number">1</span>;<br><span class="hljs-keyword">int</span> b = <span class="hljs-number">2</span>;<br><span class="hljs-comment">//2乘以a的值再加上b的值赋给c</span><br><span class="hljs-keyword">int</span> c = <span class="hljs-number">2</span> * t + b;<br></code></pre></td></tr></table></figure><p>本质</p><blockquote><p>char本质上是一个固定占用两个字节的<strong>无符号正整数</strong>，这个正整数对应于Unicode编号，用于表示那个Unicode编号对应的字符。</p><p>由于固定占用两个字节，char只能表示Unicode编号在<strong>65536</strong>以内的字符，而不能表示超出范围的字符。</p><p>那超出范围的字符怎么表示呢？使用两个char。类String有一些相关的方法，后续文章介绍。</p></blockquote><h2 id="数组类型"><a href="#数组类型" class="headerlink" title="数组类型"></a>数组类型</h2><p>基本类型的数组有3种赋值形式</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">int</span>[] arr = &#123;<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>&#125;;<br><span class="hljs-keyword">int</span>[] arr = <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[]&#123;<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>&#125;;<br><span class="hljs-keyword">int</span>[] arr = <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[<span class="hljs-number">3</span>];<br>arr[<span class="hljs-number">0</span>]=<span class="hljs-number">1</span>; arr[<span class="hljs-number">1</span>]=<span class="hljs-number">2</span>; arr[<span class="hljs-number">2</span>]=<span class="hljs-number">3</span>;<br></code></pre></td></tr></table></figure><p>数组的长度可以动态设置，但是长度一旦设置成功是不可以<strong>更改</strong>的，但只能读，不能改。</p><p><img src="http://oss.mengsu.site/image-20211216231353239.png" alt="image-20211216231353239"></p><h3 id="数组和基本类型的区别"><a href="#数组和基本类型的区别" class="headerlink" title="数组和基本类型的区别"></a><strong>数组和基本类型的区别</strong></h3><p>一个基本类型变量，内存中只会有一块对应的内存空间。但数组有两块，一块用于存储数组内容本身，另一块用于存储内容的位置。用一个例子来说明，有一个int变量a，和一个int数组变量arr</p><p><img src="http://oss.mengsu.site/image-20211216232517756.png" alt="image-20211216232517756"></p><h3 id="为什么数组要用两块空间"><a href="#为什么数组要用两块空间" class="headerlink" title="为什么数组要用两块空间"></a><strong>为什么数组要用两块空间</strong></h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">int</span>[] arrA = &#123;<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>&#125;;<br><br><span class="hljs-keyword">int</span>[] arrB = &#123;<span class="hljs-number">4</span>,<span class="hljs-number">5</span>,<span class="hljs-number">6</span>,<span class="hljs-number">7</span>&#125;;<br>arrA = arrB;<br></code></pre></td></tr></table></figure><p>这个代码中，arrA初始的长度是3，arrB的长度是4，后来将arrB的值赋给了arrA。如果arrA对应的内存空间是直接存储的数组内容，那么它将没有足够的空间去容纳arrB的所有元素。</p><p>用两块空间存储，这个就简单的多，arrA存储的值就变成了和arrB的一样，存储的都是数组内容{4,5,6,7}的地址，此后访问arrA就和arrB是一样的了，而arrA {1,2,3}的内存空间由于无人引用会被<strong>垃圾回收</strong></p><p>由上，也可以看出，给<strong>数组变量赋值</strong>和给<strong>数组中元素赋值</strong>是两回事。给数组中元素赋值是<strong>改变数组内容</strong>，而给数组变量赋值则会让变量<strong>指向一个不同的位置</strong>。</p><p><img src="http://oss.mengsu.site/image-20211216232936531.png" alt="image-20211216232936531"></p><h2 id="运算"><a href="#运算" class="headerlink" title="运算"></a><strong>运算</strong></h2><p>给数据赋值，有了初始值之后，可以对数据进行运算。计算机之所以称为”计算”机，是因为发明它的主要目的就是运算。运算有不同的类型，不同的数据类型支持的运算也不一样，本文介绍Java中基本类型数据的主要运算。</p><ul><li>算术运算：主要是日常的加减乘除</li><li>比较运算：主要是日常的大小比较</li><li>逻辑运算：针对布尔值进行运算</li></ul><h3 id="加减乘除注意事项"><a href="#加减乘除注意事项" class="headerlink" title="加减乘除注意事项"></a><strong>加减乘除注意事项</strong></h3><p>运算时要注意结果的范围，使用恰当的数据类型。两个正数都可以用int表示，但相乘的结果可能就会超，超出后结果会令人困惑，例如：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">int</span> a = <span class="hljs-number">2147483647</span>*<span class="hljs-number">2</span>; <span class="hljs-comment">//2147483647是int能表示的最大值</span><br><span class="hljs-comment">// a = -2 超出int最大范围，具体 -2 在后面详解</span><br></code></pre></td></tr></table></figure><p>需采用long的形式作为运行变量的接受变量，只改为long也是不够的，因为运算还是默认按照int类型进行，需要将至少一个数据表示为long形式，即在后面加L或l：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">long</span> a = <span class="hljs-number">2147483647</span>*<span class="hljs-number">2L</span>;<br></code></pre></td></tr></table></figure><p>整数相除不是四舍五入，而是直接舍去小数位，例如：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">double</span> d = <span class="hljs-number">10</span>/<span class="hljs-number">4</span>;<br></code></pre></td></tr></table></figure><p>结果是2而不是2.5，如果要按小数进行运算，需要将至少一个数表示为小数形式，或者使用强制类型转化，即在数字前面加(double)，表示将数字看做double类型，如下所示任意一种形式都可以：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">double</span> d = <span class="hljs-number">10</span>/<span class="hljs-number">4.0</span>;<br><span class="hljs-keyword">double</span> d = <span class="hljs-number">10</span>/(<span class="hljs-keyword">double</span>)<span class="hljs-number">4</span>;<br></code></pre></td></tr></table></figure><h3 id="自增-自减-–"><a href="#自增-自减-–" class="headerlink" title="自增(++)/自减(–)"></a><strong>自增(++)/自减(–)</strong></h3><p>自增/自减是对自己做加一和减一操作，但每个都有两种形式，一种是放在变量后，例如a++, a–，另一种是放在变量前，例如++a, –a。</p><p>区别在于还有其他操作的时候。放在变量后(a++)，是先用原来的值进行其他操作，然后再对自己做修改，而放在变量前(++a)，是先对自己做修改，再用修改后的值进行其他操作。</p><p><img src="http://oss.mengsu.site/image-20211216234502389.png" alt="image-20211216234502389"></p><h3 id="比较运算"><a href="#比较运算" class="headerlink" title="比较运算"></a><strong>比较运算</strong></h3><p>比较运算就是计算两个值之间的关系，结果是一个布尔类型(boolean)的值。</p><p>比较操作符有：大于(&gt;)，大于等于(&gt;=)，小于(&lt;)，小于等于(&lt;=)，等于(==)，不等于(!=)。</p><p>首先，它使用两个等号==，而不是一个等号(=)，为什么不用一个等号呢？因为一个等号(=)已经被占了，表示赋值操作。</p><p>另外，对于数组，==对于 <strong>基本数据类型</strong> 比较的是值，但是对于 <strong>对象类型</strong> 比较的是内存地址，在后续说明。</p><h3 id="逻辑运算"><a href="#逻辑运算" class="headerlink" title="逻辑运算"></a><strong>逻辑运算</strong></h3><p>逻辑运算根据数据的逻辑关系，生成一个布尔值true或者false。逻辑运算只可应用于boolean类型的数据，但比较运算的结果是布尔值，所以其他类型数据的比较结果可进行逻辑运算。</p><p>逻辑运算符具体有：</p><ul><li><p>与(&amp;)：两个都为true才是true，只要有一个是false就是false</p></li><li><p>或(|)：只要有一个为true就是true，都是false才是false</p></li><li><p>非(!)：针对一个变量，true会变成false, false会变成true</p></li><li><p>异或(^)：两个相同为false, 两个不相同为true</p></li><li><p>短路与(&amp;&amp;): 和&amp;类似，不同之处马上解释</p></li><li><p>短路或 (||)：与|类似，不同之处马上解释</p></li></ul><h3 id="运算符优先级"><a href="#运算符优先级" class="headerlink" title="运算符优先级"></a><strong>运算符优先级</strong></h3><p>一个稍微复杂的运算可能会涉及多个变量，和多种运算，那哪个先算，哪个后算呢？程序语言规定了不同运算符的优先级，有的会先算，有的会后算，大部分情况下，这个优先级与我们的常识理解是相符的。</p><p>但在一些复杂情况下，我们可能会搞不明白其运算顺序。但这个我们不用太操心，可以使用括号()来表达我们想要的顺序，括号里的会先进行运算，简单的说，不确定顺序的时候，就使用括号。</p><h2 id="整数的二进制表示与位运算"><a href="#整数的二进制表示与位运算" class="headerlink" title="整数的二进制表示与位运算"></a>整数的二进制表示与位运算</h2><h3 id="十进制"><a href="#十进制" class="headerlink" title="十进制"></a><strong>十进制</strong></h3><p>比如123，表示的1*(10^2) + 2*(10^1) + 3*(10^0)，从右向左，第一位乘以10的0次方， 即1，第二位乘以10的1次方，即10，第三位乘以10的2次方，即100，依次类推。换句话说，每个位置都有一个位权，从右到左，第一位为1，然后依次乘以10，即第二位为10，第三位为100，依次类推。<strong>十进制就是正整数</strong></p><h3 id="正整数转成二进制"><a href="#正整数转成二进制" class="headerlink" title="正整数转成二进制"></a>正整数转成二进制</h3><p>要点一定一定要记住哈：除二取余，然后倒序排列，高位补零。</p><p><img src="http://oss.mengsu.site/image-20211218000345272.png" alt="image-20211218000345272"></p><p>83除以2得到的余数分别为1100101，然后咱们倒着排一下，83所对应二进制就是1010011</p><h3 id="负整数转二进制"><a href="#负整数转二进制" class="headerlink" title="负整数转二进制"></a>负整数转二进制</h3><p>对于正整数二进制取反+1，高位补0，整数有四种类型，byte/short/int/long，分别占1/2/4/8个字节，即分别占8/16/32/64位</p><ul><li>-1：1的原码表示是00000001，取反是11111110，然后再加1，就是11111111。</li><li>-2：2的原码表示是00000010，取反是11111101，然后再加1，就是11111110。</li><li>-127：127的原码表示是01111111，取反是10000000，然后再加1，就是10000001。 </li></ul><h3 id="小数转二进制"><a href="#小数转二进制" class="headerlink" title="小数转二进制"></a><strong>小数转二进制</strong></h3><p>对小数点以后的数乘以2，有一个结果吧，取结果的整数部分（不是1就是0喽），然后再用小数部分再乘以2，再取结果的整数部分……以此类推，直到小数部分为0或者位数已经够了就OK了</p><figure class="highlight tex"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs tex">0.12345<br><br>0.12345 * 2 =  0.24690<br><br>0.2469 * 2 =  0.49380<br><br>0.4938 * 2 =  0.98760<br><br>0.9876 * 2 =  1.97521<br><br>0.9752 * 2 = 1.9504 1<br><br>...........忽略，直至小数部分为0，排序<br></code></pre></td></tr></table></figure><h3 id="十六进制"><a href="#十六进制" class="headerlink" title="十六进制"></a>十六进制</h3><p>二进制写起来太长，为了简化写法，可以将四个二进制位简化为一个0到15的数，10到15用字符A到F表示，这种表示方法称为16进制，如下所示：</p><p><img src="http://oss.mengsu.site/image-20211218110855495.png" alt="image-20211218110855495"></p><p>比如123转十六进制</p><p>123 / 16 = 7 余数 11，十六进制表示法。0x <strong>+</strong> 7B，B就是11，结果就是：<strong>0x7B</strong></p><h3 id="java正整数转换"><a href="#java正整数转换" class="headerlink" title="java正整数转换"></a>java正整数转换</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">int</span> a = <span class="hljs-number">25</span>;<br>System.out.println(Integer.toBinaryString(a)); <span class="hljs-comment">//二进制</span><br>System.out.println(Integer.toHexString(a));  <span class="hljs-comment">//十六进制</span><br>System.out.println(Long.toBinaryString(a)); <span class="hljs-comment">//二进制</span><br>System.out.println(Long.toHexString(a));  <span class="hljs-comment">//十六进制</span><br></code></pre></td></tr></table></figure><h3 id="位运算"><a href="#位运算" class="headerlink" title="位运算"></a><strong>位运算</strong></h3><p>位运算是将数据看做二进制，进行位级别的操作，Java不能单独表示一个位，但是可以用byte表示8位，可以用16进制写二进制常量。比如： 0010表示成16进制是 0x2, 110110表示成16进制是 0x36。</p><p>位运算有移位运算和逻辑运算。</p><p>移位有：</p><ul><li>左移：操作符为&lt;&lt;，向左移动，右边的低位补0，高位的就舍弃掉了，将二进制看做整数，左移1位就相当于乘以2。</li><li>无符号右移：操作符为&gt;&gt;&gt;，向右移动，右边的舍弃掉，左边补0。</li><li>有符号右移：操作符为&gt;&gt;，向右移动，右边的舍弃掉，左边补什么取决于原来最高位是什么，原来是1就补1，原来是0就补0，将二进制看做整数，右移1位相当于除以2。</li></ul><p>例如：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">int</span> a = <span class="hljs-number">4</span>; <span class="hljs-comment">// 100</span><br>a = a &gt;&gt; <span class="hljs-number">2</span>; <span class="hljs-comment">// 001，等于1</span><br>a = a &lt;&lt; <span class="hljs-number">3</span> <span class="hljs-comment">// 1000，变为8</span><br></code></pre></td></tr></table></figure><p>逻辑运算有：</p><ul><li>按位与 &amp;：两位都为1才为1</li><li>按位或 |：只要有一位为1，就为1</li><li>按位取反 ~： 1变为0，0变为1</li><li>按位异或 ^ ：相异为真，相同为假</li></ul><p>大部分都比较简单，就不详细说了。具体形式，例如：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">int</span> a = ...; <br>a = a &amp; <span class="hljs-number">0x1</span> <span class="hljs-comment">// 返回0或1，就是a最右边一位的值。</span><br>a = a | <span class="hljs-number">0x1</span> <span class="hljs-comment">//不管a原来最右边一位是什么，都将设为1</span><br></code></pre></td></tr></table></figure>]]></content>
    
    
    
    <tags>
      
      <tag>Java</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Effective Java 笔记</title>
    <link href="/2021/08/09/effective-java/"/>
    <url>/2021/08/09/effective-java/</url>
    
    <content type="html"><![CDATA[<h1 id="一、用静态工厂方法代替构造器"><a href="#一、用静态工厂方法代替构造器" class="headerlink" title="一、用静态工厂方法代替构造器"></a>一、用静态工厂方法代替构造器</h1><h3 id="优点"><a href="#优点" class="headerlink" title="优点"></a>优点</h3><ol><li>静态工厂方法与构造器不同的第一大优势在于，他们有名称</li></ol><blockquote><p>比如 BigInteger.probablePrime 直接返回可能为素数</p></blockquote><ol start="2"><li>静态工厂方法与构造器不同的第二大优势在于，不必在每次调用它们的时候都创建一个新对象</li></ol><blockquote><p>可以使用预先构建好的实例，或者将构建好的实例缓存起来， 进行重复利用，从而避免创建不必要的重复对象</p></blockquote><ol start="3"><li>静态工厂方法与构造器不同的第三大优势在于，它们可以返回原返回类型的任何子类型的对象</li></ol><blockquote><p>例如 Java Collections Framework 的集合接口有 45 个工具实现，分别提供了不可修改的集合、 同步集合，等等</p></blockquote><ol start="4"><li>静态工厂的第四大优势在于，所返回的对象的类可以随着每次调用而发生变化，这取决于静态工厂方法的参数值</li></ol><blockquote><p>..</p></blockquote><ol start="5"><li>静态工厂的第五大优势在于，方法返回的对象所属的类，在编写包含该静态工厂方法的类时可以不存在</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/** 返回Connection,该类为DriverManager.class */</span><br>    <span class="hljs-meta">@CallerSensitive</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> Connection <span class="hljs-title">getConnection</span><span class="hljs-params">(String url,</span></span><br><span class="hljs-params"><span class="hljs-function">        java.util.Properties info)</span> <span class="hljs-keyword">throws</span> SQLException </span>&#123;<br><br>        <span class="hljs-keyword">return</span> (getConnection(url, info, Reflection.getCallerClass()));<br>    &#125;<br></code></pre></td></tr></table></figure><h3 id="缺点"><a href="#缺点" class="headerlink" title="缺点"></a>缺点</h3><ol><li>静态工厂方法的主要缺点在子，类如果不含公有的或者受保护的构造器，就不能被子类化</li><li>静态工厂方法的第二个缺点在于，程序员很难发现它们</li></ol><blockquote><p>对于提供了静态工厂方法而不是构造器的类来说，要想查明如何实例化一个类是非常困难的 。</p></blockquote><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><blockquote><p>简而言之，静态工厂方法和公有构造器都有用处，我们需要理解他们各自的长处。静态工厂经常更加合适，因此切忌第一反应就是提供公有的构造器，而不先考虑静态工厂。</p></blockquote><h1 id="二、遇到多个构造器参数时要考虑使用构建器"><a href="#二、遇到多个构造器参数时要考虑使用构建器" class="headerlink" title="二、遇到多个构造器参数时要考虑使用构建器"></a>二、遇到多个构造器参数时要考虑使用构建器</h1><blockquote><p>静态工厂和构造器有个共同的局限性：它们都不能很好 扩展到大量的可选参数</p><p>重叠构造器模式可行，但是当有许多参数的时候，客户端代码会很难缩写，并且仍然较难以阅读</p><p>简而言之 如果类的构造器或者静态工厂中具有多个参数，设计这种类时， Builde模式就是一种不错的选择，</p><p>采用 <code>Buide</code> 模式</p></blockquote><h1 id="三、用私有构造器或者枚举类型强化-Singleton-属性"><a href="#三、用私有构造器或者枚举类型强化-Singleton-属性" class="headerlink" title="三、用私有构造器或者枚举类型强化 Singleton 属性"></a>三、用私有构造器或者枚举类型强化 Singleton 属性</h1>]]></content>
    
    
    
    <tags>
      
      <tag>Effective Java</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>springboot源码分析(04) - SpringApplication run</title>
    <link href="/2021/08/01/springboot-source-04/"/>
    <url>/2021/08/01/springboot-source-04/</url>
    
    <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>上节讲了 <code>SpringApplication</code> 的构造方法，这节咱们来看下 <code>SpringApplication</code> 的 <code>run</code> 方法。</p><h1 id="run方法"><a href="#run方法" class="headerlink" title="run方法"></a>run方法</h1><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// SpringApplication.java</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> ConfigurableApplicationContext <span class="hljs-title">run</span><span class="hljs-params">(String... args)</span> </span>&#123;<br>  <span class="hljs-comment">// &lt;1&gt; 创建 StopWatch 对象，并启动。StopWatch 主要用于简单统计 run 启动过程的时长。</span><br>StopWatch stopWatch = <span class="hljs-keyword">new</span> StopWatch();<br>stopWatch.start();<br>  <span class="hljs-comment">// 初始化ApplicationContext</span><br>ConfigurableApplicationContext context = <span class="hljs-keyword">null</span>;<br>Collection&lt;SpringBootExceptionReporter&gt; exceptionReporters = <span class="hljs-keyword">new</span> ArrayList&lt;&gt;();<br>  <span class="hljs-comment">// &lt;2&gt; 配置 headless 属性</span><br>configureHeadlessProperty();<br>  <span class="hljs-comment">// &lt;3&gt; 获得 SpringApplicationRunListener 的数组，并启动监听</span><br>SpringApplicationRunListeners listeners = getRunListeners(args);<br>  <span class="hljs-comment">// &lt;3.1&gt; 构建 ApplicationStartingEvent 事件，并且启动</span><br>listeners.starting();<br><span class="hljs-keyword">try</span> &#123;<br>      <span class="hljs-comment">// &lt;4&gt; 创建  ApplicationArguments 对象</span><br>ApplicationArguments applicationArguments = <span class="hljs-keyword">new</span> DefaultApplicationArguments(args);<br>      <span class="hljs-comment">// &lt;5&gt; 加载属性配置。执行完成后，所有的 environment 的属性都会加载进来，包括 application.properties 和外部的属性配置。</span><br>ConfigurableEnvironment environment = prepareEnvironment(listeners, applicationArguments);<br>configureIgnoreBeanInfo(environment);<br><span class="hljs-comment">// &lt;6&gt; 打印 Spring Banner</span><br>      Banner printedBanner = printBanner(environment);<br>      <span class="hljs-comment">// &lt;7&gt; 创建 Spring 容器。</span><br>context = createApplicationContext();<br>      <span class="hljs-comment">// &lt;8&gt; 异常报告器</span><br>exceptionReporters = getSpringFactoriesInstances(SpringBootExceptionReporter.class,<br><span class="hljs-keyword">new</span> Class[] &#123; ConfigurableApplicationContext.class &#125;, context);<br>      <span class="hljs-comment">// &lt;9&gt; 主要是调用所有初始化类的 initialize 方法</span><br>prepareContext(context, environment, listeners, applicationArguments, printedBanner);<br><span class="hljs-comment">// &lt;10&gt; 初始化 Spring 容器。</span><br>      refreshContext(context);<br>      <span class="hljs-comment">// &lt;11&gt; 执行 Spring 容器的初始化的后置逻辑。默认实现为空。</span><br>afterRefresh(context, applicationArguments);<br>      <span class="hljs-comment">// &lt;12&gt; 停止 StopWatch 统计时长</span><br>stopWatch.stop();<br>      <span class="hljs-comment">// &lt;13&gt; 打印 Spring Boot 启动的时长日志。</span><br><span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span>.logStartupInfo) &#123;<br><span class="hljs-keyword">new</span> StartupInfoLogger(<span class="hljs-keyword">this</span>.mainApplicationClass).logStarted(getApplicationLog(), stopWatch);<br>&#125;<br>      <span class="hljs-comment">// &lt;14&gt; 通知 SpringApplicationRunListener 的数组，Spring 容器启动完成。</span><br>listeners.started(context);<br>      <span class="hljs-comment">// &lt;15&gt; 调用 ApplicationRunner 或者 CommandLineRunner 的运行方法。</span><br>callRunners(context, applicationArguments);<br>&#125;<br><span class="hljs-keyword">catch</span> (Throwable ex) &#123;<br>      <span class="hljs-comment">// &lt;15.1&gt; 如果发生异常，则进行处理，并抛出 IllegalStateException 异常</span><br>handleRunFailure(context, ex, exceptionReporters, listeners);<br><span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> IllegalStateException(ex);<br>&#125;<br><br>  <span class="hljs-comment">// &lt;16&gt; 通知 SpringApplicationRunListener 的数组，Spring 容器运行中。</span><br><span class="hljs-keyword">try</span> &#123;<br>listeners.running(context);<br>&#125;<br><span class="hljs-keyword">catch</span> (Throwable ex) &#123;<br>      <span class="hljs-comment">// &lt;16.1&gt; 如果发生异常，则进行处理，并抛出 IllegalStateException 异常</span><br>handleRunFailure(context, ex, exceptionReporters, <span class="hljs-keyword">null</span>);<br><span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> IllegalStateException(ex);<br>&#125;<br><span class="hljs-keyword">return</span> context;<br>&#125;<br></code></pre></td></tr></table></figure><blockquote><p>咱们可以重点关注下一下几个点。</p></blockquote><ol><li><p>&lt;1&gt; 处， <code>StopWatch</code> 主要用于简单统计 <code>run</code> 启动过程的时长。</p></li><li><p>&lt;2&gt; 处，配置 <code>awt</code> &gt; <code>java.awt.headless</code> 为 <code>true</code>。</p></li><li><p>&lt;3&gt; 处，调用 <code>#getRunListeners(String[] args)</code> 方法，获得 <code>SpringApplicationRunListener</code> 数组，并启动监听。调用位置咱们在讲解 <a href="https://mengsu.site/2021/07/31/springboot-source-03/#SpringFactoriesLoader-loadFactoryNames">SpringApplication构造方法</a> 中提到过，这是是读取缓存中的值 <code>Map&lt;ClassLoader, MultiValueMap&lt;String, String&gt;&gt; cache</code> 。</p><p>&lt;3.1&gt; 处，构建了一个ApplicationStartingEvent事件，并将其发布出去，其中调用了resolveDefaultEventType方法，该方法返回了一个封装了事件的默认类型（ApplicationStartingEvent）的ResolvableType对象。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Override</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">multicastEvent</span><span class="hljs-params">(<span class="hljs-keyword">final</span> ApplicationEvent event, <span class="hljs-meta">@Nullable</span> ResolvableType eventType)</span> </span>&#123;<br>ResolvableType type = (eventType != <span class="hljs-keyword">null</span> ? eventType : resolveDefaultEventType(event));<br>Executor executor = getTaskExecutor();<br><span class="hljs-keyword">for</span> (ApplicationListener&lt;?&gt; listener : getApplicationListeners(event, type)) &#123;<br><span class="hljs-keyword">if</span> (executor != <span class="hljs-keyword">null</span>) &#123;<br>executor.execute(() -&gt; invokeListener(listener, event));<br>&#125;<br><span class="hljs-keyword">else</span> &#123;<br>invokeListener(listener, event);<br>&#125;<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>这里不得不提的就是springboot的事件机制</p><blockquote><p>事件源：SpringApplication</p><p>事件：ApplicationStartingEvent</p><p>监听器：过滤后的监听器，具体5个上文中已经说过</p><p>事件环境：EventPublishingListener，提供环境支持事件，并且发布事件（starting方法）</p></blockquote><blockquote><p>初略的看，就是遍历getApplicationListeners(event, type)，然后对每个listener进行invokeListener(listener, event)</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">protected</span> Collection&lt;ApplicationListener&lt;?&gt;&gt; getApplicationListeners(<br>ApplicationEvent event, ResolvableType eventType) &#123;<br><br>Object source = event.getSource();<br>Class&lt;?&gt; sourceType = (source != <span class="hljs-keyword">null</span> ? source.getClass() : <span class="hljs-keyword">null</span>);<br>ListenerCacheKey cacheKey = <span class="hljs-keyword">new</span> ListenerCacheKey(eventType, sourceType);<br><br><span class="hljs-comment">// Quick check for existing entry on ConcurrentHashMap...</span><br>ListenerRetriever retriever = <span class="hljs-keyword">this</span>.retrieverCache.get(cacheKey);<br><span class="hljs-keyword">if</span> (retriever != <span class="hljs-keyword">null</span>) &#123;<br><span class="hljs-keyword">return</span> retriever.getApplicationListeners();<br>&#125;<br><br><span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span>.beanClassLoader == <span class="hljs-keyword">null</span> ||<br>(ClassUtils.isCacheSafe(event.getClass(), <span class="hljs-keyword">this</span>.beanClassLoader) &amp;&amp;<br>(sourceType == <span class="hljs-keyword">null</span> || ClassUtils.isCacheSafe(sourceType, <span class="hljs-keyword">this</span>.beanClassLoader)))) &#123;<br><span class="hljs-comment">// Fully synchronized building and caching of a ListenerRetriever</span><br><span class="hljs-keyword">synchronized</span> (<span class="hljs-keyword">this</span>.retrievalMutex) &#123;<br>retriever = <span class="hljs-keyword">this</span>.retrieverCache.get(cacheKey);<br><span class="hljs-keyword">if</span> (retriever != <span class="hljs-keyword">null</span>) &#123;<br><span class="hljs-keyword">return</span> retriever.getApplicationListeners();<br>&#125;<br>retriever = <span class="hljs-keyword">new</span> ListenerRetriever(<span class="hljs-keyword">true</span>);<br>Collection&lt;ApplicationListener&lt;?&gt;&gt; listeners =<br>retrieveApplicationListeners(eventType, sourceType, retriever);<br><span class="hljs-keyword">this</span>.retrieverCache.put(cacheKey, retriever);<br><span class="hljs-keyword">return</span> listeners;<br>&#125;<br>&#125;<br><span class="hljs-keyword">else</span> &#123;<br><span class="hljs-comment">// No ListenerRetriever caching -&gt; no synchronization necessary</span><br><span class="hljs-keyword">return</span> retrieveApplicationListeners(eventType, sourceType, <span class="hljs-keyword">null</span>);<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><blockquote><p>从上图可知，主要涉及到3个点：缓存retrieverCache、retrieveApplicationListeners已经retrieveApplicationListeners中调用的supportsEvent方法。流程是这样的：</p><p>1、缓存中是否有匹配的结果，有则返回</p><p>2、若缓存中没有匹配的结果，则从this.defaultRetriever.applicationListeners中过滤，这个this表示的EventPublishingRunListener对象的属性initialMulticaster（也就是SimpleApplicationEventMulticaster对象，而defaultRetriever.applicationListeners的值也是在EventPublishingRunListener构造方法中初始化的）</p><p>3、过滤过程，遍历defaultRetriever.applicationListeners集合，从中找出ApplicationStartingEvent匹配的listener，具体的匹配规则需要看各个listener的supportsEventType方法（有两个重载的方法）</p><p>4、将过滤的结果缓存到retrieverCache</p><p>5、将过滤出的结果返回回去</p></blockquote><p>过滤出的listener对象有哪些:</p><p><img src="/images/springboot/springboot-run-starting.png"></p><blockquote><p>invokeListener</p><p>使用给定的事件调用给定的监听器</p><p>　　getApplicationListeners方法过滤出的监听器都会被调用，过滤出来的监听器包括LoggingApplicationListener、BackgroundPreinitializer、DelegatingApplicationListener、LiquibaseServiceLocatorApplicationListener、EnableEncryptablePropertiesBeanFactoryPostProcessor五种类型的对象。这五个对象的onApplicationEvent都会被调用。</p><p>　　那么这五个监听器的onApplicationEvent都做了些什么了</p><p>　　　　　　LoggingApplicationListener：检测正在使用的日志系统，默认是logback，支持3种，优先级从高到低：logback &gt; log4j &gt; javalog。此时日志系统还没有初始化</p><p>　　　　　　BackgroundPreinitializer：另起一个线程实例化Initializer并调用其run方法，包括验证器、消息转换器等等</p><p>　　　　　　DelegatingApplicationListener：此时什么也没做</p><p>　　　　　　LiquibaseServiceLocatorApplicationListener：此时什么也没做</p><p>　　　　　　EnableEncryptablePropertiesBeanFactoryPostProcessor：此时仅仅打印了一句日志，其他什么也没做</p></blockquote></li><li><p>&lt;4&gt; 处，创建 <code>DefaultApplicationArguments</code> </p></li><li><p>&lt;5&gt; 处，调用 <code>#prepareEnvironment(SpringApplicationRunListeners listeners, ApplicationArguments applicationArguments)</code> 方法，加载属性配置。执行完成后，所有的 environment 的属性都会加载进来，包括 <code>application.properties</code> 和外部的属性配置。</p></li><li><p>&lt;6&gt; 处，调用 <code>#printBanner(ConfigurableEnvironment environment)</code> 方法，打印 Spring Banner 。</p></li><li><p>&lt;7&gt; 处，调用 <code>#createApplicationContext()</code> 方法，创建 Spring 容器。请看代码：</p></li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">protected</span> ConfigurableApplicationContext <span class="hljs-title">createApplicationContext</span><span class="hljs-params">()</span> </span>&#123;<br>Class&lt;?&gt; contextClass = <span class="hljs-keyword">this</span>.applicationContextClass;<br><span class="hljs-keyword">if</span> (contextClass == <span class="hljs-keyword">null</span>) &#123;<br><span class="hljs-keyword">try</span> &#123;<br><span class="hljs-keyword">switch</span> (<span class="hljs-keyword">this</span>.webApplicationType) &#123;<br><span class="hljs-keyword">case</span> SERVLET: <span class="hljs-comment">// 这里</span><br>contextClass = Class.forName(DEFAULT_SERVLET_WEB_CONTEXT_CLASS);<br><span class="hljs-keyword">break</span>;<br><span class="hljs-keyword">case</span> REACTIVE:<br>contextClass = Class.forName(DEFAULT_REACTIVE_WEB_CONTEXT_CLASS);<br><span class="hljs-keyword">break</span>;<br><span class="hljs-keyword">default</span>:<br>contextClass = Class.forName(DEFAULT_CONTEXT_CLASS);<br>&#125;<br>&#125;<br><span class="hljs-keyword">catch</span> (ClassNotFoundException ex) &#123;<br><span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> IllegalStateException(<br><span class="hljs-string">&quot;Unable create a default ApplicationContext, &quot;</span> + <span class="hljs-string">&quot;please specify an ApplicationContextClass&quot;</span>,<br>ex);<br>&#125;<br>&#125;<br><span class="hljs-keyword">return</span> (ConfigurableApplicationContext) BeanUtils.instantiateClass(contextClass);<br>&#125;<br></code></pre></td></tr></table></figure><blockquote><p>根据SpringApplication的webApplicationType来实例化对应的上下文；如果webApplicationType的值是SERVLET，那么实例化AnnotationConfigServletWebServerApplicationContext，如果是REACTIVE则实例化AnnotationConfigReactiveWebServerApplicationContext（响应式编程，后续再看），如果既不是SERVLET、也不是REACTIVE，那么则是默认情况（也就是我们所说的非web引用），实例化AnnotationConfigApplicationContext。很显然我们目前的应用类型是SERVLET，那么实例化AnnotationConfigServletWebServerApplicationContext。</p></blockquote><ol start="8"><li><p>&lt;8&gt; 处，…</p></li><li><p>&lt;9&gt; 处，<code>#prepareContext(ConfigurableApplicationContext context, ConfigurableEnvironment environment, SpringApplicationRunListeners listeners, ApplicationArguments applicationArguments, Banner printedBanner)</code> 方法，准备 ApplicationContext 对象，主要是初始化它的一些属性。</p></li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">prepareContext</span><span class="hljs-params">(ConfigurableApplicationContext context, ConfigurableEnvironment environment,</span></span><br><span class="hljs-params"><span class="hljs-function">SpringApplicationRunListeners listeners, ApplicationArguments applicationArguments, Banner printedBanner)</span> </span>&#123;<br><span class="hljs-comment">// &lt;1&gt; 设置 context 的 environment 属性</span><br>  context.setEnvironment(environment);<br>  <span class="hljs-comment">// &lt;2&gt; 设置 context 的一些属性</span><br>postProcessApplicationContext(context);<br>  <span class="hljs-comment">// &lt;3&gt; 初始化 ApplicationContextInitializer</span><br>applyInitializers(context);<br>  <span class="hljs-comment">// &lt;4&gt; 通知 SpringApplicationRunListener 的数组，Spring 容器准备完成。</span><br>listeners.contextPrepared(context);<br>  <span class="hljs-comment">// &lt;5&gt; 打印日志</span><br><span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span>.logStartupInfo) &#123;<br>logStartupInfo(context.getParent() == <span class="hljs-keyword">null</span>);<br>logStartupProfileInfo(context);<br>&#125;<br><span class="hljs-comment">// Add boot specific singleton beans</span><br>  <span class="hljs-comment">// &lt;6&gt; 设置 beanFactory 的属性</span><br>ConfigurableListableBeanFactory beanFactory = context.getBeanFactory();<br>beanFactory.registerSingleton(<span class="hljs-string">&quot;springApplicationArguments&quot;</span>, applicationArguments);<br><span class="hljs-keyword">if</span> (printedBanner != <span class="hljs-keyword">null</span>) &#123;<br>beanFactory.registerSingleton(<span class="hljs-string">&quot;springBootBanner&quot;</span>, printedBanner);<br>&#125;<br><span class="hljs-keyword">if</span> (beanFactory <span class="hljs-keyword">instanceof</span> DefaultListableBeanFactory) &#123;<br>((DefaultListableBeanFactory) beanFactory)<br>.setAllowBeanDefinitionOverriding(<span class="hljs-keyword">this</span>.allowBeanDefinitionOverriding);<br>&#125;<br><span class="hljs-comment">// Load the sources</span><br>  <span class="hljs-comment">// &lt;7&gt; 加载 BeanDefinition 们</span><br>Set&lt;Object&gt; sources = getAllSources();<br>Assert.notEmpty(sources, <span class="hljs-string">&quot;Sources must not be empty&quot;</span>);<br>load(context, sources.toArray(<span class="hljs-keyword">new</span> Object[<span class="hljs-number">0</span>]));<br>  <span class="hljs-comment">// &lt;8&gt; 通知 SpringApplicationRunListener 的数组，Spring 容器加载完成。</span><br>listeners.contextLoaded(context);<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    
    <tags>
      
      <tag>SpringBoot</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>springboot源码分析(03) - SpringApplication构造方法</title>
    <link href="/2021/07/31/springboot-source-03/"/>
    <url>/2021/07/31/springboot-source-03/</url>
    
    <content type="html"><![CDATA[<h1 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h1><p>上节自己搭建的 <code>web</code> 例子</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">import</span> org.springframework.boot.SpringApplication;<br><span class="hljs-keyword">import</span> org.springframework.boot.autoconfigure.SpringBootApplication;<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@Author</span>: mengsu</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@Date</span>: 2021/7/30</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@Description</span>:</span><br><span class="hljs-comment"> */</span><br><span class="hljs-meta">@SpringBootApplication</span> <span class="hljs-comment">// &lt;1&gt;</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MyTestMVCApplication</span> </span>&#123;<br><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>SpringApplication.run(MyTestMVCApplication.class, args);  <span class="hljs-comment">// &lt;2&gt;</span><br>&#125;<br><br>&#125;<br></code></pre></td></tr></table></figure><ul><li><code>&lt;1&gt;</code> 处，使用 <code>@SpringBootApplication</code> 注解，标明是 Spring Boot 应用。通过它，可以开启自动配置的功能。</li><li><code>&lt;2&gt;</code> 处，调用 <code>SpringApplication#run(Class&lt;?&gt;... primarySources)</code> 方法，启动 Spring Boot 应用。</li></ul><p>上述的代码，是我们使用 Spring Boot 时，最最最常用的代码。而本文，我们先来分析 Spring Boot 应用的<strong>启动过程</strong>。</p><h3 id="SpringApplication类注释"><a href="#SpringApplication类注释" class="headerlink" title="SpringApplication类注释"></a>SpringApplication类注释</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Class that can be used to bootstrap and launch a Spring application from a Java main</span><br><span class="hljs-comment"> * method. By default class will perform the following steps to bootstrap your</span><br><span class="hljs-comment"> * application:</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> * &lt;ul&gt;</span><br><span class="hljs-comment"> * &lt;li&gt;Create an appropriate &#123;<span class="hljs-doctag">@link</span> ApplicationContext&#125; instance (depending on your</span><br><span class="hljs-comment"> * classpath)&lt;/li&gt;</span><br><span class="hljs-comment"> * &lt;li&gt;Register a &#123;<span class="hljs-doctag">@link</span> CommandLinePropertySource&#125; to expose command line arguments as</span><br><span class="hljs-comment"> * Spring properties&lt;/li&gt;</span><br><span class="hljs-comment"> * &lt;li&gt;Refresh the application context, loading all singleton beans&lt;/li&gt;</span><br><span class="hljs-comment"> * &lt;li&gt;Trigger any &#123;<span class="hljs-doctag">@link</span> CommandLineRunner&#125; beans&lt;/li&gt;</span><br><span class="hljs-comment"> * &lt;/ul&gt;</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> * In most circumstances the static &#123;<span class="hljs-doctag">@link</span> #run(Class, String[])&#125; method can be called</span><br><span class="hljs-comment"> * directly from your &#123;<span class="hljs-doctag">@literal</span> main&#125; method to bootstrap your application:</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> * &lt;pre class=&quot;code&quot;&gt;</span><br><span class="hljs-comment"> * &amp;#064;Configuration</span><br><span class="hljs-comment"> * &amp;#064;EnableAutoConfiguration</span><br><span class="hljs-comment"> * public class MyApplication  &#123;</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> *   // ... Bean definitions</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> *   public static void main(String[] args) &#123;</span><br><span class="hljs-comment"> *     SpringApplication.run(MyApplication.class, args);</span><br><span class="hljs-comment"> *   &#125;</span><br><span class="hljs-comment"> * &#125;</span><br><span class="hljs-comment"> * &lt;/pre&gt;</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> * &lt;p&gt;</span><br><span class="hljs-comment"> * For more advanced configuration a &#123;<span class="hljs-doctag">@link</span> SpringApplication&#125; instance can be created and</span><br><span class="hljs-comment"> * customized before being run:</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> * &lt;pre class=&quot;code&quot;&gt;</span><br><span class="hljs-comment"> * public static void main(String[] args) &#123;</span><br><span class="hljs-comment"> *   SpringApplication application = new SpringApplication(MyApplication.class);</span><br><span class="hljs-comment"> *   // ... customize application settings here</span><br><span class="hljs-comment"> *   application.run(args)</span><br><span class="hljs-comment"> * &#125;</span><br><span class="hljs-comment"> * &lt;/pre&gt;</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> * &#123;<span class="hljs-doctag">@link</span> SpringApplication&#125;s can read beans from a variety of different sources. It is</span><br><span class="hljs-comment"> * generally recommended that a single &#123;<span class="hljs-doctag">@code</span> <span class="hljs-doctag">@Configuration</span>&#125; class is used to bootstrap</span><br><span class="hljs-comment"> * your application, however, you may also set &#123;<span class="hljs-doctag">@link</span> #getSources() sources&#125; from:</span><br><span class="hljs-comment"> * &lt;ul&gt;</span><br><span class="hljs-comment"> * &lt;li&gt;The fully qualified class name to be loaded by</span><br><span class="hljs-comment"> * &#123;<span class="hljs-doctag">@link</span> AnnotatedBeanDefinitionReader&#125;&lt;/li&gt;</span><br><span class="hljs-comment"> * &lt;li&gt;The location of an XML resource to be loaded by &#123;<span class="hljs-doctag">@link</span> XmlBeanDefinitionReader&#125;, or</span><br><span class="hljs-comment"> * a groovy script to be loaded by &#123;<span class="hljs-doctag">@link</span> GroovyBeanDefinitionReader&#125;&lt;/li&gt;</span><br><span class="hljs-comment"> * &lt;li&gt;The name of a package to be scanned by &#123;<span class="hljs-doctag">@link</span> ClassPathBeanDefinitionScanner&#125;&lt;/li&gt;</span><br><span class="hljs-comment"> * &lt;/ul&gt;</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> * Configuration properties are also bound to the &#123;<span class="hljs-doctag">@link</span> SpringApplication&#125;. This makes it</span><br><span class="hljs-comment"> * possible to set &#123;<span class="hljs-doctag">@link</span> SpringApplication&#125; properties dynamically, like additional</span><br><span class="hljs-comment"> * sources (&quot;spring.main.sources&quot; - a CSV list) the flag to indicate a web environment</span><br><span class="hljs-comment"> * (&quot;spring.main.web-application-type=none&quot;) or the flag to switch off the banner</span><br><span class="hljs-comment"> * (&quot;spring.main.banner-mode=off&quot;).</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@author</span> Phillip Webb</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@author</span> Dave Syer</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@author</span> Andy Wilkinson</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@author</span> Christian Dupuis</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@author</span> Stephane Nicoll</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@author</span> Jeremy Rickard</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@author</span> Craig Burke</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@author</span> Michael Simons</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@author</span> Madhura Bhave</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@author</span> Brian Clozel</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@author</span> Ethan Rubinson</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@since</span> 1.0.0</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@see</span> #run(Class, String[])</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@see</span> #run(Class[], String[])</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@see</span> #SpringApplication(Class...)</span><br><span class="hljs-comment"> */</span><br></code></pre></td></tr></table></figure><p><code>SpringApplication</code> 用于从 <code>java main</code> 方法引导和启动 <code>Spring</code> 应用程序，默认情况下，将执行以下步骤来引导我们的应用程序：</p><ol><li>创建一个恰当的 <code>ApplicationContext</code> 实例（取决于类路径）</li><li>注册 <code>CommandLinePropertySource</code> ，将命令行参数公开为 <code>Spring</code> 属性</li><li>刷新应用程序上下文，加载所有单例 <code>bean</code></li><li>触发全部 <code>CommandLineRunner bean</code></li></ol><p>大多数情况下，像 <code>SpringApplication.run(MyTestMVCApplication, args)</code> ; 这样启动我们的应用，也可以在运行之前创建和自定义 <code>SpringApplication</code> 实例，具体可以参考注释中示例。<code>SpringApplication</code> 可以从各种不同的源读取bean。 通常建议使用单个 <code>@Configuration</code> 类来引导，但是我们也可以通过以下方式来设置资源：</p><ol><li>通过 <code>AnnotatedBeanDefinitionReader</code> 加载完全限定类名</li><li>通过 <code>XmlBeanDefinitionReader</code> 加载 XML 资源位置，或者是通过 <code>GroovyBeanDefinitionReader</code> 加载 <code>groovy</code> 脚本位置</li><li>通过 <code>ClassPathBeanDefinitionScanner</code> 扫描包名称</li></ol><p>也就是说 <code>SpringApplication</code> 还是做了不少事的，具体实现后续会慢慢讲来，今天的主角只是 <code>SpringApplication</code> 构造方法。</p><h1 id="SpringApplication构造方法"><a href="#SpringApplication构造方法" class="headerlink" title="SpringApplication构造方法"></a>SpringApplication构造方法</h1><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123; <span class="hljs-comment">// &lt;1&gt;</span><br>SpringApplication.run(MyTestMVCApplication.class, args);   <br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> ConfigurableApplicationContext <span class="hljs-title">run</span><span class="hljs-params">(Class&lt;?&gt; primarySource, String... args)</span> </span>&#123; <span class="hljs-comment">// &lt;2&gt;</span><br><span class="hljs-keyword">return</span> run(<span class="hljs-keyword">new</span> Class&lt;?&gt;[] &#123; primarySource &#125;, args);<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> ConfigurableApplicationContext <span class="hljs-title">run</span><span class="hljs-params">(Class&lt;?&gt;[] primarySources, String[] args)</span> </span>&#123; <span class="hljs-comment">// &lt;3&gt;</span><br><span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> SpringApplication(primarySources).run(args);   <br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">SpringApplication</span><span class="hljs-params">(Class&lt;?&gt;... primarySources)</span> </span>&#123; <span class="hljs-comment">// &lt;4&gt;</span><br><span class="hljs-keyword">this</span>(<span class="hljs-keyword">null</span>, primarySources);<br>&#125;<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Create a new &#123;<span class="hljs-doctag">@link</span> SpringApplication&#125; instance. The application context will load</span><br><span class="hljs-comment"> * beans from the specified primary sources (see &#123;<span class="hljs-doctag">@link</span> SpringApplication class-level&#125;</span><br><span class="hljs-comment"> * documentation for details. The instance can be customized before calling</span><br><span class="hljs-comment"> * &#123;<span class="hljs-doctag">@link</span> #run(String...)&#125;.</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@param</span> resourceLoader the resource loader to use</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@param</span> primarySources the primary bean sources</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@see</span> #run(Class, String[])</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@see</span> #setSources(Set)</span><br><span class="hljs-comment"> */</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">SpringApplication</span><span class="hljs-params">(ResourceLoader resourceLoader, Class&lt;?&gt;... primarySources)</span> </span>&#123; <span class="hljs-comment">// &lt;5&gt;</span><br><span class="hljs-keyword">this</span>.resourceLoader = resourceLoader;   <br>Assert.notNull(primarySources, <span class="hljs-string">&quot;PrimarySources must not be null&quot;</span>);<br><span class="hljs-keyword">this</span>.primarySources = <span class="hljs-keyword">new</span> LinkedHashSet&lt;&gt;(Arrays.asList(primarySources)); <br><span class="hljs-keyword">this</span>.webApplicationType = WebApplicationType.deduceFromClasspath(); <span class="hljs-comment">// &lt;5.1&gt;</span><br>setInitializers((Collection) getSpringFactoriesInstances(ApplicationContextInitializer.class));  <span class="hljs-comment">// &lt;5.2&gt;</span><br>setListeners((Collection) getSpringFactoriesInstances(ApplicationListener.class)); <span class="hljs-comment">// &lt;5.3&gt;</span><br><span class="hljs-keyword">this</span>.mainApplicationClass = deduceMainApplicationClass();  <span class="hljs-comment">// &lt;5.4&gt;</span><br>&#125;<br></code></pre></td></tr></table></figure><p>按照层级跳转分为以上五个层级结构，可以发现咱们自定义的 <code>MyTestMVCApplication main</code> 方法都是调用的 <code>SpringApplication</code> 静态方法，直接到达的构造函数。</p><p>从 <code>SpringApplication</code> 构造函数的注释上来看，就是说创建一个 <code>MyTestMVCApplication </code>实例，应用上下文从特定的资源文件中加载<code>bean</code>。可以在调用<code>run</code>之前自定义实例。</p><h2 id="5-1-WebApplicationType-deduceFromClasspath"><a href="#5-1-WebApplicationType-deduceFromClasspath" class="headerlink" title="5.1 WebApplicationType.deduceFromClasspath()"></a>5.1 WebApplicationType.deduceFromClasspath()</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">static</span> WebApplicationType <span class="hljs-title">deduceFromClasspath</span><span class="hljs-params">()</span> </span>&#123;<br><span class="hljs-keyword">if</span> (ClassUtils.isPresent(WEBFLUX_INDICATOR_CLASS, <span class="hljs-keyword">null</span>) &amp;&amp; !ClassUtils.isPresent(WEBMVC_INDICATOR_CLASS, <span class="hljs-keyword">null</span>)<br>&amp;&amp; !ClassUtils.isPresent(JERSEY_INDICATOR_CLASS, <span class="hljs-keyword">null</span>)) &#123;<br><span class="hljs-keyword">return</span> WebApplicationType.REACTIVE;<br>&#125;<br><span class="hljs-keyword">for</span> (String className : SERVLET_INDICATOR_CLASSES) &#123;<br>     <span class="hljs-comment">// 判断给定的类是否能够加载，就是说类路径下是否存在给定的类</span><br><span class="hljs-keyword">if</span> (!ClassUtils.isPresent(className, <span class="hljs-keyword">null</span>)) &#123;<br><span class="hljs-keyword">return</span> WebApplicationType.NONE;<br>&#125;<br>&#125;<br><span class="hljs-keyword">return</span> WebApplicationType.SERVLET;<br>&#125;<br></code></pre></td></tr></table></figure><blockquote><p>如果<code>org.springframework.web.reactive.DispatcherHandler</code>能够被加载且<code>org.springframework.web.servlet.DispatcherServlet</code>不能够被加载，那么断定<code>web</code>应用类型是<code>REACTIVE</code>；如果<code>javax.servlet.Servlet</code>和<code>org.springframework.web.context.ConfigurableWebApplicationContext</code>任意一个不能被加载，那么断定<code>web</code>应用类型是<code>NONE</code>；如果不能断定是<code>REACTIVE</code>和<code>NONE</code>，那么就是<code>SERVLET</code>类型；具体这三种类型代表什么含义，可以查看WebApplicationType中的说明。　　</p></blockquote><h2 id="5-2-setInitializers-Collection-getSpringFactoriesInstances-ApplicationContextInitializer-class"><a href="#5-2-setInitializers-Collection-getSpringFactoriesInstances-ApplicationContextInitializer-class" class="headerlink" title="5.2 setInitializers((Collection) getSpringFactoriesInstances(ApplicationContextInitializer.class));"></a>5.2 setInitializers((Collection) getSpringFactoriesInstances(ApplicationContextInitializer.class));</h2><blockquote><p>从字面意思看就是获取spring工厂实例，至于从哪获取哪些工厂实例，我们往下看。</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">private</span> &lt;T&gt; <span class="hljs-function">Collection&lt;T&gt; <span class="hljs-title">getSpringFactoriesInstances</span><span class="hljs-params">(Class&lt;T&gt; type)</span> </span>&#123; <span class="hljs-comment">// &lt;1&gt;</span><br><span class="hljs-keyword">return</span> getSpringFactoriesInstances(type, <span class="hljs-keyword">new</span> Class&lt;?&gt;[] &#123;&#125;);<br>&#125;<br><br><span class="hljs-keyword">private</span> &lt;T&gt; <span class="hljs-function">Collection&lt;T&gt; <span class="hljs-title">getSpringFactoriesInstances</span><span class="hljs-params">(Class&lt;T&gt; type, Class&lt;?&gt;[] parameterTypes, Object... args)</span> </span>&#123; <span class="hljs-comment">// &lt;2&gt;</span><br>ClassLoader classLoader = getClassLoader();<br><span class="hljs-comment">// Use names and ensure unique to protect against duplicates</span><br>Set&lt;String&gt; names = <span class="hljs-keyword">new</span> LinkedHashSet&lt;&gt;(SpringFactoriesLoader.loadFactoryNames(type, classLoader));<br>List&lt;T&gt; instances = createSpringFactoriesInstances(type, parameterTypes, classLoader, args, names);<br>AnnotationAwareOrderComparator.sort(instances);<br><span class="hljs-keyword">return</span> instances;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="SpringFactoriesLoader-loadFactoryNames"><a href="#SpringFactoriesLoader-loadFactoryNames" class="headerlink" title="SpringFactoriesLoader.loadFactoryNames"></a>SpringFactoriesLoader.loadFactoryNames</h3><blockquote><p><strong>SpringFactoriesLoader.loadFactoryNames</strong> 可以先留意下，该处代码会在 <code>run</code> 的时候进行读取，可以看到现在的作用就是为了初始化实例，并且放在缓存当中。</p><ol><li><p>查找类路径下全部的META-INF/spring.factories的URL</p></li><li><p>根据url加载全部的spring.factories中的属性，spring.factories内容如下</p></li><li><p>将所有spring.factories中的值缓存到SpringFactoriesLoader的cache中：</p><p>private static final Map&lt;ClassLoader, MultiValueMap&lt;String, String&gt;&gt; cache = new ConcurrentReferenceHashMap&lt;&gt;()；方便下次调用。</p></li></ol></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> List&lt;String&gt; <span class="hljs-title">loadFactoryNames</span><span class="hljs-params">(Class&lt;?&gt; factoryClass, <span class="hljs-meta">@Nullable</span> ClassLoader classLoader)</span> </span>&#123;<br>String factoryClassName = factoryClass.getName();<br><span class="hljs-keyword">return</span> loadSpringFactories(classLoader).getOrDefault(factoryClassName, Collections.emptyList());<br>&#125;<br><br><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> Map&lt;String, List&lt;String&gt;&gt; loadSpringFactories(<span class="hljs-meta">@Nullable</span> ClassLoader classLoader) &#123;<br>MultiValueMap&lt;String, String&gt; result = cache.get(classLoader);<br><span class="hljs-keyword">if</span> (result != <span class="hljs-keyword">null</span>) &#123;<br><span class="hljs-keyword">return</span> result;<br>&#125;<br><br><span class="hljs-keyword">try</span> &#123;<br>     <span class="hljs-comment">// classLoader.getResources(FACTORIES_RESOURCE_LOCATION)获取类路径下全部的META-INF/spring.factories的URL</span><br>Enumeration&lt;URL&gt; urls = (classLoader != <span class="hljs-keyword">null</span> ?<br>classLoader.getResources(FACTORIES_RESOURCE_LOCATION) :<br>ClassLoader.getSystemResources(FACTORIES_RESOURCE_LOCATION));<br>result = <span class="hljs-keyword">new</span> LinkedMultiValueMap&lt;&gt;();<br>     <span class="hljs-comment">// 遍历全部的URL，逐个读取META-INF/spring.factories中的属性</span><br><span class="hljs-keyword">while</span> (urls.hasMoreElements()) &#123;<br>URL url = urls.nextElement();<br>UrlResource resource = <span class="hljs-keyword">new</span> UrlResource(url);<br>Properties properties = PropertiesLoaderUtils.loadProperties(resource);<br><span class="hljs-keyword">for</span> (Map.Entry&lt;?, ?&gt; entry : properties.entrySet()) &#123;<br>String factoryClassName = ((String) entry.getKey()).trim();<br>         <span class="hljs-comment">// 属性全部放入MultiValueMap&lt;String, String&gt; result中，注意result的类型</span><br><span class="hljs-keyword">for</span> (String factoryName : StringUtils.commaDelimitedListToStringArray((String) entry.getValue())) &#123;<br>result.add(factoryClassName, factoryName.trim());<br>&#125;<br>&#125;<br>&#125;<br>     <span class="hljs-comment">// 结果放入缓存，方便下次查找，run方法中会使用缓存</span><br>cache.put(classLoader, result);<br><span class="hljs-keyword">return</span> result;<br>&#125;<br><span class="hljs-keyword">catch</span> (IOException ex) &#123;<br><span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> IllegalArgumentException(<span class="hljs-string">&quot;Unable to load factories from location [&quot;</span> +<br>FACTORIES_RESOURCE_LOCATION + <span class="hljs-string">&quot;]&quot;</span>, ex);<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="createSpringFactoriesInstances"><a href="#createSpringFactoriesInstances" class="headerlink" title="createSpringFactoriesInstances"></a>createSpringFactoriesInstances</h3><blockquote><p>根据上面获取的指定类型的工厂名称列表来实例化工厂bean，我们可以简单的认为通过反射来实例化，但是具体的实现也没那么简单，感兴趣的可以自己去跟。</p></blockquote><h3 id="AnnotationAwareOrderComparator-sort-instances"><a href="#AnnotationAwareOrderComparator-sort-instances" class="headerlink" title="AnnotationAwareOrderComparator.sort(instances)"></a>AnnotationAwareOrderComparator.sort(instances)</h3><blockquote><p>排序规则：@Order从小到大排序，没有order则按没排序之前的顺序。</p></blockquote><h2 id="5-3-getSpringFactoriesInstances-ApplicationListener-class"><a href="#5-3-getSpringFactoriesInstances-ApplicationListener-class" class="headerlink" title="5.3 getSpringFactoriesInstances(ApplicationListener.class))"></a>5.3 getSpringFactoriesInstances(ApplicationListener.class))</h2><blockquote><p>类似 5.2 一样，  只是传入的类型不同 &gt; <code>ApplicationListener</code></p></blockquote><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><ol><li>构造自身实例</li><li>推测web应用类型，并赋值到属性webApplicationType</li><li> 设置属性 </li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java">List&lt;ApplicationContextInitializer&lt;?&gt;&gt; initializers<br>List&lt;ApplicationListener&lt;?&gt;&gt; listeners<br></code></pre></td></tr></table></figure><p>中途读取了类路径下所有META-INF/spring.factories的属性，并缓存到了SpringFactoriesLoader的cache缓存中</p><ol start="4"><li>推断主类，并赋值到属性mainApplicationClass</li></ol>]]></content>
    
    
    
    <tags>
      
      <tag>SpringBoot</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>springboot源码分析(02) - 项目结构详解</title>
    <link href="/2021/07/30/springboot-source-02/"/>
    <url>/2021/07/30/springboot-source-02/</url>
    
    <content type="html"><![CDATA[<h1 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h1><p>本文主要分享 <strong>Spring Boot 的项目结构</strong>。<br>希望通过本文能让胖友对 Spring Boot 的整体项目有个简单的了解。</p><p><img src="/images/springboot/springboot-root.png"></p><h1 id="spring-boot-project-项目"><a href="#spring-boot-project-项目" class="headerlink" title="spring-boot-project 项目"></a>spring-boot-project 项目</h1><p>结构如下</p><p><img src="/images/springboot/springboot-project.png"></p><h2 id="spring-boot-模块"><a href="#spring-boot-模块" class="headerlink" title="spring-boot 模块"></a>spring-boot 模块</h2><p><code>spring-boot</code> 模块，Spring Boot 的核心实现</p><ul><li><p>在 <code>org.springframework.boot.SpringApplication</code> 类，提供了大量的静态方法，可以很容易运行一个独立的 Spring 应用程序。</p><blockquote><p>经常使用。</p></blockquote></li><li><p>带有可选容器的嵌入式 Web 应用程序（Tomcat、Jetty、Undertow） 的支持。</p><blockquote><p>在 <code>org.springframework.boot.web</code> 包下实现。</p></blockquote></li><li><p>边界的外部配置支持。</p></li><li><p>… 省略其它。</p></li></ul><h2 id="spring-boot-autoconfigure-模块"><a href="#spring-boot-autoconfigure-模块" class="headerlink" title="spring-boot-autoconfigure 模块"></a>spring-boot-autoconfigure 模块</h2><p><code>spring-boot-autoconfigure</code> 可以根据类路径的内容，自动配置大部分常用应用程序。通过使用 <code>org.springframework.boot.autoconfigure.@EnableAutoConfiguration</code> 注解，会触发 Spring 上下文的自动配置。</p><blockquote><p>这里的大部分，指的是常用的框架。例如说，Spring MVC、Quartz 等等。也就是说，如果 <code>spring-boot-actuator-autoconfigure</code> 模块，暂未提供的框架，需要我们自己去实现对应框架的自动装配。</p></blockquote><p>这个模块的代码，必须要看，没得商量。</p><p>所以到此处为止，我们已经看到对我们来研究 Spring Boot 最最最重要的两个模块：<code>spring-boot</code> 和 <code>spring-boot-autoconfigure</code> 。</p><h2 id="spring-boot-actuator-模块"><a href="#spring-boot-actuator-模块" class="headerlink" title="spring-boot-actuator 模块"></a>spring-boot-actuator 模块</h2><p><code>spring-boot-actuator</code> 模块。正如其模块的英文 actuator ，它完全是一个用于暴露应用自身信息的模块：</p><ul><li>提供了一个监控和管理生产环境的模块，可以使用 http、jmx、ssh、telnet 等管理和监控应用。</li><li>审计（Auditing）、 健康（health）、数据采集（metrics gathering）会自动加入到应用里面。</li></ul><blockquote><p>一般情况下，我们可以不看这块代码的代码。</p></blockquote><h2 id="spring-boot-actuator-autoconfigure-模块"><a href="#spring-boot-actuator-autoconfigure-模块" class="headerlink" title="spring-boot-actuator-autoconfigure 模块"></a>spring-boot-actuator-autoconfigure 模块</h2><p><code>spring-boot-actuator-autoconfigure</code> 模块，大概 1W7 行代码左右。它提供了 <code>spring-boot-actuator</code> 的自动配置功能。</p><blockquote><p>一般情况下，我们可以不看这块代码的代码。</p></blockquote><h2 id="spring-boot-starters-模块"><a href="#spring-boot-starters-模块" class="headerlink" title="spring-boot-starters 模块"></a>spring-boot-starters 模块</h2><p><code>spring-boot-starters</code> 模块，它不存在任何的代码，而是提供我们常用框架的 Starter 模块。例如：</p><ul><li><code>spring-boot-starter-web</code> 模块，提供了对 Spring MVC 的 Starter 模块。</li><li><code>spring-boot-starter-data-jpa</code> 模块，提供了对 Spring Data JPA 的 Starter 模块。</li></ul><p>而每个 Starter 模块，里面只存在一个 <code>pom</code> 文件，这是为什么呢？简单来说，Spring Boot 可以根据项目中是否存在指定类，并且是否未生成对应的 Bean 对象，那么就自动创建 Bean 对象。因为有这样的机制，我们只需要使用 <code>pom</code> 文件，配置需要引入的框架，就可以实现该框架的使用所需要的类的自动装配。</p><blockquote><p>当然，如果其中没有自己想要的starter， 可以自定义实现。</p></blockquote><h2 id="spring-boot-cli-模块"><a href="#spring-boot-cli-模块" class="headerlink" title="spring-boot-cli 模块"></a>spring-boot-cli 模块</h2><p><code>spring-boot-cli</code> 模块，大概 1W 行代码左右。它提供了 Spring 项目相关的命令行功能。它是 Spring Boot 的命令行界面。</p><ul><li>它可以用来快速启动 Spring 。</li><li>它可以运行 Groovy 脚本，开发人员不需要编写很多样板代码，只需要关注业务逻辑。</li><li>Spring Boot CLI 是创建基于Spring的应用程序的最快方法。</li></ul><blockquote><p>一般情况下，我们可以不看这块代码的代码。</p></blockquote><h2 id="spring-boot-test-模块"><a href="#spring-boot-test-模块" class="headerlink" title="spring-boot-test 模块"></a>spring-boot-test 模块</h2><p><code>spring-boot-test</code> 模块，大概 1W 行代码左右。Spring Boot 提供测试方面的支持，例如说：</p><ul><li>SpringBootTestRandomPortEnvironmentPostProcessor 类，提供随机端口。</li><li><code>org.springframework.boot.test.mock.mockito</code> 包，提供 Mockito 的增强。</li></ul><blockquote><p>一般情况下，我们可以不看这块代码的代码。</p></blockquote><h2 id="spring-boot-test-autoconfigure-模块"><a href="#spring-boot-test-autoconfigure-模块" class="headerlink" title="spring-boot-test-autoconfigure 模块"></a>spring-boot-test-autoconfigure 模块</h2><p><code>spring-boot-test-autoconfigure</code> 模块，大概 1W 行代码不到。它提供了 <code>spring-boot-test</code> 的自动配置功能。</p><blockquote><p>一般情况下，我们可以不看这块代码的代码。</p></blockquote><h2 id="spring-boot-devtools-模块"><a href="#spring-boot-devtools-模块" class="headerlink" title="spring-boot-devtools 模块"></a>spring-boot-devtools 模块</h2><p><code>spring-boot-devtools</code> 模块，大概 8000 行代码左右。通过它，来使 Spring Boot 应用支持热部署，提高开发者的开发效率，无需手动重启 Spring Boot 应用。</p><blockquote><p>一般情况下，我们可以不看这块代码的代码。</p></blockquote><h2 id="spring-boot-tools-模块"><a href="#spring-boot-tools-模块" class="headerlink" title="spring-boot-tools 模块"></a>spring-boot-tools 模块</h2><p><code>spring-boot-tools</code> 模块，大概 3W 行代码左右。它是 Spring Boot 提供的工具箱，所以在其内有多个子 Maven 项目。</p><p>注意哟，我们这里说的工具箱，并不是我们在 Java 里的工具类。困惑？我们来举个例子：<code>spring-boot-maven-plugin</code> 模块：提供 Maven 打包 Spring Boot 项目的插件。</p><p>关于 <code>spring-boot-tools</code> 模块的其它子模块，我们就暂时不多做介绍落。</p><blockquote><p>一般情况下，我们可以不看这块代码的代码。</p></blockquote><h1 id="spring-boot-samples-项目"><a href="#spring-boot-samples-项目" class="headerlink" title="spring-boot-samples 项目"></a>spring-boot-samples 项目</h1><p><code>spring-boot-samples</code> 项目，2W 行代码左右。丧心病狂，提供了超级多的示例，简直良心无敌啊。</p><blockquote><p>一般情况下，我们可以不看这块代码的代码。如果真的需要某个 Spring Boot 对某个框架的示例，大多数情况下，我们还是 Google 检索文章居多。</p></blockquote><h1 id="spring-boot-samples-invoker-项目"><a href="#spring-boot-samples-invoker-项目" class="headerlink" title="spring-boot-samples-invoker 项目"></a>spring-boot-samples-invoker 项目</h1><p><code>spring-boot-samples-invoker</code> 项目，无代码，不用看。当然，也并不重要。</p><h1 id="spring-boot-tests"><a href="#spring-boot-tests" class="headerlink" title="spring-boot-tests"></a>spring-boot-tests</h1><p><code>spring-boot-tests</code> 项目，3000 行代码，主要是 Spring Boot 的集成测试、部署测试。</p><blockquote><p>一般情况下，我们可以不看这块代码的代码。</p></blockquote><h1 id="结尾"><a href="#结尾" class="headerlink" title="结尾"></a>结尾</h1><p>所以我们重点关注的应该是： spring-boot-project ： <code>spring-boot</code>  和 <code>spring-boot-autoconfigure</code> 和  <code>spring-boot-starters</code></p>]]></content>
    
    
    
    <tags>
      
      <tag>SpringBoot</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>springboot源码分析(01) - 搭建调试环境</title>
    <link href="/2021/07/29/springboot-source-01/"/>
    <url>/2021/07/29/springboot-source-01/</url>
    
    <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>为了更加深入理解<code>springboot</code>，近期开始阅读<code>springboot</code>的源码，话不多说，开干！</p><h1 id="依赖工具"><a href="#依赖工具" class="headerlink" title="依赖工具"></a>依赖工具</h1><ul><li>Maven (springboot好多版本都是使用Gradle构建，搭建的胖友们需注意)</li><li>Git</li><li>Jdk8+</li><li>IntelliJ IDEA</li></ul><h1 id="源码拉取"><a href="#源码拉取" class="headerlink" title="源码拉取"></a>源码拉取</h1><p>从官方仓库 <a href="https://github.com/spring-projects/spring-boot">https://github.com/spring-projects/spring-boot</a> <code>Fork</code> 出属于自己的仓库。</p><ul><li>为什么要 <code>Fork</code> ？既然开始阅读、调试源码，我们可能会写一些注释，有了自己的仓库，可以进行自由的提交。</li><li>本文使用的 springboot 版本为 <code>2.1.19.BUILD-SNAPSHOT</code> 。</li><li>使用 <code>IntelliJ IDEA</code> 从 <code>Fork</code> 出来的仓库拉取代码。因为 Spring 项目比较大，从仓库中拉取代码的时间会比较长。</li></ul><p>拉取完成后，Maven 会开始自动 <strong>Build</strong> 项目。因为 Build 的过程中，会下载非常多的依赖，请耐心等待。</p><h1 id="构建调试Demo"><a href="#构建调试Demo" class="headerlink" title="构建调试Demo"></a>构建调试Demo</h1><h2 id="解决-pom-的报错"><a href="#解决-pom-的报错" class="headerlink" title="解决 pom 的报错"></a>解决 pom 的报错</h2><p>在根目录的 <code>pom.xml</code> 中，会看到 <code>$&#123;disable.checks&#125;</code> 报错。它是用来配置，是否开启 Maven 代码检查的插件。因为，我们目的是为了调试代码，所以自然是去禁用它。仅仅需要在 <code>pom.xml</code> 配置如下：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">properties</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">revision</span>&gt;</span>2.1.19.BUILD-SNAPSHOT<span class="hljs-tag">&lt;/<span class="hljs-name">revision</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">main.basedir</span>&gt;</span>$&#123;basedir&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">main.basedir</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">disable.checks</span>&gt;</span>true<span class="hljs-tag">&lt;/<span class="hljs-name">disable.checks</span>&gt;</span>    <span class="hljs-comment">&lt;!-- 我是被加的 --&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">properties</span>&gt;</span><br></code></pre></td></tr></table></figure><h2 id="搭建-MVC-调试环境"><a href="#搭建-MVC-调试环境" class="headerlink" title="搭建 MVC 调试环境"></a>搭建 MVC 调试环境</h2><p>在 <code>spring-boot-tests</code>  下新模块 <code>spring-boot-xxx-tests</code>  &gt;  以后自己测试的模块都是放在里面, 在新建的模块下面再新建 <code>spring-boot-xxx-mvc-tests</code> </p><p>spring-boot-xxx-tests pom文件</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-meta">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">project</span> <span class="hljs-attr">xmlns</span>=<span class="hljs-string">&quot;http://maven.apache.org/POM/4.0.0&quot;</span></span><br><span class="hljs-tag"> <span class="hljs-attr">xmlns:xsi</span>=<span class="hljs-string">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span></span><br><span class="hljs-tag"> <span class="hljs-attr">xsi:schemaLocation</span>=<span class="hljs-string">&quot;http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd&quot;</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">parent</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-boot-tests<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework.boot<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>$&#123;revision&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">parent</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">modelVersion</span>&gt;</span>4.0.0<span class="hljs-tag">&lt;/<span class="hljs-name">modelVersion</span>&gt;</span><br><br><span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-boot-mengsu-tests<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">packaging</span>&gt;</span>pom<span class="hljs-tag">&lt;/<span class="hljs-name">packaging</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">modules</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">module</span>&gt;</span>spring-boot-xxx-mvc-tests<span class="hljs-tag">&lt;/<span class="hljs-name">module</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">modules</span>&gt;</span><br><br><span class="hljs-tag">&lt;<span class="hljs-name">description</span>&gt;</span>我的Spring Boot测试模块<span class="hljs-tag">&lt;/<span class="hljs-name">description</span>&gt;</span><br><br><span class="hljs-tag">&lt;<span class="hljs-name">properties</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">main.basedir</span>&gt;</span>$&#123;basedir&#125;/../..<span class="hljs-tag">&lt;/<span class="hljs-name">main.basedir</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">java.version</span>&gt;</span>1.8<span class="hljs-tag">&lt;/<span class="hljs-name">java.version</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">properties</span>&gt;</span><br><br><span class="hljs-tag">&lt;/<span class="hljs-name">project</span>&gt;</span><br></code></pre></td></tr></table></figure><p>spring-boot-xxx-mvc-tests pom文件</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-meta">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">project</span> <span class="hljs-attr">xmlns</span>=<span class="hljs-string">&quot;http://maven.apache.org/POM/4.0.0&quot;</span></span><br><span class="hljs-tag"> <span class="hljs-attr">xmlns:xsi</span>=<span class="hljs-string">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span></span><br><span class="hljs-tag"> <span class="hljs-attr">xsi:schemaLocation</span>=<span class="hljs-string">&quot;http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd&quot;</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">parent</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-boot-mengsu-tests<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework.boot<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>$&#123;revision&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">parent</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">modelVersion</span>&gt;</span>4.0.0<span class="hljs-tag">&lt;/<span class="hljs-name">modelVersion</span>&gt;</span><br><br><span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-boot-mengsu-mvc-tests<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">name</span>&gt;</span>我的Spring Boot测试模块 之 MVC部分<span class="hljs-tag">&lt;/<span class="hljs-name">name</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">description</span>&gt;</span>$&#123;project.name&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">description</span>&gt;</span><br><br><span class="hljs-tag">&lt;<span class="hljs-name">properties</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">main.basedir</span>&gt;</span>$&#123;basedir&#125;/../../..<span class="hljs-tag">&lt;/<span class="hljs-name">main.basedir</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">properties</span>&gt;</span><br><br><span class="hljs-tag">&lt;<span class="hljs-name">dependencies</span>&gt;</span><br><span class="hljs-comment">&lt;!-- Compile --&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework.boot<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-boot-starter-web<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">dependencies</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">build</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">plugins</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">plugin</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework.boot<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-boot-maven-plugin<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">plugin</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">plugins</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">build</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">project</span>&gt;</span><br></code></pre></td></tr></table></figure><p>新建Application 启动类</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> site.mengsu;<br><br><span class="hljs-keyword">import</span> org.springframework.boot.SpringApplication;<br><span class="hljs-keyword">import</span> org.springframework.boot.autoconfigure.SpringBootApplication;<br><span class="hljs-keyword">import</span> org.springframework.web.bind.annotation.GetMapping;<br><span class="hljs-keyword">import</span> org.springframework.web.bind.annotation.RestController;<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@Author</span>: mengsu</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@Date</span>: 2021/7/30</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@Description</span>:</span><br><span class="hljs-comment"> */</span><br><span class="hljs-meta">@RestController</span><br><span class="hljs-meta">@SpringBootApplication</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MyTestMVCApplication</span> </span>&#123;<br><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>SpringApplication.run(MyTestMVCApplication.class, args);<br>&#125;<br><br><span class="hljs-meta">@GetMapping</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">index</span> <span class="hljs-params">()</span> </span>&#123;<br><span class="hljs-keyword">return</span> <span class="hljs-string">&quot;success&quot;</span>;<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="测试运行"><a href="#测试运行" class="headerlink" title="测试运行"></a>测试运行</h2><p><code>MyTestMVCApplication</code> 启动，访问：<a href="http://localhost:8080/">http://localhost:8080/</a></p><p>返回：success，即为成功。</p>]]></content>
    
    
    
    <tags>
      
      <tag>SpringBoot</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Nacos配置中心</title>
    <link href="/2021/07/27/nacos-config/"/>
    <url>/2021/07/27/nacos-config/</url>
    
    <content type="html"><![CDATA[<h1 id="概念"><a href="#概念" class="headerlink" title="概念"></a><a href="https://github.com/alibaba/spring-cloud-alibaba/wiki/Nacos-config#spring-cloud-alibaba-nacos-config">概念</a></h1><p>Nacos 提供用于存储配置和其他元数据的 key/value 存储，为分布式系统中的外部化配置提供服务器端和客户端支持。使用 Spring Cloud Alibaba Nacos Config，您可以在 Nacos Server 集中管理你 Spring Cloud 应用的外部属性配置。</p><p>Spring Cloud Alibaba Nacos Config 是 Config Server 和 Client 的替代方案，客户端和服务器上的概念与 Spring Environment 和 PropertySource 有着一致的抽象，在特殊的 bootstrap 阶段，配置被加载到 Spring 环境中。当应用程序通过部署管道从开发到测试再到生产时，您可以管理这些环境之间的配置，并确保应用程序具有迁移时需要运行的所有内容。</p><h1 id="快速开始"><a href="#快速开始" class="headerlink" title="快速开始"></a>快速开始</h1><h2 id="引入依赖"><a href="#引入依赖" class="headerlink" title="引入依赖"></a>引入依赖</h2><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>   <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>com.alibaba.cloud<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>   <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-cloud-alibaba-dependencies<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>   <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>$&#123;spring.cloud.alibaba.version&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br>   <span class="hljs-tag">&lt;<span class="hljs-name">type</span>&gt;</span>pom<span class="hljs-tag">&lt;/<span class="hljs-name">type</span>&gt;</span><br>   <span class="hljs-tag">&lt;<span class="hljs-name">scope</span>&gt;</span>import<span class="hljs-tag">&lt;/<span class="hljs-name">scope</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>   <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>com.alibaba.cloud<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>   <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-cloud-starter-alibaba-nacos-config<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br></code></pre></td></tr></table></figure><h2 id="配置文件"><a href="#配置文件" class="headerlink" title="配置文件"></a>配置文件</h2><p>创建 <code>bootstrap.yaml</code>配置文件，添加 Nacos Config 相关配置。配置如下：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-attr">spring:</span><br>  <span class="hljs-attr">application:</span><br>    <span class="hljs-attr">name:</span> <span class="hljs-string">demo-application</span><br><br>  <span class="hljs-attr">cloud:</span><br>    <span class="hljs-attr">nacos:</span><br>      <span class="hljs-comment"># Nacos Config 配置项，对应 NacosConfigProperties 配置属性类</span><br>      <span class="hljs-attr">config:</span><br>        <span class="hljs-attr">server-addr:</span> <span class="hljs-number">127.0</span><span class="hljs-number">.0</span><span class="hljs-number">.1</span><span class="hljs-string">:8848</span> <span class="hljs-comment"># Nacos 服务器地址</span><br>        <span class="hljs-attr">namespace:</span> <span class="hljs-comment"># 使用的 Nacos 的命名空间，默认为 null</span><br>        <span class="hljs-attr">group:</span> <span class="hljs-string">DEFAULT_GROUP</span> <span class="hljs-comment"># 使用的 Nacos 配置分组，默认为 DEFAULT_GROUP</span><br>        <span class="hljs-attr">name:</span> <span class="hljs-comment"># 使用的 Nacos 配置集的 dataId，默认为 spring.application.name</span><br>        <span class="hljs-attr">file-extension:</span> <span class="hljs-string">yaml</span> <span class="hljs-comment"># 使用的 Nacos 配置集的 dataId 的文件拓展名，同时也是 Nacos 配置集的配置格式，默认为 properties</span><br><br></code></pre></td></tr></table></figure><p>Nacos Config 配置项，以 <code>spring.cloud.nacos.config</code> 开头，对应 <a href="https://github.com/alibaba/spring-cloud-alibaba/blob/master/spring-cloud-alibaba-nacos-config/src/main/java/com/alibaba/cloud/nacos/NacosConfigProperties.java">NacosConfigProperties</a> 配置属性类。</p><ol><li><p><code>server-addr</code> 配置项，设置 Nacos 服务器地址。</p></li><li><p><code>namespace</code> 配置项，使用的 Nacos 的命名空间，默认为 <code>null</code>，表示使用 <code>public</code> 这个默认命名空间。</p></li></ol><blockquote><p>FROM <a href="https://nacos.io/zh-cn/docs/concepts.html">《Nacos 文档 —— Nacos 概念》</a></p><p><strong>命名空间</strong><br>用于进行租户粒度的配置隔离。不同的命名空间下，可以存在相同的 Group 或 Data ID 的配置。Namespace 的常用场景之一是不同环境的配置的区分隔离，例如开发测试环境和生产环境的资源（如配置、服务）隔离等。</p></blockquote><ol start="3"><li><code>group</code> 配置项，使用的 Nacos 配置分组，默认为 <code>DEFAULT_GROUP</code>。</li></ol><blockquote><p>FROM <a href="https://nacos.io/zh-cn/docs/concepts.html">《Nacos 文档 —— Nacos 概念》</a></p><p><strong>配置分组</strong><br>Nacos 中的一组配置集，是组织配置的维度之一。通过一个有意义的字符串（如 Buy 或 Trade ）对配置集进行分组，从而区分 Data ID 相同的配置集。当您在 Nacos 上创建一个配置时，如果未填写配置分组的名称，则配置分组的名称默认采用 <code>DEFAULT_GROUP</code> 。配置分组的常见场景：不同的应用或组件使用了相同的配置类型，如 <code>database_url</code> 配置和 <code>MQ_topic</code> 配置。</p></blockquote><ol start="4"><li><code>name</code> 配置项，使用的 Nacos 配置集的 dataId，默认为 <code>spring.application.name</code>。</li></ol><blockquote><p>FROM <a href="https://nacos.io/zh-cn/docs/concepts.html">《Nacos 文档 —— Nacos 概念》</a></p><p><strong>配置集</strong><br>一组相关或者不相关的配置项的集合称为配置集。在系统中，一个配置文件通常就是一个配置集，包含了系统各个方面的配置。例如，一个配置集可能包含了数据源、线程池、日志级别等配置项。</p><p><strong>配置集 ID</strong><br>Nacos 中的某个配置集的 ID。配置集 ID 是组织划分配置的维度之一。Data ID 通常用于组织划分系统的配置集。一个系统或者应用可以包含多个配置集，每个配置集都可以被一个有意义的名称标识。Data ID 通常采用类 Java 包（如 <code>com.taobao.tc.refund.log.level</code>）的命名规则保证全局唯一性。此命名规则非强制。</p></blockquote><p>因为这里我们未进行配置，所以使用 Nacos 配置集的 dataId 为 <code>demo-application</code>。这也是为什么我们将 <code>spring.application.name</code> 配置项添加到 <code>bootstrap.yaml</code> 配置文件中的原因。</p><ol start="5"><li><code>file-extension</code> 配置项，使用的 Nacos 配置集的 dataId 的<strong>文件拓展名</strong>，同时也是 Nacos 配置集的<strong>配置格式</strong>，默认为 <code>properties</code>。这里我们设置为 <code>yaml</code>，因为我们稍后使用的配置集的配置格式为 <code>YAML</code>。</li></ol><h3 id="bootstrap-yaml"><a href="#bootstrap-yaml" class="headerlink" title="bootstrap.yaml"></a>bootstrap.yaml</h3><blockquote><p>为什么要将 Nacos Config 的配置项添加到 <code>bootstrap.yaml</code> 配置文件，而不像我们之前的一样，添加到 <code>application.yaml</code> 配置文件中呢？</p><p>下面，我们来讲解下原因</p></blockquote><p>在 Spring Cloud 应用中，会先创建一个 <strong>Bootstrap</strong> Context（<strong>引导</strong>上下文），比 Spring Boot 创建 <strong>Application</strong> Context（<strong>应用</strong>上下文）<strong>更早初始化</strong>。</p><p>Bootstrap Context 新增了一个 <code>bootstrap.yaml</code> <strong>配置文件</strong>，保证和 Application Context 的 <code>application.yaml</code> <strong>配置文件</strong>的<strong>隔离</strong>。</p><p>有了配置文件的隔离之后，Bootstrap Context 初始化的 <strong>Bean</strong> 从哪里来？Spring Cloud 新定义了专属于 Bootstrap Context 的自动化配置类的拓展点 <strong>BootstrapConfiguration</strong>，和 Spring Boot 为 Application Context 的自动化配置类的拓展点 <strong>EnableAutoConfiguration</strong>的<strong>隔离</strong>，保证两个 Context 创建各自的 Bean。</p><p>虽然说，Bootstrap Context 和 Application Context 做了这么多隔离，但是它们有一点是共享的，那就是 <strong>Environment</strong>。在 Spring 中，我们通过 Environment 获取属性配置，例如说 <code>spring.application.name</code> 对应的值是多少。</p><p>了解完这些之后，我们把它们串联在一起去思考一下，Bootstrap Context 的<strong>目的</strong>究竟是什么呢？通过 Bootstrap Context 的优先初始化，<strong>将配置加载到 Environment 中</strong>，提供给后面的 Application Context 使用。</p><p>举个贼重要的例子，稍后我们会在 <code>bootstrap.yaml</code> 添加 Spring Cloud Alibaba Nacos Config 相关的配置，这样 Bootstrap Context 在初始化时，通过 NacosConfigBootstrapConfiguration 创建 Nacos 相关的 Bean，然后实现从 Nacos 配置中心加载配置到 Environment 中。</p><p>如果我们把 Spring Cloud Alibaba Nacos Config 相关的配置添加在 <code>application.yaml</code> 中，那么可能无法保证 Nacos 相关的 Bean 被<strong>最先</strong>初始化，完成从 Nacos 获取配置，从而影响创建的 Bean。</p><h2 id="创建-Nacos-配置集"><a href="#创建-Nacos-配置集" class="headerlink" title="创建 Nacos 配置集"></a>创建 Nacos 配置集</h2><p>打开 Nacos UI 界面的「配置列表」菜单，进入「配置管理」功能。如下图所示：</p><p><img src="/images/nacos/nacos-config-save.png"></p><h2 id="编写代码"><a href="#编写代码" class="headerlink" title="编写代码"></a>编写代码</h2><p>创建 OrderProperties配置类，读取 <code>order</code> 配置项。代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Component</span><br><span class="hljs-meta">@ConfigurationProperties(prefix = &quot;order&quot;)</span><br><span class="hljs-comment">// @NacosConfigurationProperties(prefix = &quot;order&quot;, dataId = &quot;$&#123;nacos.config.data-id&#125;&quot;, type = ConfigType.YAML)</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">OrderProperties</span> </span>&#123;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 订单支付超时时长，单位：秒。</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-keyword">private</span> Integer payTimeoutSeconds;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 订单创建频率，单位：秒</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-keyword">private</span> Integer createFrequencySeconds;<br><br>    <span class="hljs-comment">// ... 省略 setter/getter 方法</span><br><br>&#125;<br></code></pre></td></tr></table></figure><ul><li>在类上，添加 <code>@Component</code> 注解，保证该配置类可以作为一个 Bean 被扫描到。</li><li>在类上，添加 <code>@ConfigurationProperties</code> 注解，并设置 <code>prefix = &quot;order&quot;</code> 属性，这样它就可以读取<strong>前缀</strong>为 <code>order</code> 配置项，设置到配置类对应的属性上。</li></ul><p>创建 DemoController类，提供测试 <code>@ConfigurationProperties</code> 和 <code>@Value</code> 注入配置的两个 HTTP 接口。代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@RestController</span><br><span class="hljs-meta">@RequestMapping(&quot;/demo&quot;)</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">DemoController</span> </span>&#123;<br><br>    <span class="hljs-meta">@Autowired</span><br>    <span class="hljs-keyword">private</span> OrderProperties orderProperties;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 测试 <span class="hljs-doctag">@ConfigurationProperties</span> 注解的配置属性类</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-meta">@GetMapping(&quot;/test01&quot;)</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> OrderProperties <span class="hljs-title">test01</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> orderProperties;<br>    &#125;<br><br>    <span class="hljs-meta">@Value(value = &quot;$&#123;order.pay-timeout-seconds&#125;&quot;)</span> <span class="hljs-comment">// @NacosValue(value = &quot;$&#123;order.pay-timeout-seconds&#125;&quot;)</span><br>    <span class="hljs-keyword">private</span> Integer payTimeoutSeconds;<br>    <span class="hljs-meta">@Value(value = &quot;$&#123;order.create-frequency-seconds&#125;&quot;)</span> <span class="hljs-comment">// @NacosValue(value = &quot;$&#123;order.create-frequency-seconds&#125;&quot;)</span><br>    <span class="hljs-keyword">private</span> Integer createFrequencySeconds;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 测试 <span class="hljs-doctag">@Value</span> 注解的属性</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-meta">@GetMapping(&quot;/test02&quot;)</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> Map&lt;String, Object&gt; <span class="hljs-title">test02</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> JSONObject().fluentPut(<span class="hljs-string">&quot;payTimeoutSeconds&quot;</span>, payTimeoutSeconds)<br>                .fluentPut(<span class="hljs-string">&quot;createFrequencySeconds&quot;</span>, createFrequencySeconds);<br>    &#125;<br><br>&#125;<br></code></pre></td></tr></table></figure><h2 id="简单测试"><a href="#简单测试" class="headerlink" title="简单测试"></a>简单测试</h2><p>访问 <a href="http://127.0.0.1:8080/demo/test01">http://127.0.0.1:8080/demo/test01</a> 接口</p><p>访问 <a href="http://127.0.0.1:8080/demo/test02">http://127.0.0.1:8080/demo/test02</a> 接口</p><p>结果：</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs json">&#123;<br>    <span class="hljs-attr">&quot;payTimeoutSeconds&quot;</span>: <span class="hljs-number">60</span>,<br>    <span class="hljs-attr">&quot;createFrequencySeconds&quot;</span>: <span class="hljs-number">120</span><br>&#125;<br></code></pre></td></tr></table></figure><h1 id="自动刷新配置"><a href="#自动刷新配置" class="headerlink" title="自动刷新配置"></a>自动刷新配置</h1><ul><li>使用 <code>@ConfigurationProperties</code> 注解，使用 <code>@Value</code> 注解的<strong>不会</strong></li><li>使用 <code>@RefreshScope</code> 注解，</li></ul><h2 id="EnvironmentChangeEvent"><a href="#EnvironmentChangeEvent" class="headerlink" title="EnvironmentChangeEvent"></a>EnvironmentChangeEvent</h2><p>通过 <code>@ConfigurationProperties</code> 或者 <code>@Value</code> + <code>@RefreshScope</code> 注解，已经能够满足我们绝大多数场景下的自动刷新配置的功能。但是，在一些场景下，我们仍然需要<strong>实现对配置的监听，执行自定义的逻辑</strong>。</p><p>例如说，当数据库连接的配置发生变更时，我们需要通过监听该配置的变更，重新初始化应用中的数据库连接，从而访问到新的数据库地址。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Component</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">DemoEnvironmentChangeListener</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">ApplicationListener</span>&lt;<span class="hljs-title">EnvironmentChangeEvent</span>&gt; </span>&#123;<br><br>    <span class="hljs-keyword">private</span> Logger logger = LoggerFactory.getLogger(getClass());<br><br>    <span class="hljs-meta">@Autowired</span><br>    <span class="hljs-keyword">private</span> ConfigurableEnvironment environment;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">onApplicationEvent</span><span class="hljs-params">(EnvironmentChangeEvent event)</span> </span>&#123;<br>        <span class="hljs-keyword">for</span> (String key : event.getKeys()) &#123;<br>            logger.info(<span class="hljs-string">&quot;[onApplicationEvent][key(&#123;&#125;) 最新 value 为 &#123;&#125;]&quot;</span>, key, environment.getProperty(key));<br>        &#125;<br>    &#125;<br><br>&#125;<br></code></pre></td></tr></table></figure><h1 id="官方文档"><a href="#官方文档" class="headerlink" title="官方文档"></a>官方文档</h1><ul><li><a href="https://nacos.io/zh-cn/docs/what-is-nacos.html">《Nacos 官方文档》</a></li><li><a href="https://github.com/alibaba/spring-cloud-alibaba/wiki/Nacos-config">《Spring Cloud Alibaba 官方<strong>文档</strong> —— Nacos Config》</a></li><li><a href="https://github.com/alibaba/spring-cloud-alibaba/blob/master/spring-cloud-alibaba-examples/nacos-example/nacos-config-example/readme-zh.md">《Spring Cloud Alibaba 官方<strong>示例</strong> —— Nacos Config》</a></li></ul>]]></content>
    
    
    
    <tags>
      
      <tag>Nacos</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Nacos数据模型</title>
    <link href="/2021/07/27/nacos-data-model/"/>
    <url>/2021/07/27/nacos-data-model/</url>
    
    <content type="html"><![CDATA[<h2 id="数据模型"><a href="#数据模型" class="headerlink" title="数据模型"></a>数据模型</h2><p>Nacos 数据模型 Key 由三元组唯一确认。如下图所示：</p><p><img src="/images/nacos/nacos-data-model.jpeg" alt="点击"></p><ul><li>作为注册中心时，Namespace + Group + Service</li><li>作为配置中心时，Namespace + Group + DataId</li></ul><h2 id="Namespace-命名空间"><a href="#Namespace-命名空间" class="headerlink" title="Namespace 命名空间"></a>Namespace 命名空间</h2><p>用于进行租户粒度的配置隔离。默认为 public（公共命名空间）。</p><p>不同的命名空间下，可以存在相同的 Group 或 Data ID 的配置。Namespace 的常用场景之一是不同环境的配置的区分隔离，例如开发测试环境和生产环境的资源（如配置、服务）隔离等。</p><h2 id="Group-服务分组"><a href="#Group-服务分组" class="headerlink" title="Group 服务分组"></a>Group 服务分组</h2><p>不同的服务可以归类到同一分组。默认为 DEFAULT_GROUP（默认分组）。</p><h2 id="Service-服务"><a href="#Service-服务" class="headerlink" title="Service 服务"></a>Service 服务</h2><p>例如说，用户服务、订单服务、商品服务等等。</p><h2 id="官方文档"><a href="#官方文档" class="headerlink" title="官方文档"></a>官方文档</h2><ul><li><a href="https://nacos.io/zh-cn/docs/what-is-nacos.html">《Nacos 官方文档 —— 概念》</a></li><li><a href="https://nacos.io/zh-cn/docs/architecture.html">《Nacos 官方文档 —— 架构》</a></li></ul>]]></content>
    
    
    
    <tags>
      
      <tag>Nacos</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Nacos注册中心</title>
    <link href="/2021/07/27/nacos-discovery/"/>
    <url>/2021/07/27/nacos-discovery/</url>
    
    <content type="html"><![CDATA[<h3 id="服务发现和服务健康监测"><a href="#服务发现和服务健康监测" class="headerlink" title="服务发现和服务健康监测"></a><strong>服务发现和服务健康监测</strong></h3><p>Nacos 支持基于 DNS 和基于 RPC 的服务发现。服务提供者使用 <a href="https://nacos.io/zh-cn/docs/sdk.html">原生SDK</a>、<a href="https://nacos.io/zh-cn/docs/open-api.html">OpenAPI</a>、或一个<a href="https://nacos.io/zh-cn/docs/other-language.html">独立的Agent TODO</a>注册 Service 后，服务消费者可以使用<a href="https://nacos.io/zh-cn/docs/xx">DNS TODO</a> 或<a href="https://nacos.io/zh-cn/docs/open-api.html">HTTP&amp;API</a>查找和发现服务。</p><p>Nacos 提供对服务的实时的健康检查，阻止向不健康的主机或服务实例发送请求。Nacos 支持传输层 (PING 或 TCP)和应用层 (如 HTTP、MySQL、用户自定义）的健康检查。 对于复杂的云环境和网络拓扑环境中（如 VPC、边缘网络等）服务的健康检查，Nacos 提供了 agent 上报模式和服务端主动检测2种健康检查模式。Nacos 还提供了统一的健康检查仪表盘，帮助您根据健康状态管理服务的可用性及流量。</p><h3 id="注册中心原理"><a href="#注册中心原理" class="headerlink" title="注册中心原理"></a>注册中心原理</h3><p>在使用注册中心时，一共有三种角色：服务提供者（Service Provider）、服务消费者（Service Consumer）、注册中心（Registry）。</p><p><img src="/images/nacos/nacos-dis.png" alt="点击"></p><ol><li>Provider：</li></ol><ul><li>启动时，向 Registry <strong>注册</strong>自己为一个服务（Service）的实例（Instance）。</li><li>同时，定期向 Registry 发送<strong>心跳</strong>，告诉自己还存活。</li><li>关闭时，向 Registry <strong>取消注册</strong>。</li></ul><ol start="2"><li>Consumer：</li></ol><ul><li>启动时，向 Registry <strong>订阅</strong>使用到的服务，并缓存服务的实例列表在内存中。</li><li>后续，Consumer 向对应服务的 Provider 发起<strong>调用</strong>时，从内存中的该服务的实例列表选择一个，进行远程调用。</li><li>关闭时，向 Registry <strong>取消订阅</strong>。</li></ul><ol start="3"><li>Registry：</li></ol><ul><li>Provider 超过一定时间未<strong>心跳</strong>时，从服务的实例列表移除。</li><li>服务的实例列表发生变化（新增或者移除）时，通知订阅该服务的 Consumer，从而让 Consumer 能够刷新本地缓存。</li></ul><p>当然，不同的注册中心可能在实现原理上会略有差异。例如说，<a href="https://github.com/Netflix/eureka/">Eureka</a> 注册中心，并不提供通知功能，而是 Eureka Client 自己定期轮询，实现本地缓存的更新。</p><p>另外，Provider 和 Consumer 是角色上的定义，一个服务<strong>同时</strong>即可以是 Provider 也可以作为 Consumer。例如说，优惠劵服务可以给订单服务提供接口，同时又调用用户服务提供的接口。</p><h3 id="快速开始"><a href="#快速开始" class="headerlink" title="快速开始"></a>快速开始</h3><h4 id="引入依赖"><a href="#引入依赖" class="headerlink" title="引入依赖"></a>引入依赖</h4><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>com.alibaba.cloud<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-cloud-alibaba-dependencies<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>$&#123;spring.cloud.alibaba.version&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">type</span>&gt;</span>pom<span class="hljs-tag">&lt;/<span class="hljs-name">type</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">scope</span>&gt;</span>import<span class="hljs-tag">&lt;/<span class="hljs-name">scope</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>com.alibaba.cloud<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-cloud-starter-alibaba-nacos-discovery<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br></code></pre></td></tr></table></figure><h4 id="生产者"><a href="#生产者" class="headerlink" title="生产者"></a>生产者</h4><p>配置文件</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-attr">spring:</span><br>  <span class="hljs-attr">application:</span><br>    <span class="hljs-attr">name:</span> <span class="hljs-string">demo-provider</span> <span class="hljs-comment"># Spring 应用名</span><br>  <span class="hljs-attr">cloud:</span><br>    <span class="hljs-attr">nacos:</span><br>      <span class="hljs-comment"># Nacos 作为注册中心的配置项，对应 NacosDiscoveryProperties 配置类</span><br>      <span class="hljs-attr">discovery:</span><br>        <span class="hljs-attr">server-addr:</span> <span class="hljs-number">127.0</span><span class="hljs-number">.0</span><span class="hljs-number">.1</span><span class="hljs-string">:8848</span> <span class="hljs-comment"># Nacos 服务器地址</span><br>        <span class="hljs-attr">service:</span> <span class="hljs-string">$&#123;spring.application.name&#125;</span> <span class="hljs-comment"># 注册到 Nacos 的服务名。默认值为 $&#123;spring.application.name&#125;。</span><br><br><span class="hljs-attr">server:</span><br>  <span class="hljs-attr">port:</span> <span class="hljs-number">18080</span> <span class="hljs-comment"># 服务器端口。默认为 8080</span><br></code></pre></td></tr></table></figure><p>重点看 <code>spring.cloud.nacos.discovery</code> 配置项，它是 Nacos Discovery 配置项的前缀，对应 <a href="https://github.com/alibaba/spring-cloud-alibaba/blob/master/spring-cloud-alibaba-nacos-discovery/src/main/java/com/alibaba/cloud/nacos/NacosDiscoveryProperties.java">NacosDiscoveryProperties</a> 配置项。</p><p>创建 DemoProviderApplication 类，创建应用启动类，并提供 HTTP 接口。代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@SpringBootApplication</span><br><span class="hljs-meta">@EnableDiscoveryClient</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">DemoProviderApplication</span> </span>&#123;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>        SpringApplication.run(DemoProviderApplication.class, args);<br>    &#125;<br><br>    <span class="hljs-meta">@RestController</span><br>    <span class="hljs-keyword">static</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">TestController</span> </span>&#123;<br><br>        <span class="hljs-meta">@GetMapping(&quot;/echo&quot;)</span><br>        <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">echo</span><span class="hljs-params">(String name)</span> </span>&#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;provider:&quot;</span> + name;<br>        &#125;<br><br>    &#125;<br><br>&#125;<br></code></pre></td></tr></table></figure><ol><li><p><code>@SpringBootApplication</code> 注解，被添加在类上，声明这是一个 Spring Boot 应用。Spring Cloud 是构建在 Spring Boot 之上的，所以需要添加。</p></li><li><p><a href="https://github.com/spring-cloud/spring-cloud-commons/blob/master/spring-cloud-commons/src/main/java/org/springframework/cloud/client/discovery/EnableDiscoveryClient.java"><code>@EnableDiscoveryClient</code></a> 注解，开启 Spring Cloud 的注册发现功能。不过从 Spring Cloud Edgware 版本开始，实际上已经不需要添加 <code>@EnableDiscoveryClient</code> 注解，只需要引入 Spring Cloud 注册发现组件，就会自动开启注册发现的功能。例如说，我们这里已经引入了 <code>spring-cloud-starter-alibaba-nacos-discovery</code> 依赖，就不用再添加 <code>@EnableDiscoveryClient</code> 注解了。</p></li></ol><h4 id="消费者"><a href="#消费者" class="headerlink" title="消费者"></a>消费者</h4><p>配置文件</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-attr">spring:</span><br>  <span class="hljs-attr">application:</span><br>    <span class="hljs-attr">name:</span> <span class="hljs-string">demo-provider</span> <span class="hljs-comment"># Spring 应用名</span><br>  <span class="hljs-attr">cloud:</span><br>    <span class="hljs-attr">nacos:</span><br>      <span class="hljs-comment"># Nacos 作为注册中心的配置项，对应 NacosDiscoveryProperties 配置类</span><br>      <span class="hljs-attr">discovery:</span><br>        <span class="hljs-attr">server-addr:</span> <span class="hljs-number">127.0</span><span class="hljs-number">.0</span><span class="hljs-number">.1</span><span class="hljs-string">:8848</span> <span class="hljs-comment"># Nacos 服务器地址</span><br>        <span class="hljs-attr">service:</span> <span class="hljs-string">$&#123;spring.application.name&#125;</span> <span class="hljs-comment"># 注册到 Nacos 的服务名。默认值为 $&#123;spring.application.name&#125;。</span><br><br><span class="hljs-attr">server:</span><br>  <span class="hljs-attr">port:</span> <span class="hljs-number">28080</span> <span class="hljs-comment"># 服务器端口。默认为 8080</span><br></code></pre></td></tr></table></figure><p>创建 DemoConsumerApplication类，创建应用启动类，并提供一个调用服务提供者的 HTTP 接口。代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@SpringBootApplication</span><br><span class="hljs-comment">// @EnableDiscoveryClient</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">DemoConsumerApplication</span> </span>&#123;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>        SpringApplication.run(DemoConsumerApplication.class, args);<br>    &#125;<br><br>    <span class="hljs-meta">@Configuration</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">RestTemplateConfiguration</span> </span>&#123;<br><br>        <span class="hljs-meta">@Bean</span><br>        <span class="hljs-function"><span class="hljs-keyword">public</span> RestTemplate <span class="hljs-title">restTemplate</span><span class="hljs-params">()</span> </span>&#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> RestTemplate();<br>        &#125;<br><br>    &#125;<br><br>    <span class="hljs-meta">@RestController</span><br>    <span class="hljs-keyword">static</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">TestController</span> </span>&#123;<br><br>        <span class="hljs-meta">@Autowired</span><br>        <span class="hljs-keyword">private</span> DiscoveryClient discoveryClient;<br>        <span class="hljs-meta">@Autowired</span><br>        <span class="hljs-keyword">private</span> RestTemplate restTemplate;<br>        <span class="hljs-meta">@Autowired</span><br>        <span class="hljs-keyword">private</span> LoadBalancerClient loadBalancerClient;<br><br>        <span class="hljs-meta">@GetMapping(&quot;/hello&quot;)</span><br>        <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">hello</span><span class="hljs-params">(String name)</span> </span>&#123;<br>            <span class="hljs-comment">// &lt;1&gt; 获得服务 `demo-provider` 的一个实例</span><br>            ServiceInstance instance;<br>            <span class="hljs-keyword">if</span> (<span class="hljs-keyword">true</span>) &#123;<br>                <span class="hljs-comment">// 获取服务 `demo-provider` 对应的实例列表</span><br>                List&lt;ServiceInstance&gt; instances = discoveryClient.getInstances(<span class="hljs-string">&quot;demo-provider&quot;</span>);<br>                <span class="hljs-comment">// 选择第一个</span><br>                instance = instances.size() &gt; <span class="hljs-number">0</span> ? instances.get(<span class="hljs-number">0</span>) : <span class="hljs-keyword">null</span>;<br>            &#125; <span class="hljs-keyword">else</span> &#123;<br>                instance = loadBalancerClient.choose(<span class="hljs-string">&quot;demo-provider&quot;</span>);<br>            &#125;<br>            <span class="hljs-comment">// &lt;2&gt; 发起调用</span><br>            <span class="hljs-keyword">if</span> (instance == <span class="hljs-keyword">null</span>) &#123;<br>                <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> IllegalStateException(<span class="hljs-string">&quot;获取不到实例&quot;</span>);<br>            &#125;<br>            String targetUrl = instance.getUri() + <span class="hljs-string">&quot;/echo?name=&quot;</span> + name;<br>            String response = restTemplate.getForObject(targetUrl, String.class);<br>            <span class="hljs-comment">// 返回结果</span><br>            <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;consumer:&quot;</span> + response;<br>        &#125;<br><br>    &#125;<br><br>&#125;<br></code></pre></td></tr></table></figure><ol><li><p><code>@EnableDiscoveryClient</code> 注解，因为已经无需添加，所以我们进行了注释，原因在上面已经解释过。</p></li><li><p>RestTemplateConfiguration 配置类，创建 <a href="https://github.com/spring-projects/spring-framework/blob/master/spring-web/src/main/java/org/springframework/web/client/RestTemplate.java">RestTemplate</a> Bean。RestTemplate 是 Spring 提供的 HTTP 调用模板工具类，可以方便我们稍后调用服务提供者的 HTTP API。</p></li><li><p>TestController 提供了 <code>/hello</code> 接口，用于调用服务提供者的 <code>/demo</code> 接口。代码略微有几行，我们来稍微解释下哈。</p></li></ol><p><code>discoveryClient</code> 属性，DiscoveryClient 对象，服务发现客户端，上文我们已经介绍过。这里我们注入的不是 Nacos Discovery 提供的 NacosDiscoveryClient，保证通用性。未来如果我们不使用 Nacos 作为注册中心，而是使用 Eureka 或则 Zookeeper 时，则无需改动这里的代码。</p><p><code>loadBalancerClient</code> 属性，<a href="https://github.com/spring-cloud/spring-cloud-commons/blob/master/spring-cloud-commons/src/main/java/org/springframework/cloud/client/loadbalancer/LoadBalancerClient.java">LoadBalancerClient</a> 对象，负载均衡客户端。稍后我们会使用它，从 Nacos 获取的服务 <code>demo-provider</code> 的实例列表中，选择一个进行 HTTP 调用。</p><blockquote><p>拓展小知识：在 Spring Cloud Common 项目中，定义了<a href="https://github.com/spring-cloud/spring-cloud-commons/blob/master/spring-cloud-commons/src/main/java/org/springframework/cloud/client/loadbalancer/LoadBalancerClient.java">LoadBalancerClient</a> 接口，作为通用的负载均衡客户端，提供从指定服务中选择一个实例、对指定服务发起请求等 API 方法。而想要集成到 Spring Cloud 体系的负载均衡的组件，需要提供对应的 LoadBalancerClient 实现类。</p><p>例如说，Spring Cloud Netflix Ribbon 提供了 <a href="https://github.com/spring-cloud/spring-cloud-netflix/blob/2.2.x/spring-cloud-netflix-ribbon/src/main/java/org/springframework/cloud/netflix/ribbon/RibbonLoadBalancerClient.java">RibbonLoadBalancerClient</a> 实现。</p><p>如此，所有需要使用到的地方，只需要获取到 DiscoveryClient 客户端，而无需关注具体实现，保证其通用性。😈 不过貌似 Spring Cloud 体系中，暂时只有 Ribbon 一个负载均衡组件。</p><p>当然，LoadBalancerClient 的服务的实例列表，是来自 DiscoveryClient 提供的。</p></blockquote><p><code>/hello</code> 接口，示例接口，对服务提供者发起一次 HTTP 调用。</p><ul><li><code>&lt;1&gt;</code> 处，获得服务 <code>demo-provider</code> 的一个实例。这里我们提供了两种方式的代码，分别基于 DiscoveryClient 和 LoadBalancerClient。</li><li><code>&lt;2&gt;</code> 处，通过获取到的服务实例 ServiceInstance 对象，拼接请求的目标 URL，之后使用 RestTemplate 发起 HTTP 调用。</li></ul><h4 id="测试"><a href="#测试" class="headerlink" title="测试"></a>测试</h4><p>访问：<a href="http://127.0.0.1:28080/hello?name=mengsu">http://127.0.0.1:28080/hello?name=mengsu</a> ，返回结果为 <code>&quot;consumer:provider:mengsu&quot;</code>。说明，调用远程的<strong>服务提供者</strong>成功。</p>]]></content>
    
    
    
    <tags>
      
      <tag>Nacos</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Typora快捷键</title>
    <link href="/2021/07/26/Typora%E5%BF%AB%E6%8D%B7%E9%94%AE/"/>
    <url>/2021/07/26/Typora%E5%BF%AB%E6%8D%B7%E9%94%AE/</url>
    
    <content type="html"><![CDATA[<h1 id="Typora快捷键"><a href="#Typora快捷键" class="headerlink" title="Typora快捷键"></a>Typora快捷键</h1><p>最大标题：command + 1 或者：#<br> 大标题：command + 2 或者：##<br> 标准标题：command + 3 或者：###<br> 中标题：command + 4 或者：####<br> 小标题：command + 5 或者：#####<br> 插入表格：command + T<br> 插入代码：command + alt +c<br> 插入图片：cmd + ctrl + i<br> 行间公式 command + Alt + b<br> 段落：command + 0<br> 竖线 ： command + Alt +q<br> 无需列表：command+option+U<br> 有序列表（1. 2.） ：输入数字+“.”之后输 入空格 或者：command + Alt + o<br> 黑点标记：command + Alt + u<br> 隔离线shift + command + -<br> 超链接：command + Alt + l<br> 插入链接：command +k<br> 下划线：command +u<br> 加粗：command +b<br> 搜索：command +f<br> 引用：command+option+Q</p>]]></content>
    
    
    
    <tags>
      
      <tag>Typora</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Nacos安装运行</title>
    <link href="/2021/07/26/nacos-install/"/>
    <url>/2021/07/26/nacos-install/</url>
    
    <content type="html"><![CDATA[<h2 id="快速开始"><a href="#快速开始" class="headerlink" title="快速开始"></a><a href="https://nacos.io/zh-cn/">快速开始</a></h2><h3 id="Docker下载安装"><a href="#Docker下载安装" class="headerlink" title="Docker下载安装"></a>Docker下载安装</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">docker pull nacos/nacos-server<br></code></pre></td></tr></table></figure><h3 id="Docker查看镜像"><a href="#Docker查看镜像" class="headerlink" title="Docker查看镜像"></a>Docker查看镜像</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">docker images<br></code></pre></td></tr></table></figure><h3 id="Docker运行"><a href="#Docker运行" class="headerlink" title="Docker运行"></a>Docker运行</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs bash">docker run -d \<br>-e MODE=standalone \<br>-e SPRING_DATASOURCE_PLATFORM=mysql \<br>-e MYSQL_SERVICE_HOST=docker.for.mac.host.internal \<br>-e MYSQL_SERVICE_PORT=3306 \<br>-e MYSQL_SERVICE_USER=root \<br>-e MYSQL_SERVICE_PASSWORD=123456 \<br>-e MYSQL_SERVICE_DB_NAME=nacos_config \<br>-p 8848:8848 \<br>--restart=always \<br>nacos/nacos-server<br></code></pre></td></tr></table></figure><p>备注：连接数据库需要导入nacos自己的<a href="https://github.com/alibaba/nacos/edit/master/distribution/conf/nacos-mysql.sql">数据库脚本</a>，该模式为单机启动</p><h3 id="Docker查看运行状态"><a href="#Docker查看运行状态" class="headerlink" title="Docker查看运行状态"></a>Docker查看运行状态</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">docker ps<br></code></pre></td></tr></table></figure><h3 id="访问地址"><a href="#访问地址" class="headerlink" title="访问地址"></a>访问地址</h3><p><a href="http://127.0.0.1:8848/">http://127.0.0.1:8848/</a>  ，默认账密都是：nacos</p><h3 id="系统截图"><a href="#系统截图" class="headerlink" title="系统截图"></a>系统截图</h3><p><img src="/images/nacos/nacos-show.png" alt="点击"></p>]]></content>
    
    
    
    <tags>
      
      <tag>Nacos</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Hexo</title>
    <link href="/2021/07/23/hello-world/"/>
    <url>/2021/07/23/hello-world/</url>
    
    <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ hexo new <span class="hljs-string">&quot;My New Post&quot;</span><br></code></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ hexo server<br></code></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ hexo generate<br></code></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ hexo deploy<br></code></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>]]></content>
    
    
    
  </entry>
  
  
  
  
</search>
