<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>java基础(01)</title>
    <link href="/2021/12/16/java/java-base-1/"/>
    <url>/2021/12/16/java/java-base-1/</url>
    
    <content type="html"><![CDATA[<h1 id="数据类型和变量"><a href="#数据类型和变量" class="headerlink" title="数据类型和变量"></a>数据类型和变量</h1><p>数据类型用于对数据归类，以便于理解和操作。对Java语言而言，有如下基本数据类型。</p><ul><li>整数类型：有4种整型byte/short/int/long,分别有不同的取值范围；</li><li>小数类型：有两种类型Hoat/doublc,有不同的取值范围和精度；</li><li>字符类型：char,表示单个字符；</li><li>真假类型：boolean，表示真假。</li></ul><p>为了操作数据，需要把数据存放到内存中。所谓内存在程序看来就是一块有地址编号的连续的空 间，数据放到内存中的某个位置后，为了方便地找到和操作这个数据，需要给这个位置起一个名字。编程 语言通过<strong>变量</strong>这个概念来表示这个过程。</p><p><strong>变量就是给数据起名字，方便找不同的数据，它的值可以变，但含义不应变。</strong></p><h2 id="基本数据类型"><a href="#基本数据类型" class="headerlink" title="基本数据类型"></a>基本数据类型</h2><h3 id="整数类型"><a href="#整数类型" class="headerlink" title="整数类型"></a>整数类型</h3><p>整数类型有byte、short、int和long,分别占1、2、4、8个字节</p><p><img src="http://oss.mengsu.site/image-20211216225240791.png" alt="image-20211216225240791"></p><p>赋值操作很简单，只需要把对应的值赋给定义的<strong>变量</strong>即可，但是要注意赋值的范围不能超出变量类型的最大取值范围。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">byte</span> b = <span class="hljs-number">23</span>; <br><span class="hljs-keyword">short</span> s = <span class="hljs-number">3333</span>; <br><span class="hljs-keyword">int</span> i = <span class="hljs-number">9999</span>;<br><span class="hljs-keyword">long</span> <span class="hljs-number">1</span> = <span class="hljs-number">32323</span>;<br><span class="hljs-comment">// 但是，在给long类型赋值时，如果常量超过了int的表示范围，需要在常量后面加大写或小写字母L, 即L或1</span><br><span class="hljs-keyword">long</span> a = <span class="hljs-number">3232343433L</span>;<br></code></pre></td></tr></table></figure><h3 id="小数类型"><a href="#小数类型" class="headerlink" title="小数类型"></a>小数类型</h3><p>小数类型有float和double,占用的内存空间分别是4和8字节，有不同的取值范围和精度，double表示 的范围更大，精度更高，E表示以10为底的指数，E后 面的+号和-号代表正指数和负指数，例如：1.4E-45表示1.4乘以10的-45次方。</p><p><img src="http://oss.mengsu.site/image-20211216230055879.png" alt="image-20211216230055879"></p><p>赋值操作</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">double</span> d = <span class="hljs-number">333.33</span>;<br><span class="hljs-comment">// 但对于float,需要在数字后面加大写字母F或小写字母f</span><br><span class="hljs-keyword">float</span> f = <span class="hljs-number">333.33f</span>;<br></code></pre></td></tr></table></figure><h3 id="真假类型"><a href="#真假类型" class="headerlink" title="真假类型"></a>真假类型</h3><p>真假(<strong>boolean</strong>)类型很简单，直接使用true或false赋值，分别表示真和假</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">boolean</span> b = <span class="hljs-keyword">true</span>; b = <span class="hljs-keyword">false</span>;<br></code></pre></td></tr></table></figure><h3 id="字符类型"><a href="#字符类型" class="headerlink" title="字符类型"></a>字符类型</h3><p>字符类型char用于表示一个字符，这个字符可以是中文字符，也可以是英文字符，char占用的内存空 间是两个字节。赋值时把常,字符用单引号括起来，不要使用双引号</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">char</span> c = <span class="hljs-string">&#x27;c&#x27;</span>;<br></code></pre></td></tr></table></figure><p>前面介绍的赋值都是在声明变量的时候就进行了赋值，但这不是必需的，可以先声明变量，随后再 进行赋值。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">int</span> a = <span class="hljs-number">1</span>;<br><span class="hljs-keyword">int</span> b = <span class="hljs-number">2</span>;<br><span class="hljs-comment">//2乘以a的值再加上b的值赋给c</span><br><span class="hljs-keyword">int</span> c = <span class="hljs-number">2</span> * t + b;<br></code></pre></td></tr></table></figure><h2 id="数组类型"><a href="#数组类型" class="headerlink" title="数组类型"></a>数组类型</h2><p>基本类型的数组有3种赋值形式</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">int</span>[] arr = &#123;<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>&#125;;<br><span class="hljs-keyword">int</span>[] arr = <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[]&#123;<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>&#125;;<br><span class="hljs-keyword">int</span>[] arr = <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[<span class="hljs-number">3</span>];<br>arr[<span class="hljs-number">0</span>]=<span class="hljs-number">1</span>; arr[<span class="hljs-number">1</span>]=<span class="hljs-number">2</span>; arr[<span class="hljs-number">2</span>]=<span class="hljs-number">3</span>;<br></code></pre></td></tr></table></figure><p>数组的长度可以动态设置，但是长度一旦设置成功是不可以<strong>更改</strong>的，但只能读，不能改。</p><p><img src="http://oss.mengsu.site/image-20211216231353239.png" alt="image-20211216231353239"></p><h3 id="数组和基本类型的区别"><a href="#数组和基本类型的区别" class="headerlink" title="数组和基本类型的区别"></a><strong>数组和基本类型的区别</strong></h3><p>一个基本类型变量，内存中只会有一块对应的内存空间。但数组有两块，一块用于存储数组内容本身，另一块用于存储内容的位置。用一个例子来说明，有一个int变量a，和一个int数组变量arr</p><p><img src="http://oss.mengsu.site/image-20211216232517756.png" alt="image-20211216232517756"></p><h3 id="为什么数组要用两块空间"><a href="#为什么数组要用两块空间" class="headerlink" title="为什么数组要用两块空间"></a><strong>为什么数组要用两块空间</strong></h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">int</span>[] arrA = &#123;<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>&#125;;<br><br><span class="hljs-keyword">int</span>[] arrB = &#123;<span class="hljs-number">4</span>,<span class="hljs-number">5</span>,<span class="hljs-number">6</span>,<span class="hljs-number">7</span>&#125;;<br>arrA = arrB;<br></code></pre></td></tr></table></figure><p>这个代码中，arrA初始的长度是3，arrB的长度是4，后来将arrB的值赋给了arrA。如果arrA对应的内存空间是直接存储的数组内容，那么它将没有足够的空间去容纳arrB的所有元素。</p><p>用两块空间存储，这个就简单的多，arrA存储的值就变成了和arrB的一样，存储的都是数组内容{4,5,6,7}的地址，此后访问arrA就和arrB是一样的了，而arrA {1,2,3}的内存空间由于无人引用会被<strong>垃圾回收</strong></p><p>由上，也可以看出，给<strong>数组变量赋值</strong>和给<strong>数组中元素赋值</strong>是两回事。给数组中元素赋值是<strong>改变数组内容</strong>，而给数组变量赋值则会让变量<strong>指向一个不同的位置</strong>。</p><p><img src="http://oss.mengsu.site/image-20211216232936531.png" alt="image-20211216232936531"></p><h2 id="运算"><a href="#运算" class="headerlink" title="运算"></a><strong>运算</strong></h2><p>给数据赋值，有了初始值之后，可以对数据进行运算。计算机之所以称为”计算”机，是因为发明它的主要目的就是运算。运算有不同的类型，不同的数据类型支持的运算也不一样，本文介绍Java中基本类型数据的主要运算。</p><ul><li>算术运算：主要是日常的加减乘除</li><li>比较运算：主要是日常的大小比较</li><li>逻辑运算：针对布尔值进行运算</li></ul><h3 id="加减乘除注意事项"><a href="#加减乘除注意事项" class="headerlink" title="加减乘除注意事项"></a><strong>加减乘除注意事项</strong></h3><p>运算时要注意结果的范围，使用恰当的数据类型。两个正数都可以用int表示，但相乘的结果可能就会超，超出后结果会令人困惑，例如：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">int</span> a = <span class="hljs-number">2147483647</span>*<span class="hljs-number">2</span>; <span class="hljs-comment">//2147483647是int能表示的最大值</span><br><span class="hljs-comment">// a = -2 超出int最大范围，具体 -2 在后面详解</span><br></code></pre></td></tr></table></figure><p>需采用long的形式作为运行变量的接受变量，只改为long也是不够的，因为运算还是默认按照int类型进行，需要将至少一个数据表示为long形式，即在后面加L或l：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">long</span> a = <span class="hljs-number">2147483647</span>*<span class="hljs-number">2L</span>;<br></code></pre></td></tr></table></figure><p>整数相除不是四舍五入，而是直接舍去小数位，例如：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">double</span> d = <span class="hljs-number">10</span>/<span class="hljs-number">4</span>;<br></code></pre></td></tr></table></figure><p>结果是2而不是2.5，如果要按小数进行运算，需要将至少一个数表示为小数形式，或者使用强制类型转化，即在数字前面加(double)，表示将数字看做double类型，如下所示任意一种形式都可以：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">double</span> d = <span class="hljs-number">10</span>/<span class="hljs-number">4.0</span>;<br><span class="hljs-keyword">double</span> d = <span class="hljs-number">10</span>/(<span class="hljs-keyword">double</span>)<span class="hljs-number">4</span>;<br></code></pre></td></tr></table></figure><h3 id="自增-自减-–"><a href="#自增-自减-–" class="headerlink" title="自增(++)/自减(–)"></a><strong>自增(++)/自减(–)</strong></h3><p>自增/自减是对自己做加一和减一操作，但每个都有两种形式，一种是放在变量后，例如a++, a–，另一种是放在变量前，例如++a, –a。</p><p>区别在于还有其他操作的时候。放在变量后(a++)，是先用原来的值进行其他操作，然后再对自己做修改，而放在变量前(++a)，是先对自己做修改，再用修改后的值进行其他操作。</p><p><img src="http://oss.mengsu.site/image-20211216234502389.png" alt="image-20211216234502389"></p><h3 id="比较运算"><a href="#比较运算" class="headerlink" title="比较运算"></a><strong>比较运算</strong></h3><p>比较运算就是计算两个值之间的关系，结果是一个布尔类型(boolean)的值。</p><p>比较操作符有：大于(&gt;)，大于等于(&gt;=)，小于(&lt;)，小于等于(&lt;=)，等于(==)，不等于(!=)。</p><p>首先，它使用两个等号==，而不是一个等号(=)，为什么不用一个等号呢？因为一个等号(=)已经被占了，表示赋值操作。</p><p>另外，对于数组，==对于 <strong>基本数据类型</strong> 比较的是值，但是对于 <strong>对象类型</strong> 比较的是内存地址，在后续说明。</p><h3 id="逻辑运算"><a href="#逻辑运算" class="headerlink" title="逻辑运算"></a><strong>逻辑运算</strong></h3><p>逻辑运算根据数据的逻辑关系，生成一个布尔值true或者false。逻辑运算只可应用于boolean类型的数据，但比较运算的结果是布尔值，所以其他类型数据的比较结果可进行逻辑运算。</p><p>逻辑运算符具体有：</p><ul><li><p>与(&amp;)：两个都为true才是true，只要有一个是false就是false</p></li><li><p>或(|)：只要有一个为true就是true，都是false才是false</p></li><li><p>非(!)：针对一个变量，true会变成false, false会变成true</p></li><li><p>异或(^)：两个相同为false, 两个不相同为true</p></li><li><p>短路与(&amp;&amp;): 和&amp;类似，不同之处马上解释</p></li><li><p>短路或 (||)：与|类似，不同之处马上解释</p></li></ul><h3 id="运算符优先级"><a href="#运算符优先级" class="headerlink" title="运算符优先级"></a><strong>运算符优先级</strong></h3><p>一个稍微复杂的运算可能会涉及多个变量，和多种运算，那哪个先算，哪个后算呢？程序语言规定了不同运算符的优先级，有的会先算，有的会后算，大部分情况下，这个优先级与我们的常识理解是相符的。</p><p>但在一些复杂情况下，我们可能会搞不明白其运算顺序。但这个我们不用太操心，可以使用括号()来表达我们想要的顺序，括号里的会先进行运算，简单的说，不确定顺序的时候，就使用括号。</p><h2 id="整数的二进制表示与位运算"><a href="#整数的二进制表示与位运算" class="headerlink" title="整数的二进制表示与位运算"></a>整数的二进制表示与位运算</h2><h3 id="十进制"><a href="#十进制" class="headerlink" title="十进制"></a><strong>十进制</strong></h3><p>比如123，表示的1*(10^2) + 2*(10^1) + 3*(10^0)，从右向左，第一位乘以10的0次方， 即1，第二位乘以10的1次方，即10，第三位乘以10的2次方，即100，依次类推。换句话说，每个位置都有一个位权，从右到左，第一位为1，然后依次乘以10，即第二位为10，第三位为100，依次类推。<strong>十进制就是正整数</strong></p><h3 id="正整数转成二进制"><a href="#正整数转成二进制" class="headerlink" title="正整数转成二进制"></a>正整数转成二进制</h3><p>要点一定一定要记住哈：除二取余，然后倒序排列，高位补零。</p><p><img src="http://oss.mengsu.site/image-20211218000345272.png" alt="image-20211218000345272"></p><p>83除以2得到的余数分别为1100101，然后咱们倒着排一下，83所对应二进制就是1010011</p><h3 id="负整数转二进制"><a href="#负整数转二进制" class="headerlink" title="负整数转二进制"></a>负整数转二进制</h3><p>对于正整数二进制取反+1，高位补0，整数有四种类型，byte/short/int/long，分别占1/2/4/8个字节，即分别占8/16/32/64位</p><ul><li>-1：1的原码表示是00000001，取反是11111110，然后再加1，就是11111111。</li><li>-2：2的原码表示是00000010，取反是11111101，然后再加1，就是11111110。</li><li>-127：127的原码表示是01111111，取反是10000000，然后再加1，就是10000001。 </li></ul><h3 id="小数转二进制"><a href="#小数转二进制" class="headerlink" title="小数转二进制"></a><strong>小数转二进制</strong></h3><p>对小数点以后的数乘以2，有一个结果吧，取结果的整数部分（不是1就是0喽），然后再用小数部分再乘以2，再取结果的整数部分……以此类推，直到小数部分为0或者位数已经够了就OK了</p><figure class="highlight tex"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs tex">0.12345<br><br>0.12345 * 2 =  0.24690<br><br>0.2469 * 2 =  0.49380<br><br>0.4938 * 2 =  0.98760<br><br>0.9876 * 2 =  1.97521<br><br>0.9752 * 2 = 1.9504 1<br><br>...........忽略，直至小数部分为0，排序<br></code></pre></td></tr></table></figure><h3 id="十六进制"><a href="#十六进制" class="headerlink" title="十六进制"></a>十六进制</h3><p>二进制写起来太长，为了简化写法，可以将四个二进制位简化为一个0到15的数，10到15用字符A到F表示，这种表示方法称为16进制，如下所示：</p><p><img src="http://oss.mengsu.site/image-20211218110855495.png" alt="image-20211218110855495"></p><p>比如123转十六进制</p><p>123 / 16 = 7 余数 11，十六进制表示法。0x <strong>+</strong> 7B，B就是11，结果就是：<strong>0x7B</strong></p><h3 id="java正整数转换"><a href="#java正整数转换" class="headerlink" title="java正整数转换"></a>java正整数转换</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">int</span> a = <span class="hljs-number">25</span>;<br>System.out.println(Integer.toBinaryString(a)); <span class="hljs-comment">//二进制</span><br>System.out.println(Integer.toHexString(a));  <span class="hljs-comment">//十六进制</span><br>System.out.println(Long.toBinaryString(a)); <span class="hljs-comment">//二进制</span><br>System.out.println(Long.toHexString(a));  <span class="hljs-comment">//十六进制</span><br></code></pre></td></tr></table></figure><h3 id="位运算"><a href="#位运算" class="headerlink" title="位运算"></a><strong>位运算</strong></h3><p>位运算是将数据看做二进制，进行位级别的操作，Java不能单独表示一个位，但是可以用byte表示8位，可以用16进制写二进制常量。比如： 0010表示成16进制是 0x2, 110110表示成16进制是 0x36。</p><p>位运算有移位运算和逻辑运算。</p><p>移位有：</p><ul><li>左移：操作符为&lt;&lt;，向左移动，右边的低位补0，高位的就舍弃掉了，将二进制看做整数，左移1位就相当于乘以2。</li><li>无符号右移：操作符为&gt;&gt;&gt;，向右移动，右边的舍弃掉，左边补0。</li><li>有符号右移：操作符为&gt;&gt;，向右移动，右边的舍弃掉，左边补什么取决于原来最高位是什么，原来是1就补1，原来是0就补0，将二进制看做整数，右移1位相当于除以2。</li></ul><p>例如：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">int</span> a = <span class="hljs-number">4</span>; <span class="hljs-comment">// 100</span><br>a = a &gt;&gt; <span class="hljs-number">2</span>; <span class="hljs-comment">// 001，等于1</span><br>a = a &lt;&lt; <span class="hljs-number">3</span> <span class="hljs-comment">// 1000，变为8</span><br></code></pre></td></tr></table></figure><p>逻辑运算有：</p><ul><li>按位与 &amp;：两位都为1才为1</li><li>按位或 |：只要有一位为1，就为1</li><li>按位取反 ~： 1变为0，0变为1</li><li>按位异或 ^ ：相异为真，相同为假</li></ul><p>大部分都比较简单，就不详细说了。具体形式，例如：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">int</span> a = ...; <br>a = a &amp; <span class="hljs-number">0x1</span> <span class="hljs-comment">// 返回0或1，就是a最右边一位的值。</span><br>a = a | <span class="hljs-number">0x1</span> <span class="hljs-comment">//不管a原来最右边一位是什么，都将设为1</span><br></code></pre></td></tr></table></figure>]]></content>
    
    
    
    <tags>
      
      <tag>Java</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Effective Java 笔记</title>
    <link href="/2021/08/09/effective-java/"/>
    <url>/2021/08/09/effective-java/</url>
    
    <content type="html"><![CDATA[<h1 id="一、用静态工厂方法代替构造器"><a href="#一、用静态工厂方法代替构造器" class="headerlink" title="一、用静态工厂方法代替构造器"></a>一、用静态工厂方法代替构造器</h1><h3 id="优点"><a href="#优点" class="headerlink" title="优点"></a>优点</h3><ol><li>静态工厂方法与构造器不同的第一大优势在于，他们有名称</li></ol><blockquote><p>比如 BigInteger.probablePrime 直接返回可能为素数</p></blockquote><ol start="2"><li>静态工厂方法与构造器不同的第二大优势在于，不必在每次调用它们的时候都创建一个新对象</li></ol><blockquote><p>可以使用预先构建好的实例，或者将构建好的实例缓存起来， 进行重复利用，从而避免创建不必要的重复对象</p></blockquote><ol start="3"><li>静态工厂方法与构造器不同的第三大优势在于，它们可以返回原返回类型的任何子类型的对象</li></ol><blockquote><p>例如 Java Collections Framework 的集合接口有 45 个工具实现，分别提供了不可修改的集合、 同步集合，等等</p></blockquote><ol start="4"><li>静态工厂的第四大优势在于，所返回的对象的类可以随着每次调用而发生变化，这取决于静态工厂方法的参数值</li></ol><blockquote><p>..</p></blockquote><ol start="5"><li>静态工厂的第五大优势在于，方法返回的对象所属的类，在编写包含该静态工厂方法的类时可以不存在</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/** 返回Connection,该类为DriverManager.class */</span><br>    <span class="hljs-meta">@CallerSensitive</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> Connection <span class="hljs-title">getConnection</span><span class="hljs-params">(String url,</span></span><br><span class="hljs-params"><span class="hljs-function">        java.util.Properties info)</span> <span class="hljs-keyword">throws</span> SQLException </span>&#123;<br><br>        <span class="hljs-keyword">return</span> (getConnection(url, info, Reflection.getCallerClass()));<br>    &#125;<br></code></pre></td></tr></table></figure><h3 id="缺点"><a href="#缺点" class="headerlink" title="缺点"></a>缺点</h3><ol><li>静态工厂方法的主要缺点在子，类如果不含公有的或者受保护的构造器，就不能被子类化</li><li>静态工厂方法的第二个缺点在于，程序员很难发现它们</li></ol><blockquote><p>对于提供了静态工厂方法而不是构造器的类来说，要想查明如何实例化一个类是非常困难的 。</p></blockquote><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><blockquote><p>简而言之，静态工厂方法和公有构造器都有用处，我们需要理解他们各自的长处。静态工厂经常更加合适，因此切忌第一反应就是提供公有的构造器，而不先考虑静态工厂。</p></blockquote><h1 id="二、遇到多个构造器参数时要考虑使用构建器"><a href="#二、遇到多个构造器参数时要考虑使用构建器" class="headerlink" title="二、遇到多个构造器参数时要考虑使用构建器"></a>二、遇到多个构造器参数时要考虑使用构建器</h1><blockquote><p>静态工厂和构造器有个共同的局限性：它们都不能很好 扩展到大量的可选参数</p><p>重叠构造器模式可行，但是当有许多参数的时候，客户端代码会很难缩写，并且仍然较难以阅读</p><p>简而言之 如果类的构造器或者静态工厂中具有多个参数，设计这种类时， Builde模式就是一种不错的选择，</p><p>采用 <code>Buide</code> 模式</p></blockquote><h1 id="三、用私有构造器或者枚举类型强化-Singleton-属性"><a href="#三、用私有构造器或者枚举类型强化-Singleton-属性" class="headerlink" title="三、用私有构造器或者枚举类型强化 Singleton 属性"></a>三、用私有构造器或者枚举类型强化 Singleton 属性</h1>]]></content>
    
    
    
    <tags>
      
      <tag>Effective Java</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>springboot源码分析(04) - SpringApplication run</title>
    <link href="/2021/08/01/springboot-source-04/"/>
    <url>/2021/08/01/springboot-source-04/</url>
    
    <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>上节讲了 <code>SpringApplication</code> 的构造方法，这节咱们来看下 <code>SpringApplication</code> 的 <code>run</code> 方法。</p><h1 id="run方法"><a href="#run方法" class="headerlink" title="run方法"></a>run方法</h1><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// SpringApplication.java</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> ConfigurableApplicationContext <span class="hljs-title">run</span><span class="hljs-params">(String... args)</span> </span>&#123;<br>  <span class="hljs-comment">// &lt;1&gt; 创建 StopWatch 对象，并启动。StopWatch 主要用于简单统计 run 启动过程的时长。</span><br>StopWatch stopWatch = <span class="hljs-keyword">new</span> StopWatch();<br>stopWatch.start();<br>  <span class="hljs-comment">// 初始化ApplicationContext</span><br>ConfigurableApplicationContext context = <span class="hljs-keyword">null</span>;<br>Collection&lt;SpringBootExceptionReporter&gt; exceptionReporters = <span class="hljs-keyword">new</span> ArrayList&lt;&gt;();<br>  <span class="hljs-comment">// &lt;2&gt; 配置 headless 属性</span><br>configureHeadlessProperty();<br>  <span class="hljs-comment">// &lt;3&gt; 获得 SpringApplicationRunListener 的数组，并启动监听</span><br>SpringApplicationRunListeners listeners = getRunListeners(args);<br>  <span class="hljs-comment">// &lt;3.1&gt; 构建 ApplicationStartingEvent 事件，并且启动</span><br>listeners.starting();<br><span class="hljs-keyword">try</span> &#123;<br>      <span class="hljs-comment">// &lt;4&gt; 创建  ApplicationArguments 对象</span><br>ApplicationArguments applicationArguments = <span class="hljs-keyword">new</span> DefaultApplicationArguments(args);<br>      <span class="hljs-comment">// &lt;5&gt; 加载属性配置。执行完成后，所有的 environment 的属性都会加载进来，包括 application.properties 和外部的属性配置。</span><br>ConfigurableEnvironment environment = prepareEnvironment(listeners, applicationArguments);<br>configureIgnoreBeanInfo(environment);<br><span class="hljs-comment">// &lt;6&gt; 打印 Spring Banner</span><br>      Banner printedBanner = printBanner(environment);<br>      <span class="hljs-comment">// &lt;7&gt; 创建 Spring 容器。</span><br>context = createApplicationContext();<br>      <span class="hljs-comment">// &lt;8&gt; 异常报告器</span><br>exceptionReporters = getSpringFactoriesInstances(SpringBootExceptionReporter.class,<br><span class="hljs-keyword">new</span> Class[] &#123; ConfigurableApplicationContext.class &#125;, context);<br>      <span class="hljs-comment">// &lt;9&gt; 主要是调用所有初始化类的 initialize 方法</span><br>prepareContext(context, environment, listeners, applicationArguments, printedBanner);<br><span class="hljs-comment">// &lt;10&gt; 初始化 Spring 容器。</span><br>      refreshContext(context);<br>      <span class="hljs-comment">// &lt;11&gt; 执行 Spring 容器的初始化的后置逻辑。默认实现为空。</span><br>afterRefresh(context, applicationArguments);<br>      <span class="hljs-comment">// &lt;12&gt; 停止 StopWatch 统计时长</span><br>stopWatch.stop();<br>      <span class="hljs-comment">// &lt;13&gt; 打印 Spring Boot 启动的时长日志。</span><br><span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span>.logStartupInfo) &#123;<br><span class="hljs-keyword">new</span> StartupInfoLogger(<span class="hljs-keyword">this</span>.mainApplicationClass).logStarted(getApplicationLog(), stopWatch);<br>&#125;<br>      <span class="hljs-comment">// &lt;14&gt; 通知 SpringApplicationRunListener 的数组，Spring 容器启动完成。</span><br>listeners.started(context);<br>      <span class="hljs-comment">// &lt;15&gt; 调用 ApplicationRunner 或者 CommandLineRunner 的运行方法。</span><br>callRunners(context, applicationArguments);<br>&#125;<br><span class="hljs-keyword">catch</span> (Throwable ex) &#123;<br>      <span class="hljs-comment">// &lt;15.1&gt; 如果发生异常，则进行处理，并抛出 IllegalStateException 异常</span><br>handleRunFailure(context, ex, exceptionReporters, listeners);<br><span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> IllegalStateException(ex);<br>&#125;<br><br>  <span class="hljs-comment">// &lt;16&gt; 通知 SpringApplicationRunListener 的数组，Spring 容器运行中。</span><br><span class="hljs-keyword">try</span> &#123;<br>listeners.running(context);<br>&#125;<br><span class="hljs-keyword">catch</span> (Throwable ex) &#123;<br>      <span class="hljs-comment">// &lt;16.1&gt; 如果发生异常，则进行处理，并抛出 IllegalStateException 异常</span><br>handleRunFailure(context, ex, exceptionReporters, <span class="hljs-keyword">null</span>);<br><span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> IllegalStateException(ex);<br>&#125;<br><span class="hljs-keyword">return</span> context;<br>&#125;<br></code></pre></td></tr></table></figure><blockquote><p>咱们可以重点关注下一下几个点。</p></blockquote><ol><li><p>&lt;1&gt; 处， <code>StopWatch</code> 主要用于简单统计 <code>run</code> 启动过程的时长。</p></li><li><p>&lt;2&gt; 处，配置 <code>awt</code> &gt; <code>java.awt.headless</code> 为 <code>true</code>。</p></li><li><p>&lt;3&gt; 处，调用 <code>#getRunListeners(String[] args)</code> 方法，获得 <code>SpringApplicationRunListener</code> 数组，并启动监听。调用位置咱们在讲解 <a href="https://mengsu.site/2021/07/31/springboot-source-03/#SpringFactoriesLoader-loadFactoryNames">SpringApplication构造方法</a> 中提到过，这是是读取缓存中的值 <code>Map&lt;ClassLoader, MultiValueMap&lt;String, String&gt;&gt; cache</code> 。</p><p>&lt;3.1&gt; 处，构建了一个ApplicationStartingEvent事件，并将其发布出去，其中调用了resolveDefaultEventType方法，该方法返回了一个封装了事件的默认类型（ApplicationStartingEvent）的ResolvableType对象。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Override</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">multicastEvent</span><span class="hljs-params">(<span class="hljs-keyword">final</span> ApplicationEvent event, <span class="hljs-meta">@Nullable</span> ResolvableType eventType)</span> </span>&#123;<br>ResolvableType type = (eventType != <span class="hljs-keyword">null</span> ? eventType : resolveDefaultEventType(event));<br>Executor executor = getTaskExecutor();<br><span class="hljs-keyword">for</span> (ApplicationListener&lt;?&gt; listener : getApplicationListeners(event, type)) &#123;<br><span class="hljs-keyword">if</span> (executor != <span class="hljs-keyword">null</span>) &#123;<br>executor.execute(() -&gt; invokeListener(listener, event));<br>&#125;<br><span class="hljs-keyword">else</span> &#123;<br>invokeListener(listener, event);<br>&#125;<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>这里不得不提的就是springboot的事件机制</p><blockquote><p>事件源：SpringApplication</p><p>事件：ApplicationStartingEvent</p><p>监听器：过滤后的监听器，具体5个上文中已经说过</p><p>事件环境：EventPublishingListener，提供环境支持事件，并且发布事件（starting方法）</p></blockquote><blockquote><p>初略的看，就是遍历getApplicationListeners(event, type)，然后对每个listener进行invokeListener(listener, event)</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">protected</span> Collection&lt;ApplicationListener&lt;?&gt;&gt; getApplicationListeners(<br>ApplicationEvent event, ResolvableType eventType) &#123;<br><br>Object source = event.getSource();<br>Class&lt;?&gt; sourceType = (source != <span class="hljs-keyword">null</span> ? source.getClass() : <span class="hljs-keyword">null</span>);<br>ListenerCacheKey cacheKey = <span class="hljs-keyword">new</span> ListenerCacheKey(eventType, sourceType);<br><br><span class="hljs-comment">// Quick check for existing entry on ConcurrentHashMap...</span><br>ListenerRetriever retriever = <span class="hljs-keyword">this</span>.retrieverCache.get(cacheKey);<br><span class="hljs-keyword">if</span> (retriever != <span class="hljs-keyword">null</span>) &#123;<br><span class="hljs-keyword">return</span> retriever.getApplicationListeners();<br>&#125;<br><br><span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span>.beanClassLoader == <span class="hljs-keyword">null</span> ||<br>(ClassUtils.isCacheSafe(event.getClass(), <span class="hljs-keyword">this</span>.beanClassLoader) &amp;&amp;<br>(sourceType == <span class="hljs-keyword">null</span> || ClassUtils.isCacheSafe(sourceType, <span class="hljs-keyword">this</span>.beanClassLoader)))) &#123;<br><span class="hljs-comment">// Fully synchronized building and caching of a ListenerRetriever</span><br><span class="hljs-keyword">synchronized</span> (<span class="hljs-keyword">this</span>.retrievalMutex) &#123;<br>retriever = <span class="hljs-keyword">this</span>.retrieverCache.get(cacheKey);<br><span class="hljs-keyword">if</span> (retriever != <span class="hljs-keyword">null</span>) &#123;<br><span class="hljs-keyword">return</span> retriever.getApplicationListeners();<br>&#125;<br>retriever = <span class="hljs-keyword">new</span> ListenerRetriever(<span class="hljs-keyword">true</span>);<br>Collection&lt;ApplicationListener&lt;?&gt;&gt; listeners =<br>retrieveApplicationListeners(eventType, sourceType, retriever);<br><span class="hljs-keyword">this</span>.retrieverCache.put(cacheKey, retriever);<br><span class="hljs-keyword">return</span> listeners;<br>&#125;<br>&#125;<br><span class="hljs-keyword">else</span> &#123;<br><span class="hljs-comment">// No ListenerRetriever caching -&gt; no synchronization necessary</span><br><span class="hljs-keyword">return</span> retrieveApplicationListeners(eventType, sourceType, <span class="hljs-keyword">null</span>);<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><blockquote><p>从上图可知，主要涉及到3个点：缓存retrieverCache、retrieveApplicationListeners已经retrieveApplicationListeners中调用的supportsEvent方法。流程是这样的：</p><p>1、缓存中是否有匹配的结果，有则返回</p><p>2、若缓存中没有匹配的结果，则从this.defaultRetriever.applicationListeners中过滤，这个this表示的EventPublishingRunListener对象的属性initialMulticaster（也就是SimpleApplicationEventMulticaster对象，而defaultRetriever.applicationListeners的值也是在EventPublishingRunListener构造方法中初始化的）</p><p>3、过滤过程，遍历defaultRetriever.applicationListeners集合，从中找出ApplicationStartingEvent匹配的listener，具体的匹配规则需要看各个listener的supportsEventType方法（有两个重载的方法）</p><p>4、将过滤的结果缓存到retrieverCache</p><p>5、将过滤出的结果返回回去</p></blockquote><p>过滤出的listener对象有哪些:</p><p><img src="/images/springboot/springboot-run-starting.png"></p><blockquote><p>invokeListener</p><p>使用给定的事件调用给定的监听器</p><p>　　getApplicationListeners方法过滤出的监听器都会被调用，过滤出来的监听器包括LoggingApplicationListener、BackgroundPreinitializer、DelegatingApplicationListener、LiquibaseServiceLocatorApplicationListener、EnableEncryptablePropertiesBeanFactoryPostProcessor五种类型的对象。这五个对象的onApplicationEvent都会被调用。</p><p>　　那么这五个监听器的onApplicationEvent都做了些什么了</p><p>　　　　　　LoggingApplicationListener：检测正在使用的日志系统，默认是logback，支持3种，优先级从高到低：logback &gt; log4j &gt; javalog。此时日志系统还没有初始化</p><p>　　　　　　BackgroundPreinitializer：另起一个线程实例化Initializer并调用其run方法，包括验证器、消息转换器等等</p><p>　　　　　　DelegatingApplicationListener：此时什么也没做</p><p>　　　　　　LiquibaseServiceLocatorApplicationListener：此时什么也没做</p><p>　　　　　　EnableEncryptablePropertiesBeanFactoryPostProcessor：此时仅仅打印了一句日志，其他什么也没做</p></blockquote></li><li><p>&lt;4&gt; 处，创建 <code>DefaultApplicationArguments</code> </p></li><li><p>&lt;5&gt; 处，调用 <code>#prepareEnvironment(SpringApplicationRunListeners listeners, ApplicationArguments applicationArguments)</code> 方法，加载属性配置。执行完成后，所有的 environment 的属性都会加载进来，包括 <code>application.properties</code> 和外部的属性配置。</p></li><li><p>&lt;6&gt; 处，调用 <code>#printBanner(ConfigurableEnvironment environment)</code> 方法，打印 Spring Banner 。</p></li><li><p>&lt;7&gt; 处，调用 <code>#createApplicationContext()</code> 方法，创建 Spring 容器。请看代码：</p></li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">protected</span> ConfigurableApplicationContext <span class="hljs-title">createApplicationContext</span><span class="hljs-params">()</span> </span>&#123;<br>Class&lt;?&gt; contextClass = <span class="hljs-keyword">this</span>.applicationContextClass;<br><span class="hljs-keyword">if</span> (contextClass == <span class="hljs-keyword">null</span>) &#123;<br><span class="hljs-keyword">try</span> &#123;<br><span class="hljs-keyword">switch</span> (<span class="hljs-keyword">this</span>.webApplicationType) &#123;<br><span class="hljs-keyword">case</span> SERVLET: <span class="hljs-comment">// 这里</span><br>contextClass = Class.forName(DEFAULT_SERVLET_WEB_CONTEXT_CLASS);<br><span class="hljs-keyword">break</span>;<br><span class="hljs-keyword">case</span> REACTIVE:<br>contextClass = Class.forName(DEFAULT_REACTIVE_WEB_CONTEXT_CLASS);<br><span class="hljs-keyword">break</span>;<br><span class="hljs-keyword">default</span>:<br>contextClass = Class.forName(DEFAULT_CONTEXT_CLASS);<br>&#125;<br>&#125;<br><span class="hljs-keyword">catch</span> (ClassNotFoundException ex) &#123;<br><span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> IllegalStateException(<br><span class="hljs-string">&quot;Unable create a default ApplicationContext, &quot;</span> + <span class="hljs-string">&quot;please specify an ApplicationContextClass&quot;</span>,<br>ex);<br>&#125;<br>&#125;<br><span class="hljs-keyword">return</span> (ConfigurableApplicationContext) BeanUtils.instantiateClass(contextClass);<br>&#125;<br></code></pre></td></tr></table></figure><blockquote><p>根据SpringApplication的webApplicationType来实例化对应的上下文；如果webApplicationType的值是SERVLET，那么实例化AnnotationConfigServletWebServerApplicationContext，如果是REACTIVE则实例化AnnotationConfigReactiveWebServerApplicationContext（响应式编程，后续再看），如果既不是SERVLET、也不是REACTIVE，那么则是默认情况（也就是我们所说的非web引用），实例化AnnotationConfigApplicationContext。很显然我们目前的应用类型是SERVLET，那么实例化AnnotationConfigServletWebServerApplicationContext。</p></blockquote><ol start="8"><li><p>&lt;8&gt; 处，…</p></li><li><p>&lt;9&gt; 处，<code>#prepareContext(ConfigurableApplicationContext context, ConfigurableEnvironment environment, SpringApplicationRunListeners listeners, ApplicationArguments applicationArguments, Banner printedBanner)</code> 方法，准备 ApplicationContext 对象，主要是初始化它的一些属性。</p></li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">prepareContext</span><span class="hljs-params">(ConfigurableApplicationContext context, ConfigurableEnvironment environment,</span></span><br><span class="hljs-params"><span class="hljs-function">SpringApplicationRunListeners listeners, ApplicationArguments applicationArguments, Banner printedBanner)</span> </span>&#123;<br><span class="hljs-comment">// &lt;1&gt; 设置 context 的 environment 属性</span><br>  context.setEnvironment(environment);<br>  <span class="hljs-comment">// &lt;2&gt; 设置 context 的一些属性</span><br>postProcessApplicationContext(context);<br>  <span class="hljs-comment">// &lt;3&gt; 初始化 ApplicationContextInitializer</span><br>applyInitializers(context);<br>  <span class="hljs-comment">// &lt;4&gt; 通知 SpringApplicationRunListener 的数组，Spring 容器准备完成。</span><br>listeners.contextPrepared(context);<br>  <span class="hljs-comment">// &lt;5&gt; 打印日志</span><br><span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span>.logStartupInfo) &#123;<br>logStartupInfo(context.getParent() == <span class="hljs-keyword">null</span>);<br>logStartupProfileInfo(context);<br>&#125;<br><span class="hljs-comment">// Add boot specific singleton beans</span><br>  <span class="hljs-comment">// &lt;6&gt; 设置 beanFactory 的属性</span><br>ConfigurableListableBeanFactory beanFactory = context.getBeanFactory();<br>beanFactory.registerSingleton(<span class="hljs-string">&quot;springApplicationArguments&quot;</span>, applicationArguments);<br><span class="hljs-keyword">if</span> (printedBanner != <span class="hljs-keyword">null</span>) &#123;<br>beanFactory.registerSingleton(<span class="hljs-string">&quot;springBootBanner&quot;</span>, printedBanner);<br>&#125;<br><span class="hljs-keyword">if</span> (beanFactory <span class="hljs-keyword">instanceof</span> DefaultListableBeanFactory) &#123;<br>((DefaultListableBeanFactory) beanFactory)<br>.setAllowBeanDefinitionOverriding(<span class="hljs-keyword">this</span>.allowBeanDefinitionOverriding);<br>&#125;<br><span class="hljs-comment">// Load the sources</span><br>  <span class="hljs-comment">// &lt;7&gt; 加载 BeanDefinition 们</span><br>Set&lt;Object&gt; sources = getAllSources();<br>Assert.notEmpty(sources, <span class="hljs-string">&quot;Sources must not be empty&quot;</span>);<br>load(context, sources.toArray(<span class="hljs-keyword">new</span> Object[<span class="hljs-number">0</span>]));<br>  <span class="hljs-comment">// &lt;8&gt; 通知 SpringApplicationRunListener 的数组，Spring 容器加载完成。</span><br>listeners.contextLoaded(context);<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    
    <tags>
      
      <tag>SpringBoot</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>springboot源码分析(03) - SpringApplication构造方法</title>
    <link href="/2021/07/31/springboot-source-03/"/>
    <url>/2021/07/31/springboot-source-03/</url>
    
    <content type="html"><![CDATA[<h1 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h1><p>上节自己搭建的 <code>web</code> 例子</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">import</span> org.springframework.boot.SpringApplication;<br><span class="hljs-keyword">import</span> org.springframework.boot.autoconfigure.SpringBootApplication;<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@Author</span>: mengsu</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@Date</span>: 2021/7/30</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@Description</span>:</span><br><span class="hljs-comment"> */</span><br><span class="hljs-meta">@SpringBootApplication</span> <span class="hljs-comment">// &lt;1&gt;</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MyTestMVCApplication</span> </span>&#123;<br><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>SpringApplication.run(MyTestMVCApplication.class, args);  <span class="hljs-comment">// &lt;2&gt;</span><br>&#125;<br><br>&#125;<br></code></pre></td></tr></table></figure><ul><li><code>&lt;1&gt;</code> 处，使用 <code>@SpringBootApplication</code> 注解，标明是 Spring Boot 应用。通过它，可以开启自动配置的功能。</li><li><code>&lt;2&gt;</code> 处，调用 <code>SpringApplication#run(Class&lt;?&gt;... primarySources)</code> 方法，启动 Spring Boot 应用。</li></ul><p>上述的代码，是我们使用 Spring Boot 时，最最最常用的代码。而本文，我们先来分析 Spring Boot 应用的<strong>启动过程</strong>。</p><h3 id="SpringApplication类注释"><a href="#SpringApplication类注释" class="headerlink" title="SpringApplication类注释"></a>SpringApplication类注释</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Class that can be used to bootstrap and launch a Spring application from a Java main</span><br><span class="hljs-comment"> * method. By default class will perform the following steps to bootstrap your</span><br><span class="hljs-comment"> * application:</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> * &lt;ul&gt;</span><br><span class="hljs-comment"> * &lt;li&gt;Create an appropriate &#123;<span class="hljs-doctag">@link</span> ApplicationContext&#125; instance (depending on your</span><br><span class="hljs-comment"> * classpath)&lt;/li&gt;</span><br><span class="hljs-comment"> * &lt;li&gt;Register a &#123;<span class="hljs-doctag">@link</span> CommandLinePropertySource&#125; to expose command line arguments as</span><br><span class="hljs-comment"> * Spring properties&lt;/li&gt;</span><br><span class="hljs-comment"> * &lt;li&gt;Refresh the application context, loading all singleton beans&lt;/li&gt;</span><br><span class="hljs-comment"> * &lt;li&gt;Trigger any &#123;<span class="hljs-doctag">@link</span> CommandLineRunner&#125; beans&lt;/li&gt;</span><br><span class="hljs-comment"> * &lt;/ul&gt;</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> * In most circumstances the static &#123;<span class="hljs-doctag">@link</span> #run(Class, String[])&#125; method can be called</span><br><span class="hljs-comment"> * directly from your &#123;<span class="hljs-doctag">@literal</span> main&#125; method to bootstrap your application:</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> * &lt;pre class=&quot;code&quot;&gt;</span><br><span class="hljs-comment"> * &amp;#064;Configuration</span><br><span class="hljs-comment"> * &amp;#064;EnableAutoConfiguration</span><br><span class="hljs-comment"> * public class MyApplication  &#123;</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> *   // ... Bean definitions</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> *   public static void main(String[] args) &#123;</span><br><span class="hljs-comment"> *     SpringApplication.run(MyApplication.class, args);</span><br><span class="hljs-comment"> *   &#125;</span><br><span class="hljs-comment"> * &#125;</span><br><span class="hljs-comment"> * &lt;/pre&gt;</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> * &lt;p&gt;</span><br><span class="hljs-comment"> * For more advanced configuration a &#123;<span class="hljs-doctag">@link</span> SpringApplication&#125; instance can be created and</span><br><span class="hljs-comment"> * customized before being run:</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> * &lt;pre class=&quot;code&quot;&gt;</span><br><span class="hljs-comment"> * public static void main(String[] args) &#123;</span><br><span class="hljs-comment"> *   SpringApplication application = new SpringApplication(MyApplication.class);</span><br><span class="hljs-comment"> *   // ... customize application settings here</span><br><span class="hljs-comment"> *   application.run(args)</span><br><span class="hljs-comment"> * &#125;</span><br><span class="hljs-comment"> * &lt;/pre&gt;</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> * &#123;<span class="hljs-doctag">@link</span> SpringApplication&#125;s can read beans from a variety of different sources. It is</span><br><span class="hljs-comment"> * generally recommended that a single &#123;<span class="hljs-doctag">@code</span> <span class="hljs-doctag">@Configuration</span>&#125; class is used to bootstrap</span><br><span class="hljs-comment"> * your application, however, you may also set &#123;<span class="hljs-doctag">@link</span> #getSources() sources&#125; from:</span><br><span class="hljs-comment"> * &lt;ul&gt;</span><br><span class="hljs-comment"> * &lt;li&gt;The fully qualified class name to be loaded by</span><br><span class="hljs-comment"> * &#123;<span class="hljs-doctag">@link</span> AnnotatedBeanDefinitionReader&#125;&lt;/li&gt;</span><br><span class="hljs-comment"> * &lt;li&gt;The location of an XML resource to be loaded by &#123;<span class="hljs-doctag">@link</span> XmlBeanDefinitionReader&#125;, or</span><br><span class="hljs-comment"> * a groovy script to be loaded by &#123;<span class="hljs-doctag">@link</span> GroovyBeanDefinitionReader&#125;&lt;/li&gt;</span><br><span class="hljs-comment"> * &lt;li&gt;The name of a package to be scanned by &#123;<span class="hljs-doctag">@link</span> ClassPathBeanDefinitionScanner&#125;&lt;/li&gt;</span><br><span class="hljs-comment"> * &lt;/ul&gt;</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> * Configuration properties are also bound to the &#123;<span class="hljs-doctag">@link</span> SpringApplication&#125;. This makes it</span><br><span class="hljs-comment"> * possible to set &#123;<span class="hljs-doctag">@link</span> SpringApplication&#125; properties dynamically, like additional</span><br><span class="hljs-comment"> * sources (&quot;spring.main.sources&quot; - a CSV list) the flag to indicate a web environment</span><br><span class="hljs-comment"> * (&quot;spring.main.web-application-type=none&quot;) or the flag to switch off the banner</span><br><span class="hljs-comment"> * (&quot;spring.main.banner-mode=off&quot;).</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@author</span> Phillip Webb</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@author</span> Dave Syer</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@author</span> Andy Wilkinson</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@author</span> Christian Dupuis</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@author</span> Stephane Nicoll</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@author</span> Jeremy Rickard</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@author</span> Craig Burke</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@author</span> Michael Simons</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@author</span> Madhura Bhave</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@author</span> Brian Clozel</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@author</span> Ethan Rubinson</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@since</span> 1.0.0</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@see</span> #run(Class, String[])</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@see</span> #run(Class[], String[])</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@see</span> #SpringApplication(Class...)</span><br><span class="hljs-comment"> */</span><br></code></pre></td></tr></table></figure><p><code>SpringApplication</code> 用于从 <code>java main</code> 方法引导和启动 <code>Spring</code> 应用程序，默认情况下，将执行以下步骤来引导我们的应用程序：</p><ol><li>创建一个恰当的 <code>ApplicationContext</code> 实例（取决于类路径）</li><li>注册 <code>CommandLinePropertySource</code> ，将命令行参数公开为 <code>Spring</code> 属性</li><li>刷新应用程序上下文，加载所有单例 <code>bean</code></li><li>触发全部 <code>CommandLineRunner bean</code></li></ol><p>大多数情况下，像 <code>SpringApplication.run(MyTestMVCApplication, args)</code> ; 这样启动我们的应用，也可以在运行之前创建和自定义 <code>SpringApplication</code> 实例，具体可以参考注释中示例。<code>SpringApplication</code> 可以从各种不同的源读取bean。 通常建议使用单个 <code>@Configuration</code> 类来引导，但是我们也可以通过以下方式来设置资源：</p><ol><li>通过 <code>AnnotatedBeanDefinitionReader</code> 加载完全限定类名</li><li>通过 <code>XmlBeanDefinitionReader</code> 加载 XML 资源位置，或者是通过 <code>GroovyBeanDefinitionReader</code> 加载 <code>groovy</code> 脚本位置</li><li>通过 <code>ClassPathBeanDefinitionScanner</code> 扫描包名称</li></ol><p>也就是说 <code>SpringApplication</code> 还是做了不少事的，具体实现后续会慢慢讲来，今天的主角只是 <code>SpringApplication</code> 构造方法。</p><h1 id="SpringApplication构造方法"><a href="#SpringApplication构造方法" class="headerlink" title="SpringApplication构造方法"></a>SpringApplication构造方法</h1><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123; <span class="hljs-comment">// &lt;1&gt;</span><br>SpringApplication.run(MyTestMVCApplication.class, args);   <br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> ConfigurableApplicationContext <span class="hljs-title">run</span><span class="hljs-params">(Class&lt;?&gt; primarySource, String... args)</span> </span>&#123; <span class="hljs-comment">// &lt;2&gt;</span><br><span class="hljs-keyword">return</span> run(<span class="hljs-keyword">new</span> Class&lt;?&gt;[] &#123; primarySource &#125;, args);<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> ConfigurableApplicationContext <span class="hljs-title">run</span><span class="hljs-params">(Class&lt;?&gt;[] primarySources, String[] args)</span> </span>&#123; <span class="hljs-comment">// &lt;3&gt;</span><br><span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> SpringApplication(primarySources).run(args);   <br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">SpringApplication</span><span class="hljs-params">(Class&lt;?&gt;... primarySources)</span> </span>&#123; <span class="hljs-comment">// &lt;4&gt;</span><br><span class="hljs-keyword">this</span>(<span class="hljs-keyword">null</span>, primarySources);<br>&#125;<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Create a new &#123;<span class="hljs-doctag">@link</span> SpringApplication&#125; instance. The application context will load</span><br><span class="hljs-comment"> * beans from the specified primary sources (see &#123;<span class="hljs-doctag">@link</span> SpringApplication class-level&#125;</span><br><span class="hljs-comment"> * documentation for details. The instance can be customized before calling</span><br><span class="hljs-comment"> * &#123;<span class="hljs-doctag">@link</span> #run(String...)&#125;.</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@param</span> resourceLoader the resource loader to use</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@param</span> primarySources the primary bean sources</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@see</span> #run(Class, String[])</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@see</span> #setSources(Set)</span><br><span class="hljs-comment"> */</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">SpringApplication</span><span class="hljs-params">(ResourceLoader resourceLoader, Class&lt;?&gt;... primarySources)</span> </span>&#123; <span class="hljs-comment">// &lt;5&gt;</span><br><span class="hljs-keyword">this</span>.resourceLoader = resourceLoader;   <br>Assert.notNull(primarySources, <span class="hljs-string">&quot;PrimarySources must not be null&quot;</span>);<br><span class="hljs-keyword">this</span>.primarySources = <span class="hljs-keyword">new</span> LinkedHashSet&lt;&gt;(Arrays.asList(primarySources)); <br><span class="hljs-keyword">this</span>.webApplicationType = WebApplicationType.deduceFromClasspath(); <span class="hljs-comment">// &lt;5.1&gt;</span><br>setInitializers((Collection) getSpringFactoriesInstances(ApplicationContextInitializer.class));  <span class="hljs-comment">// &lt;5.2&gt;</span><br>setListeners((Collection) getSpringFactoriesInstances(ApplicationListener.class)); <span class="hljs-comment">// &lt;5.3&gt;</span><br><span class="hljs-keyword">this</span>.mainApplicationClass = deduceMainApplicationClass();  <span class="hljs-comment">// &lt;5.4&gt;</span><br>&#125;<br></code></pre></td></tr></table></figure><p>按照层级跳转分为以上五个层级结构，可以发现咱们自定义的 <code>MyTestMVCApplication main</code> 方法都是调用的 <code>SpringApplication</code> 静态方法，直接到达的构造函数。</p><p>从 <code>SpringApplication</code> 构造函数的注释上来看，就是说创建一个 <code>MyTestMVCApplication </code>实例，应用上下文从特定的资源文件中加载<code>bean</code>。可以在调用<code>run</code>之前自定义实例。</p><h2 id="5-1-WebApplicationType-deduceFromClasspath"><a href="#5-1-WebApplicationType-deduceFromClasspath" class="headerlink" title="5.1 WebApplicationType.deduceFromClasspath()"></a>5.1 WebApplicationType.deduceFromClasspath()</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">static</span> WebApplicationType <span class="hljs-title">deduceFromClasspath</span><span class="hljs-params">()</span> </span>&#123;<br><span class="hljs-keyword">if</span> (ClassUtils.isPresent(WEBFLUX_INDICATOR_CLASS, <span class="hljs-keyword">null</span>) &amp;&amp; !ClassUtils.isPresent(WEBMVC_INDICATOR_CLASS, <span class="hljs-keyword">null</span>)<br>&amp;&amp; !ClassUtils.isPresent(JERSEY_INDICATOR_CLASS, <span class="hljs-keyword">null</span>)) &#123;<br><span class="hljs-keyword">return</span> WebApplicationType.REACTIVE;<br>&#125;<br><span class="hljs-keyword">for</span> (String className : SERVLET_INDICATOR_CLASSES) &#123;<br>     <span class="hljs-comment">// 判断给定的类是否能够加载，就是说类路径下是否存在给定的类</span><br><span class="hljs-keyword">if</span> (!ClassUtils.isPresent(className, <span class="hljs-keyword">null</span>)) &#123;<br><span class="hljs-keyword">return</span> WebApplicationType.NONE;<br>&#125;<br>&#125;<br><span class="hljs-keyword">return</span> WebApplicationType.SERVLET;<br>&#125;<br></code></pre></td></tr></table></figure><blockquote><p>如果<code>org.springframework.web.reactive.DispatcherHandler</code>能够被加载且<code>org.springframework.web.servlet.DispatcherServlet</code>不能够被加载，那么断定<code>web</code>应用类型是<code>REACTIVE</code>；如果<code>javax.servlet.Servlet</code>和<code>org.springframework.web.context.ConfigurableWebApplicationContext</code>任意一个不能被加载，那么断定<code>web</code>应用类型是<code>NONE</code>；如果不能断定是<code>REACTIVE</code>和<code>NONE</code>，那么就是<code>SERVLET</code>类型；具体这三种类型代表什么含义，可以查看WebApplicationType中的说明。　　</p></blockquote><h2 id="5-2-setInitializers-Collection-getSpringFactoriesInstances-ApplicationContextInitializer-class"><a href="#5-2-setInitializers-Collection-getSpringFactoriesInstances-ApplicationContextInitializer-class" class="headerlink" title="5.2 setInitializers((Collection) getSpringFactoriesInstances(ApplicationContextInitializer.class));"></a>5.2 setInitializers((Collection) getSpringFactoriesInstances(ApplicationContextInitializer.class));</h2><blockquote><p>从字面意思看就是获取spring工厂实例，至于从哪获取哪些工厂实例，我们往下看。</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">private</span> &lt;T&gt; <span class="hljs-function">Collection&lt;T&gt; <span class="hljs-title">getSpringFactoriesInstances</span><span class="hljs-params">(Class&lt;T&gt; type)</span> </span>&#123; <span class="hljs-comment">// &lt;1&gt;</span><br><span class="hljs-keyword">return</span> getSpringFactoriesInstances(type, <span class="hljs-keyword">new</span> Class&lt;?&gt;[] &#123;&#125;);<br>&#125;<br><br><span class="hljs-keyword">private</span> &lt;T&gt; <span class="hljs-function">Collection&lt;T&gt; <span class="hljs-title">getSpringFactoriesInstances</span><span class="hljs-params">(Class&lt;T&gt; type, Class&lt;?&gt;[] parameterTypes, Object... args)</span> </span>&#123; <span class="hljs-comment">// &lt;2&gt;</span><br>ClassLoader classLoader = getClassLoader();<br><span class="hljs-comment">// Use names and ensure unique to protect against duplicates</span><br>Set&lt;String&gt; names = <span class="hljs-keyword">new</span> LinkedHashSet&lt;&gt;(SpringFactoriesLoader.loadFactoryNames(type, classLoader));<br>List&lt;T&gt; instances = createSpringFactoriesInstances(type, parameterTypes, classLoader, args, names);<br>AnnotationAwareOrderComparator.sort(instances);<br><span class="hljs-keyword">return</span> instances;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="SpringFactoriesLoader-loadFactoryNames"><a href="#SpringFactoriesLoader-loadFactoryNames" class="headerlink" title="SpringFactoriesLoader.loadFactoryNames"></a>SpringFactoriesLoader.loadFactoryNames</h3><blockquote><p><strong>SpringFactoriesLoader.loadFactoryNames</strong> 可以先留意下，该处代码会在 <code>run</code> 的时候进行读取，可以看到现在的作用就是为了初始化实例，并且放在缓存当中。</p><ol><li><p>查找类路径下全部的META-INF/spring.factories的URL</p></li><li><p>根据url加载全部的spring.factories中的属性，spring.factories内容如下</p></li><li><p>将所有spring.factories中的值缓存到SpringFactoriesLoader的cache中：</p><p>private static final Map&lt;ClassLoader, MultiValueMap&lt;String, String&gt;&gt; cache = new ConcurrentReferenceHashMap&lt;&gt;()；方便下次调用。</p></li></ol></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> List&lt;String&gt; <span class="hljs-title">loadFactoryNames</span><span class="hljs-params">(Class&lt;?&gt; factoryClass, <span class="hljs-meta">@Nullable</span> ClassLoader classLoader)</span> </span>&#123;<br>String factoryClassName = factoryClass.getName();<br><span class="hljs-keyword">return</span> loadSpringFactories(classLoader).getOrDefault(factoryClassName, Collections.emptyList());<br>&#125;<br><br><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> Map&lt;String, List&lt;String&gt;&gt; loadSpringFactories(<span class="hljs-meta">@Nullable</span> ClassLoader classLoader) &#123;<br>MultiValueMap&lt;String, String&gt; result = cache.get(classLoader);<br><span class="hljs-keyword">if</span> (result != <span class="hljs-keyword">null</span>) &#123;<br><span class="hljs-keyword">return</span> result;<br>&#125;<br><br><span class="hljs-keyword">try</span> &#123;<br>     <span class="hljs-comment">// classLoader.getResources(FACTORIES_RESOURCE_LOCATION)获取类路径下全部的META-INF/spring.factories的URL</span><br>Enumeration&lt;URL&gt; urls = (classLoader != <span class="hljs-keyword">null</span> ?<br>classLoader.getResources(FACTORIES_RESOURCE_LOCATION) :<br>ClassLoader.getSystemResources(FACTORIES_RESOURCE_LOCATION));<br>result = <span class="hljs-keyword">new</span> LinkedMultiValueMap&lt;&gt;();<br>     <span class="hljs-comment">// 遍历全部的URL，逐个读取META-INF/spring.factories中的属性</span><br><span class="hljs-keyword">while</span> (urls.hasMoreElements()) &#123;<br>URL url = urls.nextElement();<br>UrlResource resource = <span class="hljs-keyword">new</span> UrlResource(url);<br>Properties properties = PropertiesLoaderUtils.loadProperties(resource);<br><span class="hljs-keyword">for</span> (Map.Entry&lt;?, ?&gt; entry : properties.entrySet()) &#123;<br>String factoryClassName = ((String) entry.getKey()).trim();<br>         <span class="hljs-comment">// 属性全部放入MultiValueMap&lt;String, String&gt; result中，注意result的类型</span><br><span class="hljs-keyword">for</span> (String factoryName : StringUtils.commaDelimitedListToStringArray((String) entry.getValue())) &#123;<br>result.add(factoryClassName, factoryName.trim());<br>&#125;<br>&#125;<br>&#125;<br>     <span class="hljs-comment">// 结果放入缓存，方便下次查找，run方法中会使用缓存</span><br>cache.put(classLoader, result);<br><span class="hljs-keyword">return</span> result;<br>&#125;<br><span class="hljs-keyword">catch</span> (IOException ex) &#123;<br><span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> IllegalArgumentException(<span class="hljs-string">&quot;Unable to load factories from location [&quot;</span> +<br>FACTORIES_RESOURCE_LOCATION + <span class="hljs-string">&quot;]&quot;</span>, ex);<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="createSpringFactoriesInstances"><a href="#createSpringFactoriesInstances" class="headerlink" title="createSpringFactoriesInstances"></a>createSpringFactoriesInstances</h3><blockquote><p>根据上面获取的指定类型的工厂名称列表来实例化工厂bean，我们可以简单的认为通过反射来实例化，但是具体的实现也没那么简单，感兴趣的可以自己去跟。</p></blockquote><h3 id="AnnotationAwareOrderComparator-sort-instances"><a href="#AnnotationAwareOrderComparator-sort-instances" class="headerlink" title="AnnotationAwareOrderComparator.sort(instances)"></a>AnnotationAwareOrderComparator.sort(instances)</h3><blockquote><p>排序规则：@Order从小到大排序，没有order则按没排序之前的顺序。</p></blockquote><h2 id="5-3-getSpringFactoriesInstances-ApplicationListener-class"><a href="#5-3-getSpringFactoriesInstances-ApplicationListener-class" class="headerlink" title="5.3 getSpringFactoriesInstances(ApplicationListener.class))"></a>5.3 getSpringFactoriesInstances(ApplicationListener.class))</h2><blockquote><p>类似 5.2 一样，  只是传入的类型不同 &gt; <code>ApplicationListener</code></p></blockquote><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><ol><li>构造自身实例</li><li>推测web应用类型，并赋值到属性webApplicationType</li><li> 设置属性 </li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java">List&lt;ApplicationContextInitializer&lt;?&gt;&gt; initializers<br>List&lt;ApplicationListener&lt;?&gt;&gt; listeners<br></code></pre></td></tr></table></figure><p>中途读取了类路径下所有META-INF/spring.factories的属性，并缓存到了SpringFactoriesLoader的cache缓存中</p><ol start="4"><li>推断主类，并赋值到属性mainApplicationClass</li></ol>]]></content>
    
    
    
    <tags>
      
      <tag>SpringBoot</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>springboot源码分析(02) - 项目结构详解</title>
    <link href="/2021/07/30/springboot-source-02/"/>
    <url>/2021/07/30/springboot-source-02/</url>
    
    <content type="html"><![CDATA[<h1 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h1><p>本文主要分享 <strong>Spring Boot 的项目结构</strong>。<br>希望通过本文能让胖友对 Spring Boot 的整体项目有个简单的了解。</p><p><img src="/images/springboot/springboot-root.png"></p><h1 id="spring-boot-project-项目"><a href="#spring-boot-project-项目" class="headerlink" title="spring-boot-project 项目"></a>spring-boot-project 项目</h1><p>结构如下</p><p><img src="/images/springboot/springboot-project.png"></p><h2 id="spring-boot-模块"><a href="#spring-boot-模块" class="headerlink" title="spring-boot 模块"></a>spring-boot 模块</h2><p><code>spring-boot</code> 模块，Spring Boot 的核心实现</p><ul><li><p>在 <code>org.springframework.boot.SpringApplication</code> 类，提供了大量的静态方法，可以很容易运行一个独立的 Spring 应用程序。</p><blockquote><p>经常使用。</p></blockquote></li><li><p>带有可选容器的嵌入式 Web 应用程序（Tomcat、Jetty、Undertow） 的支持。</p><blockquote><p>在 <code>org.springframework.boot.web</code> 包下实现。</p></blockquote></li><li><p>边界的外部配置支持。</p></li><li><p>… 省略其它。</p></li></ul><h2 id="spring-boot-autoconfigure-模块"><a href="#spring-boot-autoconfigure-模块" class="headerlink" title="spring-boot-autoconfigure 模块"></a>spring-boot-autoconfigure 模块</h2><p><code>spring-boot-autoconfigure</code> 可以根据类路径的内容，自动配置大部分常用应用程序。通过使用 <code>org.springframework.boot.autoconfigure.@EnableAutoConfiguration</code> 注解，会触发 Spring 上下文的自动配置。</p><blockquote><p>这里的大部分，指的是常用的框架。例如说，Spring MVC、Quartz 等等。也就是说，如果 <code>spring-boot-actuator-autoconfigure</code> 模块，暂未提供的框架，需要我们自己去实现对应框架的自动装配。</p></blockquote><p>这个模块的代码，必须要看，没得商量。</p><p>所以到此处为止，我们已经看到对我们来研究 Spring Boot 最最最重要的两个模块：<code>spring-boot</code> 和 <code>spring-boot-autoconfigure</code> 。</p><h2 id="spring-boot-actuator-模块"><a href="#spring-boot-actuator-模块" class="headerlink" title="spring-boot-actuator 模块"></a>spring-boot-actuator 模块</h2><p><code>spring-boot-actuator</code> 模块。正如其模块的英文 actuator ，它完全是一个用于暴露应用自身信息的模块：</p><ul><li>提供了一个监控和管理生产环境的模块，可以使用 http、jmx、ssh、telnet 等管理和监控应用。</li><li>审计（Auditing）、 健康（health）、数据采集（metrics gathering）会自动加入到应用里面。</li></ul><blockquote><p>一般情况下，我们可以不看这块代码的代码。</p></blockquote><h2 id="spring-boot-actuator-autoconfigure-模块"><a href="#spring-boot-actuator-autoconfigure-模块" class="headerlink" title="spring-boot-actuator-autoconfigure 模块"></a>spring-boot-actuator-autoconfigure 模块</h2><p><code>spring-boot-actuator-autoconfigure</code> 模块，大概 1W7 行代码左右。它提供了 <code>spring-boot-actuator</code> 的自动配置功能。</p><blockquote><p>一般情况下，我们可以不看这块代码的代码。</p></blockquote><h2 id="spring-boot-starters-模块"><a href="#spring-boot-starters-模块" class="headerlink" title="spring-boot-starters 模块"></a>spring-boot-starters 模块</h2><p><code>spring-boot-starters</code> 模块，它不存在任何的代码，而是提供我们常用框架的 Starter 模块。例如：</p><ul><li><code>spring-boot-starter-web</code> 模块，提供了对 Spring MVC 的 Starter 模块。</li><li><code>spring-boot-starter-data-jpa</code> 模块，提供了对 Spring Data JPA 的 Starter 模块。</li></ul><p>而每个 Starter 模块，里面只存在一个 <code>pom</code> 文件，这是为什么呢？简单来说，Spring Boot 可以根据项目中是否存在指定类，并且是否未生成对应的 Bean 对象，那么就自动创建 Bean 对象。因为有这样的机制，我们只需要使用 <code>pom</code> 文件，配置需要引入的框架，就可以实现该框架的使用所需要的类的自动装配。</p><blockquote><p>当然，如果其中没有自己想要的starter， 可以自定义实现。</p></blockquote><h2 id="spring-boot-cli-模块"><a href="#spring-boot-cli-模块" class="headerlink" title="spring-boot-cli 模块"></a>spring-boot-cli 模块</h2><p><code>spring-boot-cli</code> 模块，大概 1W 行代码左右。它提供了 Spring 项目相关的命令行功能。它是 Spring Boot 的命令行界面。</p><ul><li>它可以用来快速启动 Spring 。</li><li>它可以运行 Groovy 脚本，开发人员不需要编写很多样板代码，只需要关注业务逻辑。</li><li>Spring Boot CLI 是创建基于Spring的应用程序的最快方法。</li></ul><blockquote><p>一般情况下，我们可以不看这块代码的代码。</p></blockquote><h2 id="spring-boot-test-模块"><a href="#spring-boot-test-模块" class="headerlink" title="spring-boot-test 模块"></a>spring-boot-test 模块</h2><p><code>spring-boot-test</code> 模块，大概 1W 行代码左右。Spring Boot 提供测试方面的支持，例如说：</p><ul><li>SpringBootTestRandomPortEnvironmentPostProcessor 类，提供随机端口。</li><li><code>org.springframework.boot.test.mock.mockito</code> 包，提供 Mockito 的增强。</li></ul><blockquote><p>一般情况下，我们可以不看这块代码的代码。</p></blockquote><h2 id="spring-boot-test-autoconfigure-模块"><a href="#spring-boot-test-autoconfigure-模块" class="headerlink" title="spring-boot-test-autoconfigure 模块"></a>spring-boot-test-autoconfigure 模块</h2><p><code>spring-boot-test-autoconfigure</code> 模块，大概 1W 行代码不到。它提供了 <code>spring-boot-test</code> 的自动配置功能。</p><blockquote><p>一般情况下，我们可以不看这块代码的代码。</p></blockquote><h2 id="spring-boot-devtools-模块"><a href="#spring-boot-devtools-模块" class="headerlink" title="spring-boot-devtools 模块"></a>spring-boot-devtools 模块</h2><p><code>spring-boot-devtools</code> 模块，大概 8000 行代码左右。通过它，来使 Spring Boot 应用支持热部署，提高开发者的开发效率，无需手动重启 Spring Boot 应用。</p><blockquote><p>一般情况下，我们可以不看这块代码的代码。</p></blockquote><h2 id="spring-boot-tools-模块"><a href="#spring-boot-tools-模块" class="headerlink" title="spring-boot-tools 模块"></a>spring-boot-tools 模块</h2><p><code>spring-boot-tools</code> 模块，大概 3W 行代码左右。它是 Spring Boot 提供的工具箱，所以在其内有多个子 Maven 项目。</p><p>注意哟，我们这里说的工具箱，并不是我们在 Java 里的工具类。困惑？我们来举个例子：<code>spring-boot-maven-plugin</code> 模块：提供 Maven 打包 Spring Boot 项目的插件。</p><p>关于 <code>spring-boot-tools</code> 模块的其它子模块，我们就暂时不多做介绍落。</p><blockquote><p>一般情况下，我们可以不看这块代码的代码。</p></blockquote><h1 id="spring-boot-samples-项目"><a href="#spring-boot-samples-项目" class="headerlink" title="spring-boot-samples 项目"></a>spring-boot-samples 项目</h1><p><code>spring-boot-samples</code> 项目，2W 行代码左右。丧心病狂，提供了超级多的示例，简直良心无敌啊。</p><blockquote><p>一般情况下，我们可以不看这块代码的代码。如果真的需要某个 Spring Boot 对某个框架的示例，大多数情况下，我们还是 Google 检索文章居多。</p></blockquote><h1 id="spring-boot-samples-invoker-项目"><a href="#spring-boot-samples-invoker-项目" class="headerlink" title="spring-boot-samples-invoker 项目"></a>spring-boot-samples-invoker 项目</h1><p><code>spring-boot-samples-invoker</code> 项目，无代码，不用看。当然，也并不重要。</p><h1 id="spring-boot-tests"><a href="#spring-boot-tests" class="headerlink" title="spring-boot-tests"></a>spring-boot-tests</h1><p><code>spring-boot-tests</code> 项目，3000 行代码，主要是 Spring Boot 的集成测试、部署测试。</p><blockquote><p>一般情况下，我们可以不看这块代码的代码。</p></blockquote><h1 id="结尾"><a href="#结尾" class="headerlink" title="结尾"></a>结尾</h1><p>所以我们重点关注的应该是： spring-boot-project ： <code>spring-boot</code>  和 <code>spring-boot-autoconfigure</code> 和  <code>spring-boot-starters</code></p>]]></content>
    
    
    
    <tags>
      
      <tag>SpringBoot</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>springboot源码分析(01) - 搭建调试环境</title>
    <link href="/2021/07/29/springboot-source-01/"/>
    <url>/2021/07/29/springboot-source-01/</url>
    
    <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>为了更加深入理解<code>springboot</code>，近期开始阅读<code>springboot</code>的源码，话不多说，开干！</p><h1 id="依赖工具"><a href="#依赖工具" class="headerlink" title="依赖工具"></a>依赖工具</h1><ul><li>Maven (springboot好多版本都是使用Gradle构建，搭建的胖友们需注意)</li><li>Git</li><li>Jdk8+</li><li>IntelliJ IDEA</li></ul><h1 id="源码拉取"><a href="#源码拉取" class="headerlink" title="源码拉取"></a>源码拉取</h1><p>从官方仓库 <a href="https://github.com/spring-projects/spring-boot">https://github.com/spring-projects/spring-boot</a> <code>Fork</code> 出属于自己的仓库。</p><ul><li>为什么要 <code>Fork</code> ？既然开始阅读、调试源码，我们可能会写一些注释，有了自己的仓库，可以进行自由的提交。</li><li>本文使用的 springboot 版本为 <code>2.1.19.BUILD-SNAPSHOT</code> 。</li><li>使用 <code>IntelliJ IDEA</code> 从 <code>Fork</code> 出来的仓库拉取代码。因为 Spring 项目比较大，从仓库中拉取代码的时间会比较长。</li></ul><p>拉取完成后，Maven 会开始自动 <strong>Build</strong> 项目。因为 Build 的过程中，会下载非常多的依赖，请耐心等待。</p><h1 id="构建调试Demo"><a href="#构建调试Demo" class="headerlink" title="构建调试Demo"></a>构建调试Demo</h1><h2 id="解决-pom-的报错"><a href="#解决-pom-的报错" class="headerlink" title="解决 pom 的报错"></a>解决 pom 的报错</h2><p>在根目录的 <code>pom.xml</code> 中，会看到 <code>$&#123;disable.checks&#125;</code> 报错。它是用来配置，是否开启 Maven 代码检查的插件。因为，我们目的是为了调试代码，所以自然是去禁用它。仅仅需要在 <code>pom.xml</code> 配置如下：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">properties</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">revision</span>&gt;</span>2.1.19.BUILD-SNAPSHOT<span class="hljs-tag">&lt;/<span class="hljs-name">revision</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">main.basedir</span>&gt;</span>$&#123;basedir&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">main.basedir</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">disable.checks</span>&gt;</span>true<span class="hljs-tag">&lt;/<span class="hljs-name">disable.checks</span>&gt;</span>    <span class="hljs-comment">&lt;!-- 我是被加的 --&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">properties</span>&gt;</span><br></code></pre></td></tr></table></figure><h2 id="搭建-MVC-调试环境"><a href="#搭建-MVC-调试环境" class="headerlink" title="搭建 MVC 调试环境"></a>搭建 MVC 调试环境</h2><p>在 <code>spring-boot-tests</code>  下新模块 <code>spring-boot-xxx-tests</code>  &gt;  以后自己测试的模块都是放在里面, 在新建的模块下面再新建 <code>spring-boot-xxx-mvc-tests</code> </p><p>spring-boot-xxx-tests pom文件</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-meta">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">project</span> <span class="hljs-attr">xmlns</span>=<span class="hljs-string">&quot;http://maven.apache.org/POM/4.0.0&quot;</span></span><br><span class="hljs-tag"> <span class="hljs-attr">xmlns:xsi</span>=<span class="hljs-string">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span></span><br><span class="hljs-tag"> <span class="hljs-attr">xsi:schemaLocation</span>=<span class="hljs-string">&quot;http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd&quot;</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">parent</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-boot-tests<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework.boot<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>$&#123;revision&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">parent</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">modelVersion</span>&gt;</span>4.0.0<span class="hljs-tag">&lt;/<span class="hljs-name">modelVersion</span>&gt;</span><br><br><span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-boot-mengsu-tests<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">packaging</span>&gt;</span>pom<span class="hljs-tag">&lt;/<span class="hljs-name">packaging</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">modules</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">module</span>&gt;</span>spring-boot-xxx-mvc-tests<span class="hljs-tag">&lt;/<span class="hljs-name">module</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">modules</span>&gt;</span><br><br><span class="hljs-tag">&lt;<span class="hljs-name">description</span>&gt;</span>我的Spring Boot测试模块<span class="hljs-tag">&lt;/<span class="hljs-name">description</span>&gt;</span><br><br><span class="hljs-tag">&lt;<span class="hljs-name">properties</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">main.basedir</span>&gt;</span>$&#123;basedir&#125;/../..<span class="hljs-tag">&lt;/<span class="hljs-name">main.basedir</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">java.version</span>&gt;</span>1.8<span class="hljs-tag">&lt;/<span class="hljs-name">java.version</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">properties</span>&gt;</span><br><br><span class="hljs-tag">&lt;/<span class="hljs-name">project</span>&gt;</span><br></code></pre></td></tr></table></figure><p>spring-boot-xxx-mvc-tests pom文件</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-meta">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">project</span> <span class="hljs-attr">xmlns</span>=<span class="hljs-string">&quot;http://maven.apache.org/POM/4.0.0&quot;</span></span><br><span class="hljs-tag"> <span class="hljs-attr">xmlns:xsi</span>=<span class="hljs-string">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span></span><br><span class="hljs-tag"> <span class="hljs-attr">xsi:schemaLocation</span>=<span class="hljs-string">&quot;http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd&quot;</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">parent</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-boot-mengsu-tests<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework.boot<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>$&#123;revision&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">parent</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">modelVersion</span>&gt;</span>4.0.0<span class="hljs-tag">&lt;/<span class="hljs-name">modelVersion</span>&gt;</span><br><br><span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-boot-mengsu-mvc-tests<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">name</span>&gt;</span>我的Spring Boot测试模块 之 MVC部分<span class="hljs-tag">&lt;/<span class="hljs-name">name</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">description</span>&gt;</span>$&#123;project.name&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">description</span>&gt;</span><br><br><span class="hljs-tag">&lt;<span class="hljs-name">properties</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">main.basedir</span>&gt;</span>$&#123;basedir&#125;/../../..<span class="hljs-tag">&lt;/<span class="hljs-name">main.basedir</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">properties</span>&gt;</span><br><br><span class="hljs-tag">&lt;<span class="hljs-name">dependencies</span>&gt;</span><br><span class="hljs-comment">&lt;!-- Compile --&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework.boot<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-boot-starter-web<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">dependencies</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">build</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">plugins</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">plugin</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework.boot<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-boot-maven-plugin<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">plugin</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">plugins</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">build</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">project</span>&gt;</span><br></code></pre></td></tr></table></figure><p>新建Application 启动类</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> site.mengsu;<br><br><span class="hljs-keyword">import</span> org.springframework.boot.SpringApplication;<br><span class="hljs-keyword">import</span> org.springframework.boot.autoconfigure.SpringBootApplication;<br><span class="hljs-keyword">import</span> org.springframework.web.bind.annotation.GetMapping;<br><span class="hljs-keyword">import</span> org.springframework.web.bind.annotation.RestController;<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@Author</span>: mengsu</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@Date</span>: 2021/7/30</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@Description</span>:</span><br><span class="hljs-comment"> */</span><br><span class="hljs-meta">@RestController</span><br><span class="hljs-meta">@SpringBootApplication</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MyTestMVCApplication</span> </span>&#123;<br><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>SpringApplication.run(MyTestMVCApplication.class, args);<br>&#125;<br><br><span class="hljs-meta">@GetMapping</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">index</span> <span class="hljs-params">()</span> </span>&#123;<br><span class="hljs-keyword">return</span> <span class="hljs-string">&quot;success&quot;</span>;<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="测试运行"><a href="#测试运行" class="headerlink" title="测试运行"></a>测试运行</h2><p><code>MyTestMVCApplication</code> 启动，访问：<a href="http://localhost:8080/">http://localhost:8080/</a></p><p>返回：success，即为成功。</p>]]></content>
    
    
    
    <tags>
      
      <tag>SpringBoot</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Nacos配置中心</title>
    <link href="/2021/07/27/nacos-config/"/>
    <url>/2021/07/27/nacos-config/</url>
    
    <content type="html"><![CDATA[<h1 id="概念"><a href="#概念" class="headerlink" title="概念"></a><a href="https://github.com/alibaba/spring-cloud-alibaba/wiki/Nacos-config#spring-cloud-alibaba-nacos-config">概念</a></h1><p>Nacos 提供用于存储配置和其他元数据的 key/value 存储，为分布式系统中的外部化配置提供服务器端和客户端支持。使用 Spring Cloud Alibaba Nacos Config，您可以在 Nacos Server 集中管理你 Spring Cloud 应用的外部属性配置。</p><p>Spring Cloud Alibaba Nacos Config 是 Config Server 和 Client 的替代方案，客户端和服务器上的概念与 Spring Environment 和 PropertySource 有着一致的抽象，在特殊的 bootstrap 阶段，配置被加载到 Spring 环境中。当应用程序通过部署管道从开发到测试再到生产时，您可以管理这些环境之间的配置，并确保应用程序具有迁移时需要运行的所有内容。</p><h1 id="快速开始"><a href="#快速开始" class="headerlink" title="快速开始"></a>快速开始</h1><h2 id="引入依赖"><a href="#引入依赖" class="headerlink" title="引入依赖"></a>引入依赖</h2><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>   <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>com.alibaba.cloud<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>   <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-cloud-alibaba-dependencies<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>   <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>$&#123;spring.cloud.alibaba.version&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br>   <span class="hljs-tag">&lt;<span class="hljs-name">type</span>&gt;</span>pom<span class="hljs-tag">&lt;/<span class="hljs-name">type</span>&gt;</span><br>   <span class="hljs-tag">&lt;<span class="hljs-name">scope</span>&gt;</span>import<span class="hljs-tag">&lt;/<span class="hljs-name">scope</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>   <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>com.alibaba.cloud<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>   <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-cloud-starter-alibaba-nacos-config<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br></code></pre></td></tr></table></figure><h2 id="配置文件"><a href="#配置文件" class="headerlink" title="配置文件"></a>配置文件</h2><p>创建 <code>bootstrap.yaml</code>配置文件，添加 Nacos Config 相关配置。配置如下：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-attr">spring:</span><br>  <span class="hljs-attr">application:</span><br>    <span class="hljs-attr">name:</span> <span class="hljs-string">demo-application</span><br><br>  <span class="hljs-attr">cloud:</span><br>    <span class="hljs-attr">nacos:</span><br>      <span class="hljs-comment"># Nacos Config 配置项，对应 NacosConfigProperties 配置属性类</span><br>      <span class="hljs-attr">config:</span><br>        <span class="hljs-attr">server-addr:</span> <span class="hljs-number">127.0</span><span class="hljs-number">.0</span><span class="hljs-number">.1</span><span class="hljs-string">:8848</span> <span class="hljs-comment"># Nacos 服务器地址</span><br>        <span class="hljs-attr">namespace:</span> <span class="hljs-comment"># 使用的 Nacos 的命名空间，默认为 null</span><br>        <span class="hljs-attr">group:</span> <span class="hljs-string">DEFAULT_GROUP</span> <span class="hljs-comment"># 使用的 Nacos 配置分组，默认为 DEFAULT_GROUP</span><br>        <span class="hljs-attr">name:</span> <span class="hljs-comment"># 使用的 Nacos 配置集的 dataId，默认为 spring.application.name</span><br>        <span class="hljs-attr">file-extension:</span> <span class="hljs-string">yaml</span> <span class="hljs-comment"># 使用的 Nacos 配置集的 dataId 的文件拓展名，同时也是 Nacos 配置集的配置格式，默认为 properties</span><br><br></code></pre></td></tr></table></figure><p>Nacos Config 配置项，以 <code>spring.cloud.nacos.config</code> 开头，对应 <a href="https://github.com/alibaba/spring-cloud-alibaba/blob/master/spring-cloud-alibaba-nacos-config/src/main/java/com/alibaba/cloud/nacos/NacosConfigProperties.java">NacosConfigProperties</a> 配置属性类。</p><ol><li><p><code>server-addr</code> 配置项，设置 Nacos 服务器地址。</p></li><li><p><code>namespace</code> 配置项，使用的 Nacos 的命名空间，默认为 <code>null</code>，表示使用 <code>public</code> 这个默认命名空间。</p></li></ol><blockquote><p>FROM <a href="https://nacos.io/zh-cn/docs/concepts.html">《Nacos 文档 —— Nacos 概念》</a></p><p><strong>命名空间</strong><br>用于进行租户粒度的配置隔离。不同的命名空间下，可以存在相同的 Group 或 Data ID 的配置。Namespace 的常用场景之一是不同环境的配置的区分隔离，例如开发测试环境和生产环境的资源（如配置、服务）隔离等。</p></blockquote><ol start="3"><li><code>group</code> 配置项，使用的 Nacos 配置分组，默认为 <code>DEFAULT_GROUP</code>。</li></ol><blockquote><p>FROM <a href="https://nacos.io/zh-cn/docs/concepts.html">《Nacos 文档 —— Nacos 概念》</a></p><p><strong>配置分组</strong><br>Nacos 中的一组配置集，是组织配置的维度之一。通过一个有意义的字符串（如 Buy 或 Trade ）对配置集进行分组，从而区分 Data ID 相同的配置集。当您在 Nacos 上创建一个配置时，如果未填写配置分组的名称，则配置分组的名称默认采用 <code>DEFAULT_GROUP</code> 。配置分组的常见场景：不同的应用或组件使用了相同的配置类型，如 <code>database_url</code> 配置和 <code>MQ_topic</code> 配置。</p></blockquote><ol start="4"><li><code>name</code> 配置项，使用的 Nacos 配置集的 dataId，默认为 <code>spring.application.name</code>。</li></ol><blockquote><p>FROM <a href="https://nacos.io/zh-cn/docs/concepts.html">《Nacos 文档 —— Nacos 概念》</a></p><p><strong>配置集</strong><br>一组相关或者不相关的配置项的集合称为配置集。在系统中，一个配置文件通常就是一个配置集，包含了系统各个方面的配置。例如，一个配置集可能包含了数据源、线程池、日志级别等配置项。</p><p><strong>配置集 ID</strong><br>Nacos 中的某个配置集的 ID。配置集 ID 是组织划分配置的维度之一。Data ID 通常用于组织划分系统的配置集。一个系统或者应用可以包含多个配置集，每个配置集都可以被一个有意义的名称标识。Data ID 通常采用类 Java 包（如 <code>com.taobao.tc.refund.log.level</code>）的命名规则保证全局唯一性。此命名规则非强制。</p></blockquote><p>因为这里我们未进行配置，所以使用 Nacos 配置集的 dataId 为 <code>demo-application</code>。这也是为什么我们将 <code>spring.application.name</code> 配置项添加到 <code>bootstrap.yaml</code> 配置文件中的原因。</p><ol start="5"><li><code>file-extension</code> 配置项，使用的 Nacos 配置集的 dataId 的<strong>文件拓展名</strong>，同时也是 Nacos 配置集的<strong>配置格式</strong>，默认为 <code>properties</code>。这里我们设置为 <code>yaml</code>，因为我们稍后使用的配置集的配置格式为 <code>YAML</code>。</li></ol><h3 id="bootstrap-yaml"><a href="#bootstrap-yaml" class="headerlink" title="bootstrap.yaml"></a>bootstrap.yaml</h3><blockquote><p>为什么要将 Nacos Config 的配置项添加到 <code>bootstrap.yaml</code> 配置文件，而不像我们之前的一样，添加到 <code>application.yaml</code> 配置文件中呢？</p><p>下面，我们来讲解下原因</p></blockquote><p>在 Spring Cloud 应用中，会先创建一个 <strong>Bootstrap</strong> Context（<strong>引导</strong>上下文），比 Spring Boot 创建 <strong>Application</strong> Context（<strong>应用</strong>上下文）<strong>更早初始化</strong>。</p><p>Bootstrap Context 新增了一个 <code>bootstrap.yaml</code> <strong>配置文件</strong>，保证和 Application Context 的 <code>application.yaml</code> <strong>配置文件</strong>的<strong>隔离</strong>。</p><p>有了配置文件的隔离之后，Bootstrap Context 初始化的 <strong>Bean</strong> 从哪里来？Spring Cloud 新定义了专属于 Bootstrap Context 的自动化配置类的拓展点 <strong>BootstrapConfiguration</strong>，和 Spring Boot 为 Application Context 的自动化配置类的拓展点 <strong>EnableAutoConfiguration</strong>的<strong>隔离</strong>，保证两个 Context 创建各自的 Bean。</p><p>虽然说，Bootstrap Context 和 Application Context 做了这么多隔离，但是它们有一点是共享的，那就是 <strong>Environment</strong>。在 Spring 中，我们通过 Environment 获取属性配置，例如说 <code>spring.application.name</code> 对应的值是多少。</p><p>了解完这些之后，我们把它们串联在一起去思考一下，Bootstrap Context 的<strong>目的</strong>究竟是什么呢？通过 Bootstrap Context 的优先初始化，<strong>将配置加载到 Environment 中</strong>，提供给后面的 Application Context 使用。</p><p>举个贼重要的例子，稍后我们会在 <code>bootstrap.yaml</code> 添加 Spring Cloud Alibaba Nacos Config 相关的配置，这样 Bootstrap Context 在初始化时，通过 NacosConfigBootstrapConfiguration 创建 Nacos 相关的 Bean，然后实现从 Nacos 配置中心加载配置到 Environment 中。</p><p>如果我们把 Spring Cloud Alibaba Nacos Config 相关的配置添加在 <code>application.yaml</code> 中，那么可能无法保证 Nacos 相关的 Bean 被<strong>最先</strong>初始化，完成从 Nacos 获取配置，从而影响创建的 Bean。</p><h2 id="创建-Nacos-配置集"><a href="#创建-Nacos-配置集" class="headerlink" title="创建 Nacos 配置集"></a>创建 Nacos 配置集</h2><p>打开 Nacos UI 界面的「配置列表」菜单，进入「配置管理」功能。如下图所示：</p><p><img src="/images/nacos/nacos-config-save.png"></p><h2 id="编写代码"><a href="#编写代码" class="headerlink" title="编写代码"></a>编写代码</h2><p>创建 OrderProperties配置类，读取 <code>order</code> 配置项。代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Component</span><br><span class="hljs-meta">@ConfigurationProperties(prefix = &quot;order&quot;)</span><br><span class="hljs-comment">// @NacosConfigurationProperties(prefix = &quot;order&quot;, dataId = &quot;$&#123;nacos.config.data-id&#125;&quot;, type = ConfigType.YAML)</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">OrderProperties</span> </span>&#123;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 订单支付超时时长，单位：秒。</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-keyword">private</span> Integer payTimeoutSeconds;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 订单创建频率，单位：秒</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-keyword">private</span> Integer createFrequencySeconds;<br><br>    <span class="hljs-comment">// ... 省略 setter/getter 方法</span><br><br>&#125;<br></code></pre></td></tr></table></figure><ul><li>在类上，添加 <code>@Component</code> 注解，保证该配置类可以作为一个 Bean 被扫描到。</li><li>在类上，添加 <code>@ConfigurationProperties</code> 注解，并设置 <code>prefix = &quot;order&quot;</code> 属性，这样它就可以读取<strong>前缀</strong>为 <code>order</code> 配置项，设置到配置类对应的属性上。</li></ul><p>创建 DemoController类，提供测试 <code>@ConfigurationProperties</code> 和 <code>@Value</code> 注入配置的两个 HTTP 接口。代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@RestController</span><br><span class="hljs-meta">@RequestMapping(&quot;/demo&quot;)</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">DemoController</span> </span>&#123;<br><br>    <span class="hljs-meta">@Autowired</span><br>    <span class="hljs-keyword">private</span> OrderProperties orderProperties;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 测试 <span class="hljs-doctag">@ConfigurationProperties</span> 注解的配置属性类</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-meta">@GetMapping(&quot;/test01&quot;)</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> OrderProperties <span class="hljs-title">test01</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> orderProperties;<br>    &#125;<br><br>    <span class="hljs-meta">@Value(value = &quot;$&#123;order.pay-timeout-seconds&#125;&quot;)</span> <span class="hljs-comment">// @NacosValue(value = &quot;$&#123;order.pay-timeout-seconds&#125;&quot;)</span><br>    <span class="hljs-keyword">private</span> Integer payTimeoutSeconds;<br>    <span class="hljs-meta">@Value(value = &quot;$&#123;order.create-frequency-seconds&#125;&quot;)</span> <span class="hljs-comment">// @NacosValue(value = &quot;$&#123;order.create-frequency-seconds&#125;&quot;)</span><br>    <span class="hljs-keyword">private</span> Integer createFrequencySeconds;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 测试 <span class="hljs-doctag">@Value</span> 注解的属性</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-meta">@GetMapping(&quot;/test02&quot;)</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> Map&lt;String, Object&gt; <span class="hljs-title">test02</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> JSONObject().fluentPut(<span class="hljs-string">&quot;payTimeoutSeconds&quot;</span>, payTimeoutSeconds)<br>                .fluentPut(<span class="hljs-string">&quot;createFrequencySeconds&quot;</span>, createFrequencySeconds);<br>    &#125;<br><br>&#125;<br></code></pre></td></tr></table></figure><h2 id="简单测试"><a href="#简单测试" class="headerlink" title="简单测试"></a>简单测试</h2><p>访问 <a href="http://127.0.0.1:8080/demo/test01">http://127.0.0.1:8080/demo/test01</a> 接口</p><p>访问 <a href="http://127.0.0.1:8080/demo/test02">http://127.0.0.1:8080/demo/test02</a> 接口</p><p>结果：</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs json">&#123;<br>    <span class="hljs-attr">&quot;payTimeoutSeconds&quot;</span>: <span class="hljs-number">60</span>,<br>    <span class="hljs-attr">&quot;createFrequencySeconds&quot;</span>: <span class="hljs-number">120</span><br>&#125;<br></code></pre></td></tr></table></figure><h1 id="自动刷新配置"><a href="#自动刷新配置" class="headerlink" title="自动刷新配置"></a>自动刷新配置</h1><ul><li>使用 <code>@ConfigurationProperties</code> 注解，使用 <code>@Value</code> 注解的<strong>不会</strong></li><li>使用 <code>@RefreshScope</code> 注解，</li></ul><h2 id="EnvironmentChangeEvent"><a href="#EnvironmentChangeEvent" class="headerlink" title="EnvironmentChangeEvent"></a>EnvironmentChangeEvent</h2><p>通过 <code>@ConfigurationProperties</code> 或者 <code>@Value</code> + <code>@RefreshScope</code> 注解，已经能够满足我们绝大多数场景下的自动刷新配置的功能。但是，在一些场景下，我们仍然需要<strong>实现对配置的监听，执行自定义的逻辑</strong>。</p><p>例如说，当数据库连接的配置发生变更时，我们需要通过监听该配置的变更，重新初始化应用中的数据库连接，从而访问到新的数据库地址。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Component</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">DemoEnvironmentChangeListener</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">ApplicationListener</span>&lt;<span class="hljs-title">EnvironmentChangeEvent</span>&gt; </span>&#123;<br><br>    <span class="hljs-keyword">private</span> Logger logger = LoggerFactory.getLogger(getClass());<br><br>    <span class="hljs-meta">@Autowired</span><br>    <span class="hljs-keyword">private</span> ConfigurableEnvironment environment;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">onApplicationEvent</span><span class="hljs-params">(EnvironmentChangeEvent event)</span> </span>&#123;<br>        <span class="hljs-keyword">for</span> (String key : event.getKeys()) &#123;<br>            logger.info(<span class="hljs-string">&quot;[onApplicationEvent][key(&#123;&#125;) 最新 value 为 &#123;&#125;]&quot;</span>, key, environment.getProperty(key));<br>        &#125;<br>    &#125;<br><br>&#125;<br></code></pre></td></tr></table></figure><h1 id="官方文档"><a href="#官方文档" class="headerlink" title="官方文档"></a>官方文档</h1><ul><li><a href="https://nacos.io/zh-cn/docs/what-is-nacos.html">《Nacos 官方文档》</a></li><li><a href="https://github.com/alibaba/spring-cloud-alibaba/wiki/Nacos-config">《Spring Cloud Alibaba 官方<strong>文档</strong> —— Nacos Config》</a></li><li><a href="https://github.com/alibaba/spring-cloud-alibaba/blob/master/spring-cloud-alibaba-examples/nacos-example/nacos-config-example/readme-zh.md">《Spring Cloud Alibaba 官方<strong>示例</strong> —— Nacos Config》</a></li></ul>]]></content>
    
    
    
    <tags>
      
      <tag>Nacos</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Nacos数据模型</title>
    <link href="/2021/07/27/nacos-data-model/"/>
    <url>/2021/07/27/nacos-data-model/</url>
    
    <content type="html"><![CDATA[<h2 id="数据模型"><a href="#数据模型" class="headerlink" title="数据模型"></a>数据模型</h2><p>Nacos 数据模型 Key 由三元组唯一确认。如下图所示：</p><p><img src="/images/nacos/nacos-data-model.jpeg" alt="点击"></p><ul><li>作为注册中心时，Namespace + Group + Service</li><li>作为配置中心时，Namespace + Group + DataId</li></ul><h2 id="Namespace-命名空间"><a href="#Namespace-命名空间" class="headerlink" title="Namespace 命名空间"></a>Namespace 命名空间</h2><p>用于进行租户粒度的配置隔离。默认为 public（公共命名空间）。</p><p>不同的命名空间下，可以存在相同的 Group 或 Data ID 的配置。Namespace 的常用场景之一是不同环境的配置的区分隔离，例如开发测试环境和生产环境的资源（如配置、服务）隔离等。</p><h2 id="Group-服务分组"><a href="#Group-服务分组" class="headerlink" title="Group 服务分组"></a>Group 服务分组</h2><p>不同的服务可以归类到同一分组。默认为 DEFAULT_GROUP（默认分组）。</p><h2 id="Service-服务"><a href="#Service-服务" class="headerlink" title="Service 服务"></a>Service 服务</h2><p>例如说，用户服务、订单服务、商品服务等等。</p><h2 id="官方文档"><a href="#官方文档" class="headerlink" title="官方文档"></a>官方文档</h2><ul><li><a href="https://nacos.io/zh-cn/docs/what-is-nacos.html">《Nacos 官方文档 —— 概念》</a></li><li><a href="https://nacos.io/zh-cn/docs/architecture.html">《Nacos 官方文档 —— 架构》</a></li></ul>]]></content>
    
    
    
    <tags>
      
      <tag>Nacos</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Nacos注册中心</title>
    <link href="/2021/07/27/nacos-discovery/"/>
    <url>/2021/07/27/nacos-discovery/</url>
    
    <content type="html"><![CDATA[<h3 id="服务发现和服务健康监测"><a href="#服务发现和服务健康监测" class="headerlink" title="服务发现和服务健康监测"></a><strong>服务发现和服务健康监测</strong></h3><p>Nacos 支持基于 DNS 和基于 RPC 的服务发现。服务提供者使用 <a href="https://nacos.io/zh-cn/docs/sdk.html">原生SDK</a>、<a href="https://nacos.io/zh-cn/docs/open-api.html">OpenAPI</a>、或一个<a href="https://nacos.io/zh-cn/docs/other-language.html">独立的Agent TODO</a>注册 Service 后，服务消费者可以使用<a href="https://nacos.io/zh-cn/docs/xx">DNS TODO</a> 或<a href="https://nacos.io/zh-cn/docs/open-api.html">HTTP&amp;API</a>查找和发现服务。</p><p>Nacos 提供对服务的实时的健康检查，阻止向不健康的主机或服务实例发送请求。Nacos 支持传输层 (PING 或 TCP)和应用层 (如 HTTP、MySQL、用户自定义）的健康检查。 对于复杂的云环境和网络拓扑环境中（如 VPC、边缘网络等）服务的健康检查，Nacos 提供了 agent 上报模式和服务端主动检测2种健康检查模式。Nacos 还提供了统一的健康检查仪表盘，帮助您根据健康状态管理服务的可用性及流量。</p><h3 id="注册中心原理"><a href="#注册中心原理" class="headerlink" title="注册中心原理"></a>注册中心原理</h3><p>在使用注册中心时，一共有三种角色：服务提供者（Service Provider）、服务消费者（Service Consumer）、注册中心（Registry）。</p><p><img src="/images/nacos/nacos-dis.png" alt="点击"></p><ol><li>Provider：</li></ol><ul><li>启动时，向 Registry <strong>注册</strong>自己为一个服务（Service）的实例（Instance）。</li><li>同时，定期向 Registry 发送<strong>心跳</strong>，告诉自己还存活。</li><li>关闭时，向 Registry <strong>取消注册</strong>。</li></ul><ol start="2"><li>Consumer：</li></ol><ul><li>启动时，向 Registry <strong>订阅</strong>使用到的服务，并缓存服务的实例列表在内存中。</li><li>后续，Consumer 向对应服务的 Provider 发起<strong>调用</strong>时，从内存中的该服务的实例列表选择一个，进行远程调用。</li><li>关闭时，向 Registry <strong>取消订阅</strong>。</li></ul><ol start="3"><li>Registry：</li></ol><ul><li>Provider 超过一定时间未<strong>心跳</strong>时，从服务的实例列表移除。</li><li>服务的实例列表发生变化（新增或者移除）时，通知订阅该服务的 Consumer，从而让 Consumer 能够刷新本地缓存。</li></ul><p>当然，不同的注册中心可能在实现原理上会略有差异。例如说，<a href="https://github.com/Netflix/eureka/">Eureka</a> 注册中心，并不提供通知功能，而是 Eureka Client 自己定期轮询，实现本地缓存的更新。</p><p>另外，Provider 和 Consumer 是角色上的定义，一个服务<strong>同时</strong>即可以是 Provider 也可以作为 Consumer。例如说，优惠劵服务可以给订单服务提供接口，同时又调用用户服务提供的接口。</p><h3 id="快速开始"><a href="#快速开始" class="headerlink" title="快速开始"></a>快速开始</h3><h4 id="引入依赖"><a href="#引入依赖" class="headerlink" title="引入依赖"></a>引入依赖</h4><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>com.alibaba.cloud<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-cloud-alibaba-dependencies<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>$&#123;spring.cloud.alibaba.version&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">type</span>&gt;</span>pom<span class="hljs-tag">&lt;/<span class="hljs-name">type</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">scope</span>&gt;</span>import<span class="hljs-tag">&lt;/<span class="hljs-name">scope</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>com.alibaba.cloud<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-cloud-starter-alibaba-nacos-discovery<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br></code></pre></td></tr></table></figure><h4 id="生产者"><a href="#生产者" class="headerlink" title="生产者"></a>生产者</h4><p>配置文件</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-attr">spring:</span><br>  <span class="hljs-attr">application:</span><br>    <span class="hljs-attr">name:</span> <span class="hljs-string">demo-provider</span> <span class="hljs-comment"># Spring 应用名</span><br>  <span class="hljs-attr">cloud:</span><br>    <span class="hljs-attr">nacos:</span><br>      <span class="hljs-comment"># Nacos 作为注册中心的配置项，对应 NacosDiscoveryProperties 配置类</span><br>      <span class="hljs-attr">discovery:</span><br>        <span class="hljs-attr">server-addr:</span> <span class="hljs-number">127.0</span><span class="hljs-number">.0</span><span class="hljs-number">.1</span><span class="hljs-string">:8848</span> <span class="hljs-comment"># Nacos 服务器地址</span><br>        <span class="hljs-attr">service:</span> <span class="hljs-string">$&#123;spring.application.name&#125;</span> <span class="hljs-comment"># 注册到 Nacos 的服务名。默认值为 $&#123;spring.application.name&#125;。</span><br><br><span class="hljs-attr">server:</span><br>  <span class="hljs-attr">port:</span> <span class="hljs-number">18080</span> <span class="hljs-comment"># 服务器端口。默认为 8080</span><br></code></pre></td></tr></table></figure><p>重点看 <code>spring.cloud.nacos.discovery</code> 配置项，它是 Nacos Discovery 配置项的前缀，对应 <a href="https://github.com/alibaba/spring-cloud-alibaba/blob/master/spring-cloud-alibaba-nacos-discovery/src/main/java/com/alibaba/cloud/nacos/NacosDiscoveryProperties.java">NacosDiscoveryProperties</a> 配置项。</p><p>创建 DemoProviderApplication 类，创建应用启动类，并提供 HTTP 接口。代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@SpringBootApplication</span><br><span class="hljs-meta">@EnableDiscoveryClient</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">DemoProviderApplication</span> </span>&#123;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>        SpringApplication.run(DemoProviderApplication.class, args);<br>    &#125;<br><br>    <span class="hljs-meta">@RestController</span><br>    <span class="hljs-keyword">static</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">TestController</span> </span>&#123;<br><br>        <span class="hljs-meta">@GetMapping(&quot;/echo&quot;)</span><br>        <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">echo</span><span class="hljs-params">(String name)</span> </span>&#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;provider:&quot;</span> + name;<br>        &#125;<br><br>    &#125;<br><br>&#125;<br></code></pre></td></tr></table></figure><ol><li><p><code>@SpringBootApplication</code> 注解，被添加在类上，声明这是一个 Spring Boot 应用。Spring Cloud 是构建在 Spring Boot 之上的，所以需要添加。</p></li><li><p><a href="https://github.com/spring-cloud/spring-cloud-commons/blob/master/spring-cloud-commons/src/main/java/org/springframework/cloud/client/discovery/EnableDiscoveryClient.java"><code>@EnableDiscoveryClient</code></a> 注解，开启 Spring Cloud 的注册发现功能。不过从 Spring Cloud Edgware 版本开始，实际上已经不需要添加 <code>@EnableDiscoveryClient</code> 注解，只需要引入 Spring Cloud 注册发现组件，就会自动开启注册发现的功能。例如说，我们这里已经引入了 <code>spring-cloud-starter-alibaba-nacos-discovery</code> 依赖，就不用再添加 <code>@EnableDiscoveryClient</code> 注解了。</p></li></ol><h4 id="消费者"><a href="#消费者" class="headerlink" title="消费者"></a>消费者</h4><p>配置文件</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-attr">spring:</span><br>  <span class="hljs-attr">application:</span><br>    <span class="hljs-attr">name:</span> <span class="hljs-string">demo-provider</span> <span class="hljs-comment"># Spring 应用名</span><br>  <span class="hljs-attr">cloud:</span><br>    <span class="hljs-attr">nacos:</span><br>      <span class="hljs-comment"># Nacos 作为注册中心的配置项，对应 NacosDiscoveryProperties 配置类</span><br>      <span class="hljs-attr">discovery:</span><br>        <span class="hljs-attr">server-addr:</span> <span class="hljs-number">127.0</span><span class="hljs-number">.0</span><span class="hljs-number">.1</span><span class="hljs-string">:8848</span> <span class="hljs-comment"># Nacos 服务器地址</span><br>        <span class="hljs-attr">service:</span> <span class="hljs-string">$&#123;spring.application.name&#125;</span> <span class="hljs-comment"># 注册到 Nacos 的服务名。默认值为 $&#123;spring.application.name&#125;。</span><br><br><span class="hljs-attr">server:</span><br>  <span class="hljs-attr">port:</span> <span class="hljs-number">28080</span> <span class="hljs-comment"># 服务器端口。默认为 8080</span><br></code></pre></td></tr></table></figure><p>创建 DemoConsumerApplication类，创建应用启动类，并提供一个调用服务提供者的 HTTP 接口。代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@SpringBootApplication</span><br><span class="hljs-comment">// @EnableDiscoveryClient</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">DemoConsumerApplication</span> </span>&#123;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>        SpringApplication.run(DemoConsumerApplication.class, args);<br>    &#125;<br><br>    <span class="hljs-meta">@Configuration</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">RestTemplateConfiguration</span> </span>&#123;<br><br>        <span class="hljs-meta">@Bean</span><br>        <span class="hljs-function"><span class="hljs-keyword">public</span> RestTemplate <span class="hljs-title">restTemplate</span><span class="hljs-params">()</span> </span>&#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> RestTemplate();<br>        &#125;<br><br>    &#125;<br><br>    <span class="hljs-meta">@RestController</span><br>    <span class="hljs-keyword">static</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">TestController</span> </span>&#123;<br><br>        <span class="hljs-meta">@Autowired</span><br>        <span class="hljs-keyword">private</span> DiscoveryClient discoveryClient;<br>        <span class="hljs-meta">@Autowired</span><br>        <span class="hljs-keyword">private</span> RestTemplate restTemplate;<br>        <span class="hljs-meta">@Autowired</span><br>        <span class="hljs-keyword">private</span> LoadBalancerClient loadBalancerClient;<br><br>        <span class="hljs-meta">@GetMapping(&quot;/hello&quot;)</span><br>        <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">hello</span><span class="hljs-params">(String name)</span> </span>&#123;<br>            <span class="hljs-comment">// &lt;1&gt; 获得服务 `demo-provider` 的一个实例</span><br>            ServiceInstance instance;<br>            <span class="hljs-keyword">if</span> (<span class="hljs-keyword">true</span>) &#123;<br>                <span class="hljs-comment">// 获取服务 `demo-provider` 对应的实例列表</span><br>                List&lt;ServiceInstance&gt; instances = discoveryClient.getInstances(<span class="hljs-string">&quot;demo-provider&quot;</span>);<br>                <span class="hljs-comment">// 选择第一个</span><br>                instance = instances.size() &gt; <span class="hljs-number">0</span> ? instances.get(<span class="hljs-number">0</span>) : <span class="hljs-keyword">null</span>;<br>            &#125; <span class="hljs-keyword">else</span> &#123;<br>                instance = loadBalancerClient.choose(<span class="hljs-string">&quot;demo-provider&quot;</span>);<br>            &#125;<br>            <span class="hljs-comment">// &lt;2&gt; 发起调用</span><br>            <span class="hljs-keyword">if</span> (instance == <span class="hljs-keyword">null</span>) &#123;<br>                <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> IllegalStateException(<span class="hljs-string">&quot;获取不到实例&quot;</span>);<br>            &#125;<br>            String targetUrl = instance.getUri() + <span class="hljs-string">&quot;/echo?name=&quot;</span> + name;<br>            String response = restTemplate.getForObject(targetUrl, String.class);<br>            <span class="hljs-comment">// 返回结果</span><br>            <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;consumer:&quot;</span> + response;<br>        &#125;<br><br>    &#125;<br><br>&#125;<br></code></pre></td></tr></table></figure><ol><li><p><code>@EnableDiscoveryClient</code> 注解，因为已经无需添加，所以我们进行了注释，原因在上面已经解释过。</p></li><li><p>RestTemplateConfiguration 配置类，创建 <a href="https://github.com/spring-projects/spring-framework/blob/master/spring-web/src/main/java/org/springframework/web/client/RestTemplate.java">RestTemplate</a> Bean。RestTemplate 是 Spring 提供的 HTTP 调用模板工具类，可以方便我们稍后调用服务提供者的 HTTP API。</p></li><li><p>TestController 提供了 <code>/hello</code> 接口，用于调用服务提供者的 <code>/demo</code> 接口。代码略微有几行，我们来稍微解释下哈。</p></li></ol><p><code>discoveryClient</code> 属性，DiscoveryClient 对象，服务发现客户端，上文我们已经介绍过。这里我们注入的不是 Nacos Discovery 提供的 NacosDiscoveryClient，保证通用性。未来如果我们不使用 Nacos 作为注册中心，而是使用 Eureka 或则 Zookeeper 时，则无需改动这里的代码。</p><p><code>loadBalancerClient</code> 属性，<a href="https://github.com/spring-cloud/spring-cloud-commons/blob/master/spring-cloud-commons/src/main/java/org/springframework/cloud/client/loadbalancer/LoadBalancerClient.java">LoadBalancerClient</a> 对象，负载均衡客户端。稍后我们会使用它，从 Nacos 获取的服务 <code>demo-provider</code> 的实例列表中，选择一个进行 HTTP 调用。</p><blockquote><p>拓展小知识：在 Spring Cloud Common 项目中，定义了<a href="https://github.com/spring-cloud/spring-cloud-commons/blob/master/spring-cloud-commons/src/main/java/org/springframework/cloud/client/loadbalancer/LoadBalancerClient.java">LoadBalancerClient</a> 接口，作为通用的负载均衡客户端，提供从指定服务中选择一个实例、对指定服务发起请求等 API 方法。而想要集成到 Spring Cloud 体系的负载均衡的组件，需要提供对应的 LoadBalancerClient 实现类。</p><p>例如说，Spring Cloud Netflix Ribbon 提供了 <a href="https://github.com/spring-cloud/spring-cloud-netflix/blob/2.2.x/spring-cloud-netflix-ribbon/src/main/java/org/springframework/cloud/netflix/ribbon/RibbonLoadBalancerClient.java">RibbonLoadBalancerClient</a> 实现。</p><p>如此，所有需要使用到的地方，只需要获取到 DiscoveryClient 客户端，而无需关注具体实现，保证其通用性。😈 不过貌似 Spring Cloud 体系中，暂时只有 Ribbon 一个负载均衡组件。</p><p>当然，LoadBalancerClient 的服务的实例列表，是来自 DiscoveryClient 提供的。</p></blockquote><p><code>/hello</code> 接口，示例接口，对服务提供者发起一次 HTTP 调用。</p><ul><li><code>&lt;1&gt;</code> 处，获得服务 <code>demo-provider</code> 的一个实例。这里我们提供了两种方式的代码，分别基于 DiscoveryClient 和 LoadBalancerClient。</li><li><code>&lt;2&gt;</code> 处，通过获取到的服务实例 ServiceInstance 对象，拼接请求的目标 URL，之后使用 RestTemplate 发起 HTTP 调用。</li></ul><h4 id="测试"><a href="#测试" class="headerlink" title="测试"></a>测试</h4><p>访问：<a href="http://127.0.0.1:28080/hello?name=mengsu">http://127.0.0.1:28080/hello?name=mengsu</a> ，返回结果为 <code>&quot;consumer:provider:mengsu&quot;</code>。说明，调用远程的<strong>服务提供者</strong>成功。</p>]]></content>
    
    
    
    <tags>
      
      <tag>Nacos</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Typora快捷键</title>
    <link href="/2021/07/26/Typora%E5%BF%AB%E6%8D%B7%E9%94%AE/"/>
    <url>/2021/07/26/Typora%E5%BF%AB%E6%8D%B7%E9%94%AE/</url>
    
    <content type="html"><![CDATA[<h1 id="Typora快捷键"><a href="#Typora快捷键" class="headerlink" title="Typora快捷键"></a>Typora快捷键</h1><p>最大标题：command + 1 或者：#<br> 大标题：command + 2 或者：##<br> 标准标题：command + 3 或者：###<br> 中标题：command + 4 或者：####<br> 小标题：command + 5 或者：#####<br> 插入表格：command + T<br> 插入代码：command + alt +c<br> 插入图片：cmd + ctrl + i<br> 行间公式 command + Alt + b<br> 段落：command + 0<br> 竖线 ： command + Alt +q<br> 无需列表：command+option+U<br> 有序列表（1. 2.） ：输入数字+“.”之后输 入空格 或者：command + Alt + o<br> 黑点标记：command + Alt + u<br> 隔离线shift + command + -<br> 超链接：command + Alt + l<br> 插入链接：command +k<br> 下划线：command +u<br> 加粗：command +b<br> 搜索：command +f<br> 引用：command+option+Q</p>]]></content>
    
    
    
    <tags>
      
      <tag>Typora</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Nacos安装运行</title>
    <link href="/2021/07/26/nacos-install/"/>
    <url>/2021/07/26/nacos-install/</url>
    
    <content type="html"><![CDATA[<h2 id="快速开始"><a href="#快速开始" class="headerlink" title="快速开始"></a><a href="https://nacos.io/zh-cn/">快速开始</a></h2><h3 id="Docker下载安装"><a href="#Docker下载安装" class="headerlink" title="Docker下载安装"></a>Docker下载安装</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">docker pull nacos/nacos-server<br></code></pre></td></tr></table></figure><h3 id="Docker查看镜像"><a href="#Docker查看镜像" class="headerlink" title="Docker查看镜像"></a>Docker查看镜像</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">docker images<br></code></pre></td></tr></table></figure><h3 id="Docker运行"><a href="#Docker运行" class="headerlink" title="Docker运行"></a>Docker运行</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs bash">docker run -d \<br>-e MODE=standalone \<br>-e SPRING_DATASOURCE_PLATFORM=mysql \<br>-e MYSQL_SERVICE_HOST=docker.for.mac.host.internal \<br>-e MYSQL_SERVICE_PORT=3306 \<br>-e MYSQL_SERVICE_USER=root \<br>-e MYSQL_SERVICE_PASSWORD=123456 \<br>-e MYSQL_SERVICE_DB_NAME=nacos_config \<br>-p 8848:8848 \<br>--restart=always \<br>nacos/nacos-server<br></code></pre></td></tr></table></figure><p>备注：连接数据库需要导入nacos自己的<a href="https://github.com/alibaba/nacos/edit/master/distribution/conf/nacos-mysql.sql">数据库脚本</a>，该模式为单机启动</p><h3 id="Docker查看运行状态"><a href="#Docker查看运行状态" class="headerlink" title="Docker查看运行状态"></a>Docker查看运行状态</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">docker ps<br></code></pre></td></tr></table></figure><h3 id="访问地址"><a href="#访问地址" class="headerlink" title="访问地址"></a>访问地址</h3><p><a href="http://127.0.0.1:8848/">http://127.0.0.1:8848/</a>  ，默认账密都是：nacos</p><h3 id="系统截图"><a href="#系统截图" class="headerlink" title="系统截图"></a>系统截图</h3><p><img src="/images/nacos/nacos-show.png" alt="点击"></p>]]></content>
    
    
    
    <tags>
      
      <tag>Nacos</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Hexo</title>
    <link href="/2021/07/23/hello-world/"/>
    <url>/2021/07/23/hello-world/</url>
    
    <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ hexo new <span class="hljs-string">&quot;My New Post&quot;</span><br></code></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ hexo server<br></code></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ hexo generate<br></code></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ hexo deploy<br></code></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>]]></content>
    
    
    
  </entry>
  
  
  
  
</search>
